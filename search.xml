<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux系统编程-文件I/O基础</title>
    <url>/2019/11/29/linux-programming-basic-io/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当C语言标准库已经提供了标准IO操作相关的一系列函数，为什么我们还需要学习系统IO呢？相信不少刚开始学习Linux系统编程的同学一定有这样的疑问。我们不妨站在一个较高的层次来看这个问题，比方说操作系统用户和编程语言使用者的角度。<a id="more"></a>显而易见，除了C语言，类似C++、Java、Python这样的高级语言都有IO操作，那么他们的IO操作是通过什么来实现呢？显然，需要更底层源于操作系统内核的支持。这也就是为什么我们需要学习系统IO。因为它处于内核，位于更低的层面来提供基础IO支持，当你学会系统IO后，对于很多用户空间上的IO操作，或是行业领域内更复杂的应用场景都将得心应手。</p>
<h3 id="基本读写"><a href="#基本读写" class="headerlink" title="基本读写"></a>基本读写</h3><p>来看一个基本读写的例子，我们往文件<code>demo.txt</code>中写入字符串hello world！然后再将此字符串从文件中读出，打印到终端上：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"demo.txt"</span>, O_RDWR|O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"hello world!"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> read_count = <span class="built_in">read</span>(fd, buf, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (read_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buf[read_count] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码以及注释可以看出文件读写的基本流程，大概分为4步：打开、写入、读取、关闭。看不懂不要紧，只需要有个基本印象即可。在接下来的几个小节当中，我将对每个步骤进行深入讲解，并且围绕讲解过程中提及的知识点进行一些进阶扩展。</p>
<h3 id="open打开文件"><a href="#open打开文件" class="headerlink" title="open打开文件"></a>open打开文件</h3><p>首先来看看打开操作，因为open是一个系统调用，所以在查看man手册时需要使用<code>man 2 open</code>命令。</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191127142436.png" alt=""></p>
<p>引入文档所述三个头文件后我们便可在代码中使用open打开<code>pathname</code>路径下的文件，并且设置一些<code>flags</code>参数进行操作。而<code>mode</code>则表示该文件的权限设置，通常只在创建文件时用得到。在open系统调用下方还有一个creat系统调用，用于创建文件。没错，你即可以用open来创建文件，也可以用creat来创建文件。打开或创建文件成功后，会返回一个指向该文件的文件描述符。</p>
<h4 id="flags-访问模式"><a href="#flags-访问模式" class="headerlink" title="flags 访问模式"></a>flags 访问模式</h4><p><code>pathname</code>十分容易理解，即需要打开的文件路径字符串指针。而flags你可以先简单的理解成文件的打开方式，不同的打开方式会导致不同的结果发生，若选择了错误的打开方式，轻则无法访问，重则覆盖掉文件内容。大家一定要小心！flags参数通过一个或多个标志位的按位或组合而成，它支持三种访问模式：<code>O_RDONLY</code> <code>O_WRONLY</code> <code>O_RDWR</code> ，分别表示只读、只写、可读可写。来举几个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fd1 = <span class="built_in">open</span>(<span class="string">"a.txt"</span>, O_RDONLY);          <span class="comment">// 只读</span></span><br><span class="line"><span class="keyword">int</span> fd2 = <span class="built_in">open</span>(<span class="string">"b.txt"</span>, O_WRONLY);          <span class="comment">// 只写</span></span><br><span class="line"><span class="keyword">int</span> fd3 = <span class="built_in">open</span>(<span class="string">"d.txt"</span>, O_RDWR);            <span class="comment">// 可读可写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记得每次打开后需要判断文件描述符是否等于-1</span></span><br><span class="line"><span class="comment">// 如果等于-1,则说明打开失败,此处仅判断一个以演示</span></span><br><span class="line"><span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"open"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不能对以只读模式打开的文件执行写操作，反之亦然。进程必须有足够的权限才能调用系统调用来打开文件。举个例子，假设用户对某个文件只有只读权限，该用户的进程只能以<code>O_RDONLY</code>模式打开文件，而不能以<code>O_WRONLY</code>或<code>O_RDWR</code>模式打开。 此外，flags还可以和其他值进行按位或运算，修改打开文件的行为。诸如：<code>O_APPEND</code> <code>O_ASYNC</code> <code>O_CLOEXEC</code> <code>O_CREAT</code> <code>O_DIRECT</code> <code>O_DIRECTORY</code> <code>O_DSYNC</code> <code>O_EXCL</code> <code>O_LARGEFILE</code> <code>O_NOATIME</code> <code>O_NOCTTY</code> <code>O_NOFOLLOW</code> <code>O_NONBLOCK</code> <code>O_NDELAY</code> <code>O_PATH</code> <code>O_SYNC</code> <code>O_TEMPFILE</code> <code>O_TRUNC</code>。详细信息，可以翻阅man手册。因为篇幅有限，无法一次性将这些flags讲解完，后续根据使用场景边用边讲。</p>
<h4 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h4><p>open系统调用除了能打开文件，也可根据指定的路径来新建文件。先来看看新建文件相关的两个flags：</p>
<ul>
<li>O_CREAT    当参数<code>pathname</code>指定的文件不存在时，内核自动创建。如果文件已存在，除非指定了标志位<code>O_EXCL</code>，否则该标志位无效。</li>
<li>O_EXCL     当和标志位<code>O_CREAT</code>一起使用时，如果参数<code>pathname</code>指定的文件已经存在，会导致open()调用失败。用于防止创建文件时出现竞争。如果没有和标志位<code>O_CREAT</code>一起使用，该标志位就没有任何含义。</li>
</ul>
<p>来写一个例子进行演示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1, fd2;</span><br><span class="line">    <span class="comment">// 用新建模式打开不存在的文件test.txt</span></span><br><span class="line">    fd1 = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件创建成功！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若上面的代码创建test.txt成功，那么此时便会打开一个已存在的文件</span></span><br><span class="line">    fd2 = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT|O_EXCL);</span><br><span class="line">    <span class="keyword">if</span> (fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件创建成功!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="built_in">close</span>(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">文件创建成功！</span><br><span class="line">文件创建失败: File exists</span><br></pre></td></tr></table></figure>

<h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p>除非新建文件，否则open系统调用会忽略mode参数。上面的示例使用了<code>O_CREAT</code>参数，却没有给出<code>mode</code>参数。 这通常会导致未定义的结果，并且很糟糕，如：创建的文件没有权限正常读写！我们来重新编写新建文件的代码，并加上<code>mode</code>参数。在重写之前，先要来了解一下<code>mode</code>参数的编写规则。实际上<code>mode</code>是常见的UNIX权限位集合，比如八进制数0644（文件所有者可以读写，其他人只能读）。通过翻阅<code>open</code>系统调用的手册，我们可以找到一组宏，每个宏通过按位或的方式来组合出权限集合，提供给<code>mode</code>参数。</p>
<table>
<thead>
<tr>
<th>S_IRWXU</th>
<th>00700</th>
<th>文件所有者有读、写和执行的权限</th>
</tr>
</thead>
<tbody><tr>
<td>S_IRUSR</td>
<td>00400</td>
<td>文件所有者有读权限</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>00200</td>
<td>文件所有者有写权限</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>00100</td>
<td>文件所有者有执行权限</td>
</tr>
<tr>
<td>S_IRWXG</td>
<td>00070</td>
<td>组用户有读、写和执行权限</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>00040</td>
<td>组用户有读权限</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>00020</td>
<td>组用户有写权限</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>00010</td>
<td>组用户有执行权限</td>
</tr>
<tr>
<td>S_IRWXO</td>
<td>00007</td>
<td>任何人都有读、写和执行的权限</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>00004</td>
<td>任何人都有读权限</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>00002</td>
<td>任何人都有写权限</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>00001</td>
<td>任何人都有执行权限</td>
</tr>
</tbody></table>
<p>好，既然知道了<code>mode</code>参数的编写规则，那么来重写下新建文件的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT, S_IWUSR|S_IRUSR|S_IWGRP|S_IRGRP|S_IWOTH|S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件创建成功\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    oclose(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ ./a.out </span><br><span class="line">文件创建成功</span><br><span class="line">➜ ls -l test.txt </span><br><span class="line">-rw-r--r-- 1 noir noir 0 11月 27 01:11 test.txt</span><br></pre></td></tr></table></figure>

<p>实际运用中，用一组宏按位与组合成权限集合还是有点繁琐。因此<code>mode</code>参数可直接使用八进制数来表示，<code>S_IWUSR|S_IRUSR|S_IWGRP|S_IRGRP|S_IWOTH|S_IROTH</code> 这一组合等同于八进制数0666，千万别忘了写0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br></pre></td></tr></table></figure>

<p>虽然上面的代码成功创建了文件，也增加了权限<code>mode</code>参数，那为什么实际文件权限却是<code>-rw-r--r--</code>，也就是644呢？因为最终写入磁盘的权限位是由<code>mode</code>参数和用户的文件创建掩码（umask）执行按位与操作而得到的。在系统调用open()中，umask位要和参数<code>mode</code>取反。因此umask 022和mode参数0666取反后，结果是0644。通过Linux命令<code>umask 002</code>可以变更掩码位，也可在代码中调用<code>umask</code>系统调用来执行此操作。先看看文档：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191127175029.png" alt=""></p>
<p>然后我们尝试在创建文件前修改umask值，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">umask(<span class="number">002</span>);</span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br></pre></td></tr></table></figure>

<p>程序执行完后，创建的新文件<code>test.txt</code>权限应该是0664。</p>
<h4 id="creat函数"><a href="#creat函数" class="headerlink" title="creat函数"></a>creat函数</h4><p>实际上，创建文件的操作十分常见，除了<code>open</code>，系统还为我们提供了<code>creat</code>函数专门用于文件创建。示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = creat(<span class="string">"test.txt"</span>, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码等同于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处引入了一个新的flags<code>O_TRUNC</code>：</p>
<ul>
<li>O_TRUNC    如果文件存在，并且有写权限，该标志位会把文件长度截断为0</li>
</ul>
<p>所以结合起来看，上面这段代码的含义是：创建新的文件<code>test.txt</code>，如果文件已存在，则清空内容。</p>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>当<code>open</code>系统调用成功打开文件，会返回一个非负的整数数值，这个数值便称作文件描述符。 我们来打印一下该数值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1, fd2, fd3;</span><br><span class="line">    fd1 = <span class="built_in">open</span>(<span class="string">"test1.txt"</span>, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    fd2 = <span class="built_in">open</span>(<span class="string">"test2.txt"</span>, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    fd3 = <span class="built_in">open</span>(<span class="string">"test3.txt"</span>, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span> || fd2 == <span class="number">-1</span> || fd3 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fd1:%d fd2:%d fd3:%d\n"</span>, fd1, fd2, fd3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="built_in">close</span>(fd2);</span><br><span class="line">    <span class="built_in">close</span>(fd3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fd1:3 fd2:4 fd3:5</span><br></pre></td></tr></table></figure>

<p>明明我们写的代码之前没有打开过任何文件，而文件描述符却是从3开始计数。这是因为当系统开启一个新进程的时候，内核会为每一个进程维护一张文件表，而这张表中会保存我们的文件描述符、文件<code>inode</code>节点以及读取位置指针等信息。并且，当进程创建的时候还将自动开启三个文件描述符：0、1和2。文件描述符0表示标准输入（stdin），1表示标准输出（stdout），2表示标准错误（stderr）。这就是为何我们在自己的代码中没有打开任何输入输出相关的文件，却能用<code>scanf</code>接收键盘输入，用<code>printf</code>打印到终端，用<code>perror</code>打印错误。现在，我们试着关闭这3个文件描述符，看看上述的三个函数是否还能正确执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">"file_not_exist.txt"</span>, O_WRONLY|O_TRUNC);</span><br><span class="line">    perror(<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毫无疑问，没有结果，上面三个函数均无法正常执行。</p>
<p>此外，Linux C标准库提供了三个宏来表示这3个整数，分别为<code>STDIN_FILENO</code> <code>STDOUT_FILENO</code> <code>STDERR_FILENO</code>，导入头文件<code>unistd.h</code>后即可使用。当<code>open</code>系统调用返回了正确的文件描述符，后面的读写等一系列函数就可使用此文件描述符作为参数，以进行更多文件操作。</p>
<h3 id="write写入文件"><a href="#write写入文件" class="headerlink" title="write写入文件"></a>write写入文件</h3><p>写文件使用<code>write</code>系统调用，先来看看其原型：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191127205248.png" alt=""></p>
<p><code>write</code>调用会从文件描述符<code>fd</code>指向的文件的当前位置开始，将<code>buf</code>中至多<code>count</code>个字节写入到文件中。<code>write</code>执行成功时，会返回写入的字节数，并更新文件位置。出错时，返回-1，并设置<code>errno</code>值。通常意义上，我们有文本文件写入和二进制文件写入。但这只是从用户的角度出发，对于操作系统来说，其实保存的都是二进制数据。只不过我们常用的文本编辑器帮我们将文本的二进制数据解析了出来，以便于阅读。而二进制文件格式各不相同，需要不同的程序来解析。诸如音乐播放器和电影播放器，就是很典型的例子。</p>
<h4 id="文本写入"><a href="#文本写入" class="headerlink" title="文本写入"></a>文本写入</h4><p>我们先来测试一下文本写入，将<code>hello world!</code>这条字符串写入到<code>str.txt</code>文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"str.txt"</span>, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="string">"hello world!"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行成功后，打开<code>str.txt</code>文件，发现字符串<code>hello world!</code>已经成功写入。</p>
<h4 id="二进制数据写入"><a href="#二进制数据写入" class="headerlink" title="二进制数据写入"></a>二进制数据写入</h4><p>再来看看二进制文件写入，将自定义的<code>struct Stu</code>结构体写入到<code>data</code>文件中。其实和上面的调用方式并无二致，仅仅是写入的数据变了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"data"</span>, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s.name, <span class="string">"Alan"</span>);</span><br><span class="line">    s.age = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, &amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行成功后，用文本编辑器打开<code>data</code>文件，发现乱码一串，什么鬼。因为我们没有合适的程序去读取其内容，所以你需要自己编写代码去读取。这也就是Java等高级语言中所谓的对象序列化技术。通过<code>od</code>命令来查看此文件，其实还是能看出点端倪的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  od -c data</span><br><span class="line">0000000   A   l   a   n  \0  \0  \0  \0 325 222   R 034   t   U  \0  \0</span><br><span class="line">0000020     213   U   %  \f  \0  \0  \0</span><br><span class="line">0000030</span><br></pre></td></tr></table></figure>

<h4 id="append-追加"><a href="#append-追加" class="headerlink" title="append 追加"></a>append 追加</h4><p>通常情况下除了创建新文件从头写入，在现有内容上进行追加的需求也不少见。我们需要在<code>open</code>系统调用的<code>flag</code>参数中加入一个新的标志位：<code>O_APPEND</code>，用来改变文件的访问模式为追加，先来看看定义</p>
<ul>
<li>O_APPEND    文件将以追加模式打开。也就是说，在每次写入操作之前，将会更新文件位置指针，指向文件末尾。即使有另一个进程也在向该文件写数据，以追加模式打开的进程在最后一次写操作时，还是会更新文件位置指针，指向文件末尾</li>
</ul>
<p>写个简单例子，我们先手动创建一个文件<code>append.txt</code>，并往其中写入文本<code>abc</code>，接着再通过代码向其追加文本<code>xyz</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "abc" &gt; append.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"append.txt"</span>, O_WRONLY|O_APPEND);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"xyz"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行成功后，打开文件<code>append.txt</code>，发现其中有两行文本，分别是<code>abc</code>和<code>xyz</code>，为什么不是一行呢？因为前面用到的<code>echo</code>命令会自动换行。</p>
<h5 id="共享文件操作"><a href="#共享文件操作" class="headerlink" title="共享文件操作"></a>共享文件操作</h5><p>这里针对<code>O_APPEND</code>标志位进行一下扩展。假设在多个进程中需要对同一个文件进行写入操作，那么两个进程写入的顺序是怎样的？举个例子，现有文件<code>share.txt</code>，一个进程只对其写入<code>aaa</code>，另一个进程只对其写入<code>bbb</code>，那么执行数次后，文本所展示的内容是什么样子？两个进程都有自己的文件描述符，却又指向同一个文件，因此我们可以猜想出两种结果：</p>
<ul>
<li>交替写，结果为<code>aaabbbaaabbb</code>，即一个进程写完后更新文件节点位置指针到末尾，然后另一个进程从末尾开始写</li>
<li>覆盖写，结果为<code>bbbbbbbbbbbb</code>，即一个进程写完后不更新文件节点位置指针，然后另一个进程从自己的原始位置开始写，并覆盖上一个进程所写入的数据，比如A进程先写了<code>aaa</code>，然而B进程此时的文件位置指针还在<code>aaa</code>开头，而非结尾，所以写入<code>bbb</code>后，会将<code>aaa</code>覆盖</li>
</ul>
<p>那么实际写入效果如何，我们可以用代码来验证一下。由于尚未了解多进程相关知识，我们两次打开同一文件来模拟此行为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1,fd2;</span><br><span class="line">    fd1 = <span class="built_in">open</span>(<span class="string">"share.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    fd2 = <span class="built_in">open</span>(<span class="string">"share.txt"</span>, O_WRONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span> || fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count++ &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(fd1, <span class="string">"aaa"</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">write</span>(fd2, <span class="string">"bbb"</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">	<span class="built_in">close</span>(fd2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完成，打开<code>share.txt</code>文件，可以看到文本内容<code>bbbbbbbbbbbb</code>，也就是说共享文件写入时是覆盖写。如果想让它变成交替写，则需要在<code>open</code>系统调用中加上<code>O_APPEND</code>标志位。其余代码不变，我们将打开文件的两行代码进行修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd1 = <span class="built_in">open</span>(<span class="string">"share.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC|O_APPEND, <span class="number">0666</span>);</span><br><span class="line">fd2 = <span class="built_in">open</span>(<span class="string">"share.txt"</span>, O_WRONLY|O_APPEND);</span><br></pre></td></tr></table></figure>

<p>重新编译执行，再次打开<code>share.txt</code>文件，内容已变成<code>aaabbbaaabbbaaabbbaaabbb</code>。</p>
<h3 id="read读取文件"><a href="#read读取文件" class="headerlink" title="read读取文件"></a>read读取文件</h3><p>前面讨论了打开和写入文件操作，接下来谈谈文件读取。先看看原型：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128103049.png" alt=""></p>
<p>每次调用<code>read</code>，会从<code>fd</code>指向的文件的当前偏移开始读取<code>count</code>字节到<code>buf</code>所指向的内存中。执行成功时，返回写入<code>buf</code>中的字节数。出错时，返回-1，并设置<code>errno</code>值。<code>fd</code>的文件位置指针会向前移动，移动的长度由读取到的字节数决定。</p>
<p>前面我们在文本写入和二进制数据写入两小节中分别产生了两个文件<code>str.txt</code>和<code>data</code>，现在我们尝试用<code>read</code>把其中的内容读出来，并打印到终端上。</p>
<h4 id="文本读取"><a href="#文本读取" class="headerlink" title="文本读取"></a>文本读取</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"str.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// 读之前先清空buf数据</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">read</span>(fd, buf, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行成功，会输出<code>hello world!</code>，可以看到文本读取非常简单。</p>
<h4 id="二进制数据读取"><a href="#二进制数据读取" class="headerlink" title="二进制数据读取"></a>二进制数据读取</h4><p>现在来看看二进制文件读取，我们使用上述写入的<code>data</code>文件来进行测试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"data"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="built_in">read</span>(fd, &amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, s.name, s.age);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行成功，会输出获取的结构体数据<code>Alan:12</code>。</p>
<h4 id="read返回值"><a href="#read返回值" class="headerlink" title="read返回值"></a>read返回值</h4><p>前面两段读取代码有个特点，即都是以知道<code>buf</code>缓冲区大小为前提来进行读取。比如第一段文本读取代码中，很明显我们知道要读取的字符串大小要小于100字节，所以创建了100字节的缓冲区。而第二段二进制数据读取代码中，可以很轻易通过<code>sizeof</code>运算符来得到<code>struct Stu</code>的大小。那如果并不知道要读取的文件大小是多少，缓冲区应该如何创建？通常情况下缓冲区不宜设置太小，因为读取的块太小，就会导致读取次数增加，造成效率低下。当然，也不能过大，这样会造成内存空间浪费或内存溢出。当设定好合适的缓冲区大小后，可以使用循环来读取内容。使用循环读取前，要先了解<code>read</code>系统调用的返回值，事实上调用<code>read</code>有很多种可能的返回结果，我们列出常见的几种，其余需要的时候再讲解：</p>
<ul>
<li>调用返回值等于<code>count</code>。读取到的所有<code>count</code>个字节都被存储在<code>buf</code>中。结果和预期一致。</li>
<li>调用返回值小于<code>count</code>，大于0。读取到的字节被存储到<code>buf</code>中。这种情况有很多原因，比如在读取过程中信号中断或在读取中出错，可读的数据大于0字节小于<code>count</code>字节，在读取<code>count</code>字节之前到达EOF。</li>
<li>调用返回0，表示EOF，没有更多可读的数据。</li>
</ul>
<p>了解完<code>read</code>的返回值后，我们摘录一段小王子的文本保存到文件<code>prince.txt</code>中，然后尝试循环读取到<code>buf</code>缓冲区中，并将其输出到终端，文本如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.And now here is my secret, a very simple secret. It is only with the heart that one can see rightly; what is essential is invisible to the eyes.</span><br><span class="line"></span><br><span class="line">2.If you come at four o&apos;clock in the afternoon, then at three o&apos;clock I shall begin to be happy. I shall feel happier and happier as the hour advances. At four o&apos;clock, I shall already be worrying and jumping about. I shall show you how happy I am! But if you come at just any time, I shall never know at what hour my heart is to be ready to greet you…</span><br><span class="line"></span><br><span class="line">3.If someone loves a flower, of which just one single blossom grows in all the millions and millions of stars, it is enough to make him happy just to look at the stars.He can say to himself, &quot;Somewhere, my flower is there…&quot; But if the sheep eats the flower, in one moment all his stars will be darkened… And you think that is not important!</span><br><span class="line"></span><br><span class="line">4.If we do not go through the world, we do not know what is our spiritual and emotional sustenance, but once we go through the world, we find that we can no longer go back to that wonderful place to go. When we begin to seek, we have lost, and we are not seeking, we cannot know what is so precious to us.</span><br><span class="line"></span><br><span class="line">5.Only the children know what they are looking for. They waste their time over a rag doll and it becomes very important to them; and if anybody takes it away from them, they cry…</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"prince.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = <span class="built_in">read</span>(fd, buf, <span class="number">99</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们每次读取99字节，并且将最后1字节设置为<code>\0</code>，以表示这是一条字符串，方便<code>printf</code>函数打印。当读取到文件末尾，<code>len</code>会等于0，并结束循环。如无意外，执行成功后会输出上文文本。</p>
<h3 id="lseek查找"><a href="#lseek查找" class="headerlink" title="lseek查找"></a>lseek查找</h3><p>有些同学可能在执行完<code>write</code>操作后立马使用<code>read</code>来读数据，然而此时无法正确读取，这是因为文件描述符的位置指针已经移动到了数据末尾，如果是从头写入的数据，那么我们可以用如下代码将位置指针回移，然后再进行读操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *buf = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">lseek(fd, (<span class="keyword">off_t</span>)<span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">read</span>(fd, buf, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>当然<code>lseek</code>的用法并不仅限如此，我们先看看文档，再讲述其详细用法：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128123908.png" alt=""></p>
<p><code>lseek</code>系统调用能够将文件描述符的位置指针修改成指定值，它的行为依赖于<code>whence</code>参数，该参数可以是以下任意值之一</p>
<ul>
<li>SEEK_CUR    将文件位置设置成当前值再加上<code>offset</code>个偏移值，<code>offset</code>可以是负值、0或正值。如果<code>offset</code>值为0，返回当前文件位置值。</li>
<li>SEEK_END    将文件位置设置成文件长度再加上<code>offset</code>个偏移值，<code>offset</code>可以是负值、0或正值。如果<code>offset</code>值为0，就设置成文件末尾</li>
<li>SEEK_SET    将文件位置设置成<code>offset</code>值。如果<code>offset</code>值为0，就设置成文件开始。</li>
</ul>
<p>调用成功时返回新的文件位置，错误时返回-1，并设置相应<code>errno</code>值。</p>
<p>举个例子，以下代码把<code>fd</code>的文件位置指针设置为200：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">off_t</span> ret;</span><br><span class="line">ret = lseek(fd, (<span class="keyword">off_t</span>)<span class="number">200</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"lseek"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是把<code>fd</code>的文件位置设置成文件末尾：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">off_t</span> ret;</span><br><span class="line">ret = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"lseek"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>lseek</code>返回更新后的文件位置，可以通过<code>SEEK_CUR</code>，把偏移<code>offset</code>设置成0，确定当前文件位置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line">pos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"lseek"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="稀疏文件"><a href="#稀疏文件" class="headerlink" title="稀疏文件"></a>稀疏文件</h3><p><code>lseek</code>也可将文件位置指针移动到文件末尾之后，比如以下代码会定位到<code>fd</code>指向文件末尾之后的1024*1024字节(1M) ，然后紧接着写入文本<code>end</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = lseek(fd, <span class="number">1024</span>*<span class="number">1024</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"lseek"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"end"</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>end</code>之前这段区间会用0来填充，称之为<code>空洞（hole）</code>。在UNIX系文件系统上，空洞不占用任何物理磁盘空间。包含空洞的文件称为<code>稀疏文件</code>。上面代码执行成功后，通过<code>ls -lh</code>命令查看，显示文件大小约为1M。而通过<code>du -h</code>命令查看物理空间大小，则显示为4k。这里的4k是因为最后写入的<code>end</code>，虽然<code>end</code>只占3字节，但由于Linux系统最小写入的块就是4k，所以文件物理大小为4k。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ls -l test.txt                 </span><br><span class="line">-rw-rw-r-- 1 noir noir 1003 11月 29 00:15 test.txt</span><br><span class="line">➜  du -h test.txt </span><br><span class="line">4.0k      test.txt</span><br></pre></td></tr></table></figure>

<p>为何需要空洞，打个比方，假如我们现在需要进行多线程下载，那么每条线程就必须通过<code>lseek</code>移动到不同位置创造出空洞，然后再通过<code>write</code>向空洞部分写入数据。最后所有部分的空洞都被填充，则完成整体文件下载。制造空洞不会产生任何物理I/O，对文件空洞部分的读请求则会返回相应的二进制0。</p>
<h3 id="截短文件"><a href="#截短文件" class="headerlink" title="截短文件"></a>截短文件</h3><p>通过使用<code>lseek</code>可以制造空洞，但这并非唯一做法，还有另一种方式就是使用<code>truncate</code>系统调用。先看看文档：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191129165547.png" alt=""></p>
<p><code>truncate</code>系统调用可以截短一个文件，<code>path</code>参数用于指定需截短的文件路径，<code>length</code>参数用于指定需截短的目标长度。而<code>ftruncate</code>与<code>truncate</code>不同的地方仅在于前者使用参数<code>fd</code>来指定需截短的文件，而非路径。当需要截短的长度实际大于文件本身长度时，便会造成空洞。我们使用<code>ftruncate</code>来改写上面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = ftruncate(fd, <span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"truncate"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行成功后，便创建了一个有1M大小空洞的稀疏文件。</p>
<p>上面的例子是截短的长度比文件原长度还要大，然而常规用法更多的是要截短的目标长度小于文件的原有长度。举个例子，我们现在有一个文本文件<code>test.txt</code>，里面包含一串字符串：<code>hello world</code>，现在我们使用<code>truncate</code>系统调用来截短6个字符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = truncate(<span class="string">"test.txt"</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"truncate"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完成，再次打开<code>test.txt</code>文件，其中内容已经截短为<code>hello</code>。</p>
<h3 id="close关闭文件"><a href="#close关闭文件" class="headerlink" title="close关闭文件"></a>close关闭文件</h3><p>接下来说说<code>close</code>系统调用。其实上面的代码中一直有用到，只是没有详细说明，先看看函数原型：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128134727.png" alt=""></p>
<p>当程序完成对某个文件的操作后，系统调用<code>close</code>会取消当前进程的文件描述符<code>fd</code>与其关联的文件之间的映射。调用后，先前给定的文件描述符<code>fd</code>不再有效，内核可以随时重用它，当后续有<code>open</code>调用或<code>creat</code>调用时，重新把它作为返回值。举个例子，假如我们我们关闭了文件描述符0，那么接下来的<code>open</code>调用便会打开一个新文件，并且此文件的文件描述符为0。</p>
<h3 id="dup复制文件描述符"><a href="#dup复制文件描述符" class="headerlink" title="dup复制文件描述符"></a>dup复制文件描述符</h3><p><code>dup</code>系统调用用于复制文件描述符，先来看文档：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128141513.png" alt=""></p>
<p><code>oldfd</code>表示原始文件描述符，<code>dup</code>系统调用会根据原始文件描述符复制一个新的文件描述符并返回，而这个新的文件描述符是从系统可用的最小文件描述符开始计数。如：当前已打开3，则下一个文件描述符应为4。而<code>dup2</code>系统调用除了复制文件描述符外，还可通过<code>newfd</code>来指定新文件描述符的数值。倘若<code>newfd</code>已经被使用，则<code>dup2</code>会将其关闭再给自己使用。上述两个系统调用执行成功会返回新的文件描述符，而一旦失败，则返回-1，并设置相应的<code>errno</code>。</p>
<p>下面我们复制一个文件描述符，并同时使用两个文件描述符向同一文件写入文本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"dup.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> new_fd;</span><br><span class="line">    new_fd = dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本行代码与上一行等价</span></span><br><span class="line">    <span class="comment">// new_fd = dup2(fd, 4);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"dup"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">"world"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, str1, <span class="built_in">strlen</span>(str1));</span><br><span class="line">    <span class="built_in">write</span>(new_fd, str2, <span class="built_in">strlen</span>(str2));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行成功后打开文件<code>dup.txt</code>，发现写入文本内容<code>helloworld</code>，也就是说通过<code>new_fd</code>写入的文本并没有覆盖<code>fd</code>写入的文本。这主要是因为<code>dup</code>复制出的文件描述符和原文件描述符使用的是同一文件位置偏移量。</p>
<h4 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h4><p><code>dup dup2</code>系统调用除了能复制文件描述符，还能实现重定向操作。先来看看什么是重定向：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  echo "hello"               # 直接输出到屏幕上</span><br><span class="line">hello</span><br><span class="line">➜  echo "hello" &gt; hello.txt   # 重定向到文件中</span><br><span class="line">➜  cat &lt; hello.txt            # 从文件重定向到命令里</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>如果经常使用Linux，对重定向应该不会陌生，下面我们来使用<code>dup dup2</code>来实现一个将原本输出到终端重定向至文件的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">    <span class="keyword">int</span> new_fd;</span><br><span class="line">    new_fd = dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本行代码与上一行等价,并且不需要提前关闭文件描述符1</span></span><br><span class="line">    <span class="comment">// new_fd = dup2(fd, STDOUT_FILENO);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"dup"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"hello world!"</span>;</span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以看出标准输出重定向操作主要分了三步：</p>
<ul>
<li>关闭标准输出文件描述符</li>
<li>复制文件描述符<code>fd</code>，此时会分配新的文件描述符1，并与<code>fd</code>所指向的文件绑定</li>
<li>向标准输出写入数据，此时数据会写入到<code>fd</code>所指向的文件中</li>
</ul>
<p>如果我们把下面这一行去掉，那么很明显，它会继续向标准输出打印，而不是输出到文件中，所以<code>close</code>是重定向中至关重要的一环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(STDOUT_FILENO);</span><br></pre></td></tr></table></figure>

<p>而<code>dup2</code>则更加简单，它可以不必提前关闭<code>STDOUT_FILENO</code>，当指定新的文件描述符为<code>STDOUT_FILENO</code>的时候，它会自动关闭，并将其与<code>fd</code>所指文件进行绑定。</p>
<h3 id="fcntl操作文件描述符"><a href="#fcntl操作文件描述符" class="headerlink" title="fcntl操作文件描述符"></a>fcntl操作文件描述符</h3><p><code>fcntl</code>主要作用是用来操作文件描述符，我们先看文档</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128172640.png" alt=""></p>
<p><code>fd</code>参数与上面所有的系统调用一样，指打开的文件描述符，而<code>cmd</code>则是控制命令，代表我们要针对此文件描述符进行的操作。由于命令较多，此处讲解两个以演示用法。</p>
<h4 id="模拟dup-dup2操作"><a href="#模拟dup-dup2操作" class="headerlink" title="模拟dup dup2操作"></a>模拟dup dup2操作</h4><p>除了使用<code>dup dup2</code>来复制文件描述符，通过<code>fcntl</code>也能做到，只是这种做法不常见而已。下面我们通过代码来演示如何操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> new_fd;</span><br><span class="line">    new_fd = fcntl(fd, F_DUPFD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"dup"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"hello"</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">write</span>(new_fd, <span class="string">"world"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完成，会成功往<code>test.txt</code>中写入<code>helloworld</code>，从上面的<code>fcntl</code>用法中我们发现了一个命令参数<code>F_DUPFD</code></p>
<ul>
<li>F_DUPFD    复制文件描述符，可用来模拟dup和dup2</li>
</ul>
<p>下面我们再演示一段模拟<code>dup2</code>重定向标准输出的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line"><span class="keyword">int</span> new_fd;</span><br><span class="line">new_fd = fcntl(fd, F_DUPFD, STDOUT_FILENO);</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，<code>dup2</code>设定文件描述符值之后，若此值已被使用则会先关闭，而<code>F_DUPFD</code>则不会，需要我们手动关闭，然后再设置新的文件描述符。</p>
<h4 id="设置文件访问模式"><a href="#设置文件访问模式" class="headerlink" title="设置文件访问模式"></a>设置文件访问模式</h4><p>由于实际开发中，很多时候我们获取到的文件描述符也许并非我们自行打开文件所得，而是由别的api返回。此时我们并不知道文件描述符的状态，也不知道是否具备我们需要的访问模式。这时也就引入了两个新的命令：</p>
<ul>
<li>F_GETFL    获取文件访问标志</li>
<li>F_SETFL    设置文件访问标志</li>
</ul>
<p>现在假设有一个文件描述符以可写模式打开，而我们想追加内容，来看看通过<code>fcntl</code>应该如何操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">// 获取原始文件描述符访问标志</span></span><br><span class="line">    flags = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="comment">// 在原有文件访问标志之上补充新的访问标志</span></span><br><span class="line">    flags = flags|O_APPEND;</span><br><span class="line">    <span class="comment">// 为文件描述符设定新的文件访问标志</span></span><br><span class="line">    fcntl(fd, F_SETFL, flags);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"hello"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行成功可以很清晰看到<code>test.txt</code>中的文本并未被覆盖，而是以追加的形式写入。通过上面的代码我们也看出了设置文件描述符标志的基本套路：</p>
<ul>
<li>获取原始文件描述符访问标志</li>
<li>在原有文件访问标志之上补充新的访问标志</li>
<li>为文件描述符设定新的文件访问标志</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的内容有点多，先是简要说明了文件读写的基本流程，然后针对文件打开、写入、读取进行了详细讲解。在文件读写过程中我们还需要注意文件共享写入、追加、lseek、空洞、关闭等小细节。最后又介绍了dup实现的文件共享以及重定向，还有fcntl操作文件描述符的简要方法。归根到底，其实文件I/O的基础操作并不难，也好理解，最重要的是一定要多看文档。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程-errno详解</title>
    <url>/2019/11/26/linux-programming-error/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当进行系统编程的时候，知道一个系统调用或库函数的返回结果极其重要。通常情况下，函数执行正确，可以返回需要的结果或无返回。然而，一旦发生错误，除了知道出错以外，我们还需要更详细的错误信息来辅助定位问题并加以修正。在系统编程中，错误是通过函数的返回值和特殊变量errno来描述。<a id="more"></a>用函数返回值来描述错误应该是最常见的手段，比方说-1代表文件打开失败，-2代表参数缺失等等。但很多错误其实都是通用的，如果针对每一个函数用一个错误码来表示，那么不免有些冗余，二来函数的生命周期有限，仅能描述自身，而无法描述整个程序的错误状态。所以我们需要一个全局范围的错误码和对应的错误定义，来帮助我们描述错误。</p>
<h3 id="errno-变量"><a href="#errno-变量" class="headerlink" title="errno 变量"></a>errno 变量</h3><p>举个例子，当我们使用<code>ls</code>命令来打开一个不存在的目录<code>abc</code>，很明显此时会报错并返回错误信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ ls abc</span><br><span class="line">ls: cannot access 'abc': No such file or directory</span><br></pre></td></tr></table></figure>

<p>但大部分人不知道的是，除了报错，ls命令还为系统设置了一个全局的errno来描述此程序错误。在shell中，我们可以通过查看<code>$?</code>来得到此errno</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ echo $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>可以看到，当前返回的错误码2实际上代表的是<code>No such file or directory</code>。如果我们已经知道了错误码，那么应该如何查看错误码对应的错误信息呢？总是用命令行或程序去试错，然后再记录下来成本有些大。所以此时便需要引入errno命令。</p>
<h3 id="errno-命令"><a href="#errno-命令" class="headerlink" title="errno 命令"></a>errno 命令</h3><p>没错，errno不仅是个特殊的环境变量，用<code>$?</code>来表示。与此同时，它也是一条Linux系统命令，使用<code>man errno</code>可以查看相关手册。如果你的系统中没有errno命令，那么需要安装<code>moreutils</code>，比如说在Ubuntu中：<code>sudo apt install moreutils</code></p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191126/20191126105824.png" alt=""></p>
<p>从上图可以看出errno命令的基本用法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ errno 2                                     # 查看相应错误宏名称</span><br><span class="line">ENOENT 2 No such file or directory</span><br><span class="line">➜  ~ errno -s file                               # 通过给出的关键词来搜索错误描述</span><br><span class="line">ENOENT 2 No such file or directory</span><br><span class="line">EBADF 9 Bad file descriptor</span><br><span class="line">EEXIST 17 File exists</span><br><span class="line">...</span><br><span class="line">➜  ~ errno -l                                    # 列出所有的错误值</span><br><span class="line">EPERM 1 Operation not permitted</span><br><span class="line">ENOENT 2 No such file or directory</span><br><span class="line">ESRCH 3 No such process</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h3 id="error在系统编程中的使用"><a href="#error在系统编程中的使用" class="headerlink" title="error在系统编程中的使用"></a>error在系统编程中的使用</h3><p>上面从命令行角度来讲解了errno的用法，那么如果以开发者的角度来看，errno又该如何使用？可以从手册中找到答案。之前我们查看errno命令是直接使用<code>man errno</code>，但在代码编写中，errno是作为一个库全局变量存在，因此我们需要通过<code>man 3 errno</code>命令来查看相应用法：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191126/20191126111638.png" alt=""></p>
<p>以上仅截取了部分文档，详细可自行查看。但从文档头部我们得到了两条重要信息，首先errno在代码中表示最后一次函数调用出错的错误码。其次，当使用此值的时候，我们需要引入头文件<code>errno.h</code>。在文档后面，还可以看到一个基本的伪代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A common mistake is to do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (somecall() == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"somecall() failed\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (errno == ...) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可知，错误发生的时机源于Linux系统调用或库函数调用。<strong>而errno正确的使用方法是：当错误发生，我们需要检查errno对应的值，并且做出相应处理。</strong></p>
<p>可以试着用代码将这些错误描述打印，来简单实现一下<code>errno -l</code>命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">134</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %s\n"</span>, i, strerror(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0: Success</span><br><span class="line">1: Operation not permitted</span><br><span class="line">2: No such file or directory</span><br><span class="line">3: No such process</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>代码中的strerror函数返回由errno描述的错误信息的字符串指针。其原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们用上面学到的两个Api来写一个打开文件，并判断是否打开正确的简单例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"abc.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="comment">// 如果open函数返回-1，说明打开文件失败，此时我们将错误原因打印出来</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s:%s\n"</span>, <span class="string">"open"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我当前程序运行的文件夹下并没有abc.txt这一文件， 所以执行结果为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">open:No such file or directory</span><br></pre></td></tr></table></figure>

<p>如此便可在程序出错时，知道出错的具体原因。</p>
<p>但既要使用errno又要使用strerror函数，才能输出错误，未免稍显麻烦了点，所以我们可以使用perror函数来简化这一过程。</p>
<h3 id="perror-函数"><a href="#perror-函数" class="headerlink" title="perror 函数"></a>perror 函数</h3><p>作用：打印系统错误信息</p>
<p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>现在我们用perror函数将上面的代码改造一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"abc.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时程序的运行输出已经变成了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure>

<p>执行结果与上面完全一致。也就是说，perror函数自动帮我们解析了errno这个特殊变量的值，并将值所对应的描述给打印了出来。此外我们还可以对perror传参，加上自己的标记。这会显示在输出开头。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在来小结一下，上面一共讲解了一个特殊的环境变量errno，当执行完程序或命令时，可以用<code>$?</code>来查看其结果。同时它也是一个Linux命令，可用来查看错误描述。而在系统编程中，它则用于保存系统调用或函数执行的错误结果。函数strerror可以解析出errno代码所对应的错误信息，而perror函数则可在系统编程中更好的输出错误。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>系统编程</tag>
      </tags>
  </entry>
</search>
