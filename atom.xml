<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Linxiao&#39;s Blog</title>
  
  <subtitle>学习、记录、分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://linxiao.pro/"/>
  <updated>2019-12-07T04:33:05.036Z</updated>
  <id>https://linxiao.pro/</id>
  
  <author>
    <name>Linxiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux系统编程-进程管理</title>
    <link href="https://linxiao.pro/2019/12/07/linux-programming-process-basic/"/>
    <id>https://linxiao.pro/2019/12/07/linux-programming-process-basic/</id>
    <published>2019-12-07T12:33:05.000Z</published>
    <updated>2019-12-07T04:33:05.036Z</updated>
    
    <content type="html"><![CDATA[<p>我们写完代码，经过编译生成的可执行二进制文件称作程序。程序保存在磁盘上，它是一个静态概念。而当程序被加载到内存中开始执行时，此时它又是动态的，被称作进程。一个进程涉及到很多方面，如：正在执行的二进制文件、虚拟内存、进程体系、进程状态、进程资源以及调度等等。下面的内容主要来谈谈进程的基本概念和管理。<a id="more"></a></p><h3 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a>进程ID</h3><p>我们先通过一个例子来引入进程ID这个概念，写一段代码，里面是一个死循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>gcc main.c -o loop</code>命令编译后，我们开始运行这个程序。然后在终端通过<code>ps -a</code>命令查看正在运行的进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ps -a</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  1936 tty2     00:35:12 java</span><br><span class="line">  1986 tty2     00:00:04 fsnotifier64</span><br><span class="line">  2303 tty2     00:00:04 gnome-software</span><br><span class="line"> 25474 pts/1    00:00:00 ps</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>可以看到刚运行的<code>loop</code>，其PID为25463，这里的PID也就是进程ID。每个进程的ID是唯一的，也就是说，同一时刻在操作系统内运行的程序，不可能产生两个或多个一样的PID。当进程被回收后，PID是可复用的，但这个概率比较小。因为默认情况下，内核将进程ID的最大值设置为32758，也就是int类型的最大值。只有当创建的进程数超过最大值以后，内核才会复用以前分配过的PID。</p><h4 id="获取进程ID和父进程ID"><a href="#获取进程ID和父进程ID" class="headerlink" title="获取进程ID和父进程ID"></a>获取进程ID和父进程ID</h4><p>从代码角度而言，进程ID都是由<code>pid_t</code>来表示，通常为int类型。下面两个系统调用可以获取进程ID：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205135830.png" alt=""></p><p><code>getpid</code>用来获取当前进程ID，<code>getppid</code>用于获取父进程ID。没错，每一个子进程都是由父进程派生出来的，所以还有父进程ID这么个概念。你可以通过命令行<code>pstree -p</code>查看进程树和相应的进程ID。由于以上两个函数总是会调用成功，因此不需要进行错误判断，下面用代码来演示打印当前进程ID和父进程ID：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"process id:       %10d\n"</span>, pid);</span><br><span class="line"></span><br><span class="line">    pid = getppid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent process id:%10d\n"</span>, pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>再回到我们刚刚跑起来的<code>loop</code>进程，你应该很自然的会想到在终端中用Ctrl+c去终止它。虽然有些暴力，但也的确可以这么做。于是也就引出了我们平常终止进程的两种方式，一是正常终止，二是异常终止。正常终止包括从main返回，调用exit、<code>_exit</code>或<code>_Exit</code>函数。而异常终止包括调用<code>abort</code>，接收终止信号等。在终端中执行Ctrl+c实际上就是给当前执行的进程发送终止信号，其等同于命令<code>kill -9 PID</code>，当<code>loop</code>进程接收到信号后就会终止自身。</p><h4 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h4><p>通常情况下，我们在main函数中通过return返回，于是也就退出了进程。但这样的退出方式只在main函数好使，因为程序在实际运行中往往需要调用一系列函数，每次调用相当于将函数进行一次压栈操作，而每次return又相当于从当前函数返回到调用处，也就是出栈。而从main函数return，则相当于将进程中的函数调用栈清空，也就达到了退出进程的目的。这样退出的前提是，所有的函数调用最终都能返回到main中。但事实往往不是，先看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun3\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun2\n"</span>);</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun1\n"</span>);</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如当前进程执行到fun2函数遇到异常，无法向调用处返回，而是希望直接终止进程怎么办？那么最快的方式就是使用退出函数：<code>exit</code>、<code>_exit</code>或<code>_Exit</code>。 先来看三个函数的定义：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205162819.png" alt=""></p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205162858.png" alt=""></p><p>3个函数都用于正常终止一个进程，且都带一个<code>status</code>参数，称为终止状态。大多数UNIX系统shell都提供检查进程终止状态的方法，如通过命令行<code>echo $?</code>。其中<code>_exit</code>和<code>_Exit</code>是系统调用，执行后会立即进入内核。当进程退出时，内核会清理进程所创建的、不再使用的所有资源。这包括但不局限于：分配内存、打开文件和System V的信号量。清理完成后，内核会摧毁进程，并告知父进程其子进程已经终止。</p><p>进程可以直接调用<code>_exit</code>退出，但通常并不合适，绝大多数进程在完全退出之前，还需要做一些额外的清理工作。这时需要使用<code>exit</code>，它是一个C库函数。<code>exit</code>最终还是会调用系统调用<code>_exit</code>，但在此之前它会清理所有已打开的标准I/O流，并且会调用任何由<code>atexit</code>注册的函数。</p><h4 id="atexit"><a href="#atexit" class="headerlink" title="atexit"></a>atexit</h4><p>系统调用<code>atexit</code>用来注册一些在进程结束时要调用的函数</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205171538.png" alt=""></p><p><code>atexit</code>调用成功时，会注册指定的函数作为终止函数，在程序正常结束时（即进程通过调用<code>exit</code>或从<code>main</code>函数返回）运行。指定函数必须是无参的，且没有返回值。函数形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>函数调用的顺序和函数注册的顺序相反。也就是说，这些函数是存储在栈中，以后进先出的方式调用（LIFO）。注册的函数不能调用<code>exit</code>，否则会导致递归调用死循环。调用成功<code>atexit</code>返回0。错误时，返回-1。下面通过代码来演示，如何注册：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun3\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"进程正在运行\n"</span>);</span><br><span class="line">    </span><br><span class="line">    atexit(fun1);</span><br><span class="line">    atexit(fun2);</span><br><span class="line">    atexit(fun3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"进程准备退出\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行新进程"><a href="#运行新进程" class="headerlink" title="运行新进程"></a>运行新进程</h3><p>在UNIX中，把程序载入内存执行和创建新的进程是相互独立的操作。通过<code>exec</code>系列系统调用，可以把二进制程序加载到内存中，替换地址空间原来的内容，并开始执行新程序。而通过<code>fork</code>系统调用，可以创建一个新的进程，它基本上相当于复制其父进程。通常情况下，新的进程会立即执行新的程序。</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p><code>exec</code>并非一个单独的函数，而是由<code>exec</code>开头的一系列系统调用。它们都用于加载指定的二进制程序，并替换当前的进程来运行。先来看文档：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205184100.png" alt=""></p><p>由于函数比较多，我们先拿第一个来举例。<code>execl</code>用于加载参数<code>path</code>指定的二进制文件到内存中，并替换当前进程，<code>arg</code>是该程序的参数列表，有一个或多个，参数列表必须以NULL结尾。通常情况下，<code>execl</code>不会返回。调用成功时，会跳转到新的程序入口点，而刚刚运行的代码是不再存在于进程的地址空间中。错误时，<code>execl</code>会返回-1，并设置相应的errno值。下面来举个例子，我们用<code>ls</code>命令来替换当前的进程运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始执行\n"</span>);</span><br><span class="line">    ret = execl(<span class="string">"/bin/ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"execl"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"执行结束\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开始执行</span><br><span class="line">总用量 72</span><br><span class="line">-rw---S--T 1 noir noir   530 12月  2 01:53 backup.c</span><br><span class="line">-rw-rw-r-- 1 noir noir 22760 11月 28 15:59 CMakeCache.txt</span><br><span class="line">drwxrwxr-x 5 noir noir  4096 12月  5 02:44 CMakeFiles</span><br><span class="line">-rw-rw-r-- 1 noir noir  1533 11月 28 15:59 cmake_install.cmake</span><br><span class="line">-rw-rw-r-- 1 noir noir  4991 12月  2 01:44 Makefile</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>有几点需要注意：</p><ul><li>上面的输出打印了<code>开始执行</code>，却没有打印<code>执行结束</code>。这是因为当载入新程序执行后，原有进程会被替代，即便还有后续可执行的代码，也会被忽略</li><li>虽然当前进程被新程序所替代，但进程大部分属性依然保持不变，如：pid、ppid、进程优先级、所属用户和所属组等</li><li>按照惯例，<code>arg</code>的第一个参数应该是程序的名称，当执行新进程时，该名称将被放入新进程的第一个参数<code>argv[0]</code>中，程序解析<code>argv[0]</code>后，就可知道二进制程序的名字了</li></ul><p>关于上面第三点，我们可以写两段代码来验证<code>exec</code>系列函数的参数传递。首先来写一段代码用来输出从<code>argv</code>中获取的参数列表，我们通过<code>gcc parse.c -o parse</code>将其编译为<code>parse</code>二进制文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们通过<code>execl</code>来调用<code>parse</code>，传入参数后，让其输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始执行\n"</span>);</span><br><span class="line">    ret = execl(<span class="string">"../parse"</span>, <span class="string">"parse"</span>, <span class="string">"-arg1"</span>, <span class="string">"-arg2"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"execl"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"执行结束\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始执行</span><br><span class="line">parse</span><br><span class="line">-arg1</span><br><span class="line">-arg2</span><br></pre></td></tr></table></figure><p>可见，<code>arg</code>参数被原封不动地传递到了<code>parse</code>程序的<code>argv</code>参数列表中。</p><h4 id="其他exec函数"><a href="#其他exec函数" class="headerlink" title="其他exec函数"></a>其他exec函数</h4><p>除了<code>execl</code>外，<code>exec</code>系还有其他5个函数，分别是：<code>execlp</code>、<code>execle</code>、<code>execv</code>、<code>execvp</code>、<code>execve</code>。这些函数很容易记住。<code>l</code>和<code>v</code>分别表示参数是以列表方式还是数组方式提供的。<code>p</code>表示会在用户的环境变量<code>path</code>下查找可执行文件。使用了<code>p</code>的函数可以只指定文件名，该文件必须在用户环境变量下。最后，<code>e</code>表示会为新进程提供新的环境变量。奇怪的是，<code>exec</code>函数中没有一个同时可以搜索路径和使用新环境变量的函数，虽然从技术角度看完全可以实现它。这可能是因为带<code>p</code>的<code>exec</code>函数主要是用于shell的，因为shell执行的进程通常会从shell本身继承环境变量。</p><p>和之前演示的例子一样，以下代码使用<code>execvp</code>来执行<code>ls</code>，它要求<code>ls</code>必须在<code>path</code>路径下，并且参数采用数组来提供：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *arg[] = &#123;<span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"-a"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    ret = execvp(<span class="string">"ls"</span>, arg);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"execvp"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出与之前<code>execl</code>演示的结果一致。</p><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p><code>fork</code>调用可以创建一个子进程，先来看看函数定义：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205215359.png" alt=""></p><p>当<code>fork</code>调用成功时，它会创建一个几乎与父进程完全相同的子进程。父子进程会以<code>fork</code>的调用点为起点，分别继续运行。在父进程中，<code>fork</code>会返回子进程的<code>pid</code>，而在子进程中，<code>fork</code>会返回0。出错时，不会创建子进程，<code>fork</code>返回-1，并设置相应errno值。来看一段代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process pid:%d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process ppid:%d\n"</span>, getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处休眠1秒，防止父进程过快终止</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent process pid:%d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent process ppid:%d\n"</span>, getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">child process pid:31033</span><br><span class="line">child process ppid:31032</span><br><span class="line">after</span><br><span class="line">parent process pid:31032</span><br><span class="line">parent process ppid:1936</span><br><span class="line">after</span><br></pre></td></tr></table></figure><p>上面的代码和输出有几处需要额外注意：</p><ul><li>子进程的ppid其实也就是父进程的pid</li><li>before只打印了一次是因为它处于<code>fork</code>之前，而after打印了两次是因为<code>fork</code>之后子进程和父进程都有一份打印代码</li><li>在父进程中我们休眠了一秒，是为了防止父进程在<code>fork</code>后过早结束本身运行状态，而子进程还未执行完</li></ul><p>通常情况下，会使用<code>fork</code>创建一个新的进程，然后再通过<code>exec</code>载入二进制文件，以替换<code>fork</code>出的新进程运行。将创建进程与执行二进制文件分离是一个非常好的设计。这样你就无需在<code>fork</code>出的子进程代码段中编写大量代码，而是可以编写独立的程序。这就好比我们在shell中执行命令，无需知道每个具体命令的实现，shell只需要为该命令创建一个新进程，然后把命令和相关参数丢进去执行即可。下面我们来写一段代码，演示如何在<code>fork</code>出的新进程中通过<code>exec</code>来执行<code>ls</code>命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        ret = execlp(<span class="string">"ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"-a"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"execlp"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处休眠1秒，防止父进程过快终止</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">总用量 80</span><br><span class="line">drwxrwxr-x 3 noir noir  4096 12月  5 17:10 .</span><br><span class="line">drwxrwxr-x 5 noir noir  4096 12月  5 17:10 ..</span><br><span class="line">-rw---S--T 1 noir noir   530 12月  2 01:53 backup.c</span><br><span class="line">-rw-rw-r-- 1 noir noir 22760 11月 28 15:59 CMakeCache.txt</span><br><span class="line">drwxrwxr-x 5 noir noir  4096 12月  5 17:10 CMakeFiles</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h4><p>上面的例子中需要让父进程休眠1秒，以便留给子进程足够的时间执行完。假设现在子进程进行的任务非常繁重且耗时，那么父进程应该休眠几秒？答案是不确定，我们应该让父进程等待子进程执行完。通过<code>vfork</code>可以做到这点，但是<code>vfork</code>是一个不推荐使用的函数。我们先看<code>vfork</code>的用法，然后再说明为何不推荐使用。</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206093458.png" alt=""></p><p><code>vfork</code>的调用和返回与<code>fork</code>相同，但使用<code>vfork</code>能保证子进程先运行，在它调用<code>exec</code>或<code>_exit</code>之后父进程才会继续运行。我们用这样一个特性来改写上面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        ret = execlp(<span class="string">"ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"-a"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"execlp"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程不做任何操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果与之前一样，但是父进程不需要再休眠。除了上面所说的运行特点，<code>fork</code>和<code>vfork</code>还有一个差别：同样是创建子进程，<code>fork</code>会把父进程的内存数据拷贝到子进程中；而<code>vfork</code>则是和父进程共享内存数据。我们之前有说过<code>fork</code>会创建一个与当前进程一样的子进程。所谓一样就是指内存数据一样。而实际应用中，大部分场景是<code>fork</code>一个新的子进程，然后直接通过<code>exec</code>载入二进制文件执行，根本不需要进行内存数据拷贝，因此共享父进程的就可以了。</p><p>于此同时，<code>vfork</code>这些特点也带来了些弊端：</p><ul><li>如果<code>exec</code>调用失败，那么父进程就会被一致挂起</li><li>在子进程中不能使用<code>return</code>或<code>exit</code>进行终止。由于是共享父进程内存数据，当使用<code>return</code>时，会从<code>main</code>函数返回，导致函数栈空间被清空，所以回到父进程继续运行时，栈空间会错乱。如果使用<code>exit</code>，那么它会清理父进程的标准I/O。子进程正确的退出方式是使用<code>_exit</code></li></ul><p>由于<code>vfork</code>所带来的这些隐患，所以它不推荐被使用。</p><h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p><code>vfork</code>由于没有直接的内存数据拷贝操作，所以性能非常好，但同时也带来很多危险。为了弥补<code>fork</code>拷贝内存数据所带来的性能开销，现代UNIX系统采用了写时复制(copy-on-write)的方式，而不是对父进程内存数据进行整体复制。</p><p>写时复制是一种基于惰性算法的优化策略，为了避免复制时的开销。其前提假设很简单：如果有多个进程要读取它们自己那部分资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有一个进程修改自己的副本，每个进程就好像独占那个资源，从而避免了复制带来的开销。如果某个进程想要修改自己的那份资源副本，就会开始复制该资源，并把副本提供给这个进程。这个进程后面就可以反复修改其持有的副本，而其他进程还是共享原来那份没有修改过的资源。这就是写时复制这个名称的由来：只有在写入时才执行复制。</p><h3 id="等待进程终止"><a href="#等待进程终止" class="headerlink" title="等待进程终止"></a>等待进程终止</h3><p>通过<code>vfork</code>可以使父进程挂起，等待子进程执行完再继续运行。但是<code>vfork</code>毕竟会带来一些危险性，并且其无法获取子进程执行完后的状态信息。这个时候我们需要使用<code>wait</code>系列系统调用，它们用于等待进程状态改变：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206112528.png" alt=""></p><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>先来看<code>wait</code>，调用<code>wait</code>成功时，会返回已终止子进程的pid；出错时，返回-1。如果没有子进程终止，调用会阻塞，直到有一个子进程终止。如果子进程已经终止了，调用会立即返回。如果<code>wstatus</code>指针不是NULL，那它包含了关于子进程的一些其他信息。这些信息可以根据以下宏来解释：</p><table><thead><tr><th>宏</th><th>说明</th></tr></thead><tbody><tr><td>WIFEXITED(status)</td><td>若子进程正常终止，返回真。此时可通过WEXITSTATUS(status)获取子进程传送给exit或_exit参数的低8位</td></tr><tr><td>WIFSIGNALED(status)</td><td>若子进程被信号终止，返回真。此时可通过WTERMSIG(status)获取信号编号。若进程收到信号时产生终止进程的core文件，则WCOREDUMP(status)返回真</td></tr><tr><td>WIFSTOPPED(status)</td><td>若当前子进程停止运行，返回真。此时可通过WSTIOPSIG(status)获取使进程终止的信号编号</td></tr><tr><td>WIFCONTINUED(status)</td><td>若当前子进程继续运行，返回真。</td></tr></tbody></table><p>下面我们写一个例子来演示，创建一个新的子进程，休眠60秒。然后在父进程中等待其终止状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">60</span>);</span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"正常终止，终止状态码：%d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"被信号终止，信号编码：%d\n"</span>, WTERMSIG(status));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"是否生成coredump文件：%d\n"</span>, WCOREDUMP(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"被信号暂停，信号编码:%d\n"</span>, WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFCONTINUED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"继续运行\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序正常终止会输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正常终止，终止状态码：1</span><br></pre></td></tr></table></figure><p>通过<code>kill -15 41782</code>命令尝试为该进程发送终止信号，则输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">被信号终止，信号编码：15</span><br><span class="line">是否生成coredump文件：0</span><br></pre></td></tr></table></figure><h4 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h4><p>通常情况下，一个进程会有多个子进程，如果父进程想等待其中一个子进程，一个方法是多次调用<code>wait</code>，然后每次根据返回值来判断是否为需要等待的子进程。但这种方法并不太灵活，通过<code>waitpid</code>可以指定等待的子进程，并且它额外的参数可以支持更细粒度的调整。<code>waitpid</code>函数定义上图已经列出。</p><p>参数<code>pid</code>指定要等待的一个或多个进程的<code>pid</code>，它的值必须是下面四种情况之一：</p><ul><li><code>&lt;-1</code> 等待一个指定进程组中的任何子进程退出，该进程组的ID等于<code>pid</code>的绝对值。比如，传递参数值-500，表示等待在进程组500中的任何子进程</li><li><code>-1</code> 等待任何一个子进程退出，行为和<code>wait</code>一致</li><li><code>0</code> 等待同一个进程组中的任何子进程</li><li><code>&gt;0</code> 等待进程<code>pid</code>等于<code>pid</code>的子进程。比如，传递参数值500，表示等待<code>pid</code>为500的子进程</li></ul><p>参数<code>wstatus</code>的作用和<code>wait</code>函数中的是一样的，并且也可以只用之前讨论过的宏。</p><p>参数<code>options</code>是0个或多个以下选项按二进制或运算的结果：</p><ul><li>WNOHANG 不要阻塞，如果要等待的子进程还没有结束、停止或继续运行，会立即返回</li><li>WUNTRACED 如果设置该位，即使调用进程没有跟踪子进程，也会设置返回调用参数中的WIFSTOPPED位</li><li>WCONTINUED 如果设置该位，即使是调用进程没有跟踪子进程，也会设置返回调用参数中的WIFCONTINUED位</li></ul><p>调用成功时，<code>waitpid</code>返回状态发生改变的那个进程的<code>pid</code>。如果设置了WNOHANG参数，并且要等待的一个或多个子进程的状态还没有发生改变，<code>waitpid</code>返回0。出错时，调用返回-1，并设置相应的errno值。下面通过代码来演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">60</span>);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        waitpid(pid, &amp;status, WUNTRACED|WCONTINUED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"正常终止，终止状态码:%d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"被信号暂停，信号编码:%d\n"</span>, WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFCONTINUED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"继续运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行后，我们尝试通过<code>kill -STOP 3888</code>给新创建的子进程发送信号，让其停止运行，输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被信号暂停，信号编码:19</span><br></pre></td></tr></table></figure><h3 id="创建并等待新进程"><a href="#创建并等待新进程" class="headerlink" title="创建并等待新进程"></a>创建并等待新进程</h3><p>如果一个进程创建了新进程并且立即开始等待它的结束，那么除了<code>vfork</code>和<code>wait</code>，还有另一种实现方式，即使用<code>system</code>函数</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206161937.png" alt=""></p><p><code>system</code>函数会使用<code>fork</code>创建一个子进程，然后在其内部通过<code>execl</code>系统调用去执行<code>command</code>所指定的命令，调用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, command, (<span class="keyword">char</span> *) <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>成功时，返回值是执行<code>command</code>命令得到的返回状态，该状态和执行<code>waitpid</code>所获取的状态一致。因此，可以通过WEXITSTATUS获取执行<code>command</code>命令的返回值。如果调用<code>/bin/sh</code>本身失败了，那么从WEXITSTATUS返回的值和调用exit(127)的返回值是一样的。因为也可能是调用的命令返回了127，但没有办法来检测是shell本身发生了错误还是调用<code>command</code>命令执行失败而返回127。失败时，<code>system</code>调用会返回-1。如果参数<code>command</code>是NULL且<code>/bin/sh</code>是可用的，<code>system</code>会返回一个非0值，否则返回0。我们通过一段代码来演示，如何使用<code>system</code>来调用<code>ls</code>并获取返回值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    status = system(<span class="string">"ls -l -a"</span>);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"system"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"正常终止，终止状态码:%d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">总用量 80</span><br><span class="line">drwxrwxr-x 3 noir noir  4096 12月  6 00:38 .</span><br><span class="line">drwxrwxr-x 5 noir noir  4096 12月  6 00:38 ..</span><br><span class="line">-rw---S--T 1 noir noir   530 12月  2 01:53 backup.c</span><br><span class="line">-rw-rw-r-- 1 noir noir 22760 11月 28 15:59 CMakeCache.txt</span><br><span class="line">...</span><br><span class="line">正常终止，终止状态码:0</span><br></pre></td></tr></table></figure><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>当子进程结束后，它的父进程还未获取其状态，那么这个进程就叫做僵尸进程。僵尸进程会消耗少量资源用于保存进程之前的一些状态信息。一旦父进程通过<code>waitpid</code>等方式得到此信息，那么内核就会将子进程销毁。下面用一段代码演示子进程到僵尸进程的转化过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子进程结束\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span> (pid == wait(<span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"子进程已被回收\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"父进程结束\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行后，我们可以通过<code>ps -ao pid,ppid,stat,cmd | grep zombie</code>（zombie是我们编译出的二进制程序）查看进程状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 程序开始执行，此时两个进程都在休眠状态</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep zombie</span><br><span class="line">  7354   3411 S+   ./zombie</span><br><span class="line">  7355   7354 S+   ./zombie</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序运行到第10秒，此时子进程结束，变成僵尸进程</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep zombie</span><br><span class="line">  7354   3411 S+   ./zombie</span><br><span class="line">  7355   7354 Z+   [zombie] &lt;defunct&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序运行到第20秒，此时子进程已被回收，只剩下父进程</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep zombie</span><br><span class="line">  7354   3411 S+   ./zombie</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序又运行10秒，此时父进程已经退出</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep zombie</span><br></pre></td></tr></table></figure><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>与僵尸进程对应的是孤儿进程，它是指父进程在等待子进程结束之前就已经结束自身。无论何时，只要有进程结束了，内核就会遍历它的所有子进程，并且把它们的父进程重新设置为init进程（即pid为1的那个进程）。这保证了系统中不存在没有父进程的进程，从而使得每个子进程最终都能正常退出。下面我们通过代码来演示子进程到孤儿进程的转化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子进程结束\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"父进程结束\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行后，同样我们通过<code>ps -ao pid,ppid,stat,cmd | grep orphan</code>查看进程状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 程序开始执行，此时两个进程都在休眠</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep orphan</span><br><span class="line">  7989   5753 S+   ./orphan</span><br><span class="line">  7990   7989 S+   ./orphan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序运行到第10秒，此时父进程结束，子进程变成孤儿进程，内核将其ppid重设为1</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep orphan</span><br><span class="line">  7990      1 S    ./orphan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序运行到第20秒，子进程也结束</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep orphan</span><br></pre></td></tr></table></figure><h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><p>在Linux系统中，每个进程都有用户ID和组ID，它们限定了该进程可以执行哪些操作。可以通过下面4个系统调用可以查看用户ID和组ID：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206220925.png" alt=""></p><p><img src="C:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191206220814857.png" alt="image-20191206220814857"></p><p>这四个系统调用总会成功执行，因此无需进行错误判断，下面通过代码来演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uid_t</span> uid, euid;</span><br><span class="line">    <span class="keyword">gid_t</span> gid, egid;</span><br><span class="line"></span><br><span class="line">    uid = getuid();</span><br><span class="line">    euid = geteuid();</span><br><span class="line"></span><br><span class="line">    gid = getgid();</span><br><span class="line">    egid = getegid();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uid:%d\n"</span>, uid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"euid:%d\n"</span>, euid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"gid:%d\n"</span>, gid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"egid:%d\n"</span>, egid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uid:1000</span><br><span class="line">euid:1000</span><br><span class="line">gid:1000</span><br><span class="line">egid:1000</span><br></pre></td></tr></table></figure><p>上面的用户ID和组ID对应数值的名称可以在<code>/etc/passwd</code>和<code>/etc/group</code>文件中找到。为何用户ID和组ID都分别有两个？因为其含义不同，以上四个ID分别表示：实际用户ID、有效用户ID、实际用户组、有效用户组。</p><p>实际用户ID是指运行当前进程的用户uid，这个uid往往通过继承父进程而来。有效用户ID是当前进程所使用的用户ID，一般用于权限验证。事实上，远不止这两个id，其他id可以通过命令<code>ps -ao pid,uid,euid,gid,egid,ruid,suid,cmd</code>来查看，这里不再一一解释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PID   UID  EUID   GID  EGID  RUID  SUID CMD</span><br><span class="line">1708  1000  1000  1000  1000  1000  1000 /usr/lib/xorg/Xorg vt2 </span><br><span class="line">1717  1000  1000  1000  1000  1000  1000 /usr/lib/gnome-session/gnome-session-binary </span><br><span class="line">1859  1000  1000  1000  1000  1000  1000 /usr/bin/gnome-shell</span><br><span class="line">1918  1000  1000  1000  1000  1000  1000 ibus-daemon --xim --panel disable</span><br><span class="line">1922  1000  1000  1000  1000  1000  1000 /usr/lib/ibus/ibus-dconf</span><br><span class="line">1923  1000  1000  1000  1000  1000  1000 /usr/lib/ibus/ibus-extension-gtk3</span><br><span class="line">1925  1000  1000  1000  1000  1000  1000 /usr/lib/ibus/ibus-x11 --kill-daemon</span><br></pre></td></tr></table></figure><p>为何需要这么多ID呢？实际上是因为进程在运行时对于权限的需求是变化的，有可能在进程初期需要较大权限，如将用户id和组id改为root；而后，当不需要这么大权限时，本着最小权限原则，应该再将用户id和组id的权限进行降级操作。不同的id实际上是对应了进程运行的各个不同周期。一般而言，root用户可以将用户ID和组ID改为任一需要的权限，而普通用户只能在已继承的不同周期的用户权限间进行修改。</p><p>通过以下四个系统调用我们可以用于更改实际用户ID、实际用户组ID、有效用户ID和有效组ID：</p><p><img src="C:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191206224901577.png" alt="image-20191206224901577"></p><p><img src="C:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191206224932557.png" alt="image-20191206224932557"></p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206225016.png" alt=""></p><p>执行成功时，四个调用都返回0，失败时返回-1，并设置相应的errno值。下面通过代码来演示如何修改有效用户ID，其余几个函数用法类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = seteuid(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ret"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"修改成功，当前有效用户ID为:%d\n"</span>, geteuid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果我们想把当前进程的有效用户ID设置为root，那么运行此进程的时候必须是root用户，或者有root权限。</p><h3 id="会话和进程组"><a href="#会话和进程组" class="headerlink" title="会话和进程组"></a>会话和进程组</h3><p>正如同你是你家庭的一份子，每个进程都属于一个进程组。而进程组内首进程的<code>pid</code>，也就是进程组的ID。进程组的一大好处是，当你给进程组发送信号的时候，会发送给进程组内的所有进程。比如在进行作业控制的时候，你可以通过一个操作，让组内所有进程终止、暂停或是继续运行。</p><p>而多个进程组在一起则组合成了会话。通常情况下，当有新用户登录计算机，那么登录进程就会为该用户创建一个新的会话，这个新的会话包含一个单进程，即用户的登录shell。登录shell会作为会话的首进程，会话首进程的pid也就是会话ID。会话囊括了登录用户的所有活动，并分配给用户一个控制终端来处理用户的I/O行为。事实上，我们如今的控制终端与所使用的shell已经近似于一个概念。</p><p>系统中往往存在多个会话，每个用户的登录都是一个会话，但还有一些是与用户登录会话无关的进程（例如守护进程）。守护进程往往会创建自己的会话，从而避免与其他存在的会话产生关系。每个会话都包含一个或多个进程组，而且每个进程组至少包含一个进程。包含多个进程的进程组通常是为了完成一系列任务而存在。</p><p>在登录时，shell会创建新的会话，通过<code>setsid</code>系统调用完成：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191207104401.png" alt=""></p><p>假如调用进程不是某个进程组首进程，调用<code>setsid</code>会创建新的会话，并在该会话内创建新的进程组，调用进程就是新会话和新进程组内的唯一进程，会话ID和进程组ID都被设置为调用进程的pid，此会话没有控制终端。这个特性对于守护进程而言非常有用，因为它不想是任何已存在会话的成员，也不想拥有控制终端。对于shell来说，它也很有用，因为shell希望为每一个登录的用户创建新的会话。</p><p>成功时，<code>setsid</code>会返回新会话的会话ID。出错时，返回-1，并设置相应的errno值。下面通过代码来演示如何在子进程中开启一个新的会话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前父进程会话ID：%d\n"</span>, getsid(<span class="number">0</span>));</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前子进程会话ID：%d\n"</span>, getsid(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (setsid() == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"setsid"</span>);</span><br><span class="line">            _exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"创建新会话成功,当前会话ID:%d\n"</span>, getsid(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前父进程会话ID：1706</span><br><span class="line">当前子进程会话ID：1706</span><br><span class="line">创建新会话成功,当前回话ID:21891</span><br></pre></td></tr></table></figure><p>上面用到了一个系统调用<code>getsid</code>用于获取当前进程的会话ID：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191207112659.png" alt=""></p><p>当参数<code>pid</code>为0，就返回调用进程的会话ID。出错时，返回-1，并设置相应的errno值。通常情况下，这一系统调用并不常用，它主要用于诊断问题。</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程运行在后台，不与任何控制终端相关联。守护进程通常在系统启动时就运行，它们以root用户或者其他特殊的用户（例如nginx或ssh)运行，并处理一些系统级的任务。习惯上守护进程的名字通常以d结尾(如crond和sshd)，但这不是必需的，甚至不是通用的。对于守护进程，有两个基本要求：一是必须作为init进程的子进程运行，一是不与任何控制终端交互。</p><p>一般而言，进程可以通过以下步骤成为守护进程：</p><ol><li>调用fork，创建新的子进程</li><li>在父进程中调用exit</li><li>调用<code>setsid</code>，创建新的会话和进程组，并把当前子进程作为会话的首进程</li><li>调用<code>chdir</code>，将当前工作目录改为根目录。以防止当前继承而来的工作目录所在的文件系统无法被正常卸载</li><li>关闭所有文件描述符</li><li>打开文件描述符0、1、2，并把他们重定向到/dev/null</li></ol><p>以下是一个编写守护进程的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建新进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 退出父进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新会话和新进程组</span></span><br><span class="line">    <span class="keyword">if</span> (setsid() == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsid"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置工作目录为根</span></span><br><span class="line">    <span class="keyword">if</span> (chdir(<span class="string">"/"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"chdir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭所有文件描述符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">close</span>(i) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定向文件描述符0 1 2 到/dev/null</span></span><br><span class="line">    <span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">    dup(<span class="number">0</span>);</span><br><span class="line">    dup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下为守护进程自己的任务</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，很多UNIX系统在C库中提供了<code>daemon</code>函数来自动完成这些工作：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191207122136.png" alt=""></p><p>如果参数<code>nochdir</code>为非0值，就不会将工作目录改为根目录。如果参数<code>noclose</code>为非0值，就不会关闭所有打开的文件描述符。成功时，返回0。失败时，返回-1，并设置相应的errno值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们写完代码，经过编译生成的可执行二进制文件称作程序。程序保存在磁盘上，它是一个静态概念。而当程序被加载到内存中开始执行时，此时它又是动态的，被称作进程。一个进程涉及到很多方面，如：正在执行的二进制文件、虚拟内存、进程体系、进程状态、进程资源以及调度等等。下面的内容主要来谈谈进程的基本概念和管理。
    
    </summary>
    
    
      <category term="Linux" scheme="https://linxiao.pro/categories/Linux/"/>
    
    
      <category term="C" scheme="https://linxiao.pro/tags/C/"/>
    
      <category term="系统编程" scheme="https://linxiao.pro/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="进程" scheme="https://linxiao.pro/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux系统编程-系统属性</title>
    <link href="https://linxiao.pro/2019/12/04/linux-programming-sys-info/"/>
    <id>https://linxiao.pro/2019/12/04/linux-programming-sys-info/</id>
    <published>2019-12-04T10:24:26.000Z</published>
    <updated>2019-12-04T02:24:26.231Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统在运行时依赖大量的属性及配置文件，相信不少人深有体会。举个例子，比方说在执行<code>ls</code>命令或登录时，其实就会查看<code>/etc/passwd</code>和<code>/etc/group</code>文件，来确认当前进程是否有足够权限来执行操作。由于历史原因，系统中很多属性和配置都是以文本文件来存储，通过I/O的方式来直接操作这些数据并不高效，但有时又不得不用。更多时候，则倾向于使用系统调用或C库函数来操作系统属性。<a id="more"></a></p><h3 id="密码文件"><a href="#密码文件" class="headerlink" title="密码文件"></a>密码文件</h3><p>UNIX系统密码文件通常存储了用户基本信息，通过<code>cat /etc/passwd</code>命令可查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">gdm:x:123:128:Gnome Display Manager:/var/lib/gdm3:/bin/false</span><br><span class="line">noir:x:1000:1000:Darling,,,:/home/noir:/usr/bin/zsh</span><br><span class="line">sshd:x:124:65534::/run/sshd:/usr/sbin/nologin</span><br><span class="line">alan:x:1001:1001:Alan,,,:/home/alan:/bin/bash</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>字段之间用冒号分隔，含义依次如下：用户名:密码:用户ID:组ID:注释:主目录:登录shell。关于这些字段，以下几点需要额外注意：</p><ul><li>用户ID为0的是root用户；1~999是系统用户，它们不可登录，通常代表某一系统服务；1000及以上是普通用户</li><li>密码字段标记<code>x</code>时，表明该用户有密码，否则无。早期UNIX系统直接使用该字段存放密码，但由于<code>passwd</code>文件对所有用户开放可读权限，为了安全起见，现在将密码保存在<code>shadow</code>文件中</li><li>注释用于保存用户全名、地址、电话等信息，每个部分用逗号分隔，可以为空</li><li>登录shell是一个可执行程序，代表用户登录时所使用的shell环境，如果为空会取系统默认值，通常是<code>/bin/sh</code>。如果要阻止一个用户登录，那么可以使用<code>/bin/false</code>或<code>nologin</code>命令</li></ul><h4 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h4><p>以下两个库函数，可查看密码文件中的特定用户信息：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191203/20191203164731.png" alt=""></p><p>调用成功时，这两个函数都会返回一个指向结构体<code>passwd</code>的指针。区别在于<code>getpwnam</code>函数通过用户名<code>name</code>查询，而<code>getpwuid</code>通过用户<code>uid</code>查询。若没有相关用户信息或调用失败，则返回NULL，并设置相应的errno值。返回的结构体<code>passwd</code>是函数内部的静态变量，只要调用任一相关函数，其内容就会被重写，使用完后不需要通过<code>free</code>函数释放。再来看看结构体<code>passwd</code>中字段，其实是和<code>passwd</code>文件一一对应的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_name;       <span class="comment">/* username */</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_passwd;     <span class="comment">/* user password */</span></span><br><span class="line">    <span class="keyword">uid_t</span>   pw_uid;        <span class="comment">/* user ID */</span></span><br><span class="line">    <span class="keyword">gid_t</span>   pw_gid;        <span class="comment">/* group ID */</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_gecos;      <span class="comment">/* user information */</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_dir;        <span class="comment">/* home directory */</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_shell;      <span class="comment">/* shell program */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面用一个例子来演示如何通过用户名来查看用户基本信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">ptr</span>;</span></span><br><span class="line">    ptr = getpwnam(<span class="string">"alan"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"username:%20s\n"</span>, ptr-&gt;pw_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"password:%20s\n"</span>, ptr-&gt;pw_passwd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"userId:  %20u\n"</span>, ptr-&gt;pw_uid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"groupId: %20u\n"</span>, ptr-&gt;pw_gid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"home:    %20s\n"</span>, ptr-&gt;pw_dir);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shell:   %20s\n"</span>, ptr-&gt;pw_shell);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">username:                alan</span><br><span class="line">password:                   x</span><br><span class="line">userId:                  1001</span><br><span class="line">groupId:                 1001</span><br><span class="line">home:              /home/alan</span><br><span class="line">shell:              /bin/bash</span><br></pre></td></tr></table></figure><p>此外，如果知道用户ID（比如通过<code>stat</code>系统调用获取到的文件所有者ID），那么也可以反查得到用户信息，只需要将<code>getpwnam</code>替换成<code>getpwuid</code>，并且传入参数<code>uid</code>即可，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = getpwuid(<span class="number">1001</span>);</span><br></pre></td></tr></table></figure><p>两个函数返回的结构体数据完全一样。</p><h4 id="遍历用户信息"><a href="#遍历用户信息" class="headerlink" title="遍历用户信息"></a>遍历用户信息</h4><p>有时候需要查询所有用户信息，那么需要使用到以下三个函数：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191203/20191203214534.png" alt=""></p><p>与上面两个函数一样，<code>getpwent</code>返回一个结构体<code>passwd</code>的指针，第一次调用时，它会返回第一个账户信息，多次调用它会依次返回后续账户信息。当没有更多数据或调用失败时，返回NULL，并设置相应的errno值。<code>setpwent</code>函数用于回转到数据项开头，<code>endpwent</code>函数用于关闭数据表。下面通过代码来演示遍历所有用户名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    setpwent();</span><br><span class="line">    <span class="keyword">while</span> ((ptr = getpwent()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>, ptr-&gt;pw_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"getpwent"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    endpwent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root daemon bin sys sync games ...</span><br></pre></td></tr></table></figure><h3 id="阴影文件"><a href="#阴影文件" class="headerlink" title="阴影文件"></a>阴影文件</h3><p>阴影文件用于保存用户密码，此密码是被加密过的。加密算法通常是单向加密，所以无法从现有密码推导出到原始密码。常见的加密算法有MD5或SHA-1等。早期UNIX用户密码存放在<code>passwd</code>文件中，虽然无法反向得到明文密码，但仍然可以根据一些信息（如宠物名、生日、地址）生成密码，然后与密码文件中的密码进行试探匹配。由于<code>passwd</code>文件可被所有用户读取，其安全性并不高。为了弥补这一漏洞，Linux将用户密码放到<code>shadow</code>文件保存。可以尝试通过<code>cat /etc/shadow</code>命令查看此文件内容，即发现权限不够。因此，需要通过<code>sudo</code>提升权限，或以<code>root</code>身份执行此命令。现在来看看其中内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root:$6$pTBylslXVge8c58P$FdsFUJTLQRjHHjnAFntbioy6NcqdaWx4PaY4Y6qlQWn5Jg3VDhusx..ZuyHjv.r5szUcvHt1NH.AYFj4OvsPr1:18179:0:99999:7:::</span><br><span class="line">daemon:*:18002:0:99999:7:::</span><br><span class="line">bin:*:18002:0:99999:7:::</span><br><span class="line">sys:*:18002:0:99999:7:::</span><br><span class="line">gdm:*:18002:0:99999:7:::</span><br><span class="line">noir:$1$UyI9Ho1i$0KUjbgs9EuPeqNCjGj2mX1:18111:0:99999:7:::</span><br><span class="line">systemd-coredump:!!:18111::::::</span><br><span class="line">sshd:*:18111:0:99999:7:::</span><br><span class="line">alan:$6$NQqf17Ugjh./.9Ej$wH9EnSvyCGWj4CWF1Hea63OzRyO2kIpg12dGL0WRGvZGNo4H58VB5BkNRnxJpoBdDugVvSwaMhO58mCmslQ7d.:18232:0:99999:7:::</span><br></pre></td></tr></table></figure><p>本文件中的字段也是通过冒号来进行分隔，其含义依次是：用户名:加密密码:上次更改密码的时间:最小更改密码间隔:密码有效期限:密码过期提示时间:密码锁定期:账户有效期:保留字段。</p><h4 id="查看用户密码信息"><a href="#查看用户密码信息" class="headerlink" title="查看用户密码信息"></a>查看用户密码信息</h4><p>操作<code>/etc/shadow</code>文件同样有一组函数可用，这里只讲解其中最常用的几个，我们先来看如何通过<code>getspnam</code>来获取指定用户的密码信息：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191203/20191203222941.png" alt=""></p><p>参数<code>name</code>为需要查看的用户名，当调用成功时，返回指向结构体<code>spwd</code>的指针；调用失败或没有数据时，返回NULL，并设置相应的errno值。结构体<code>spwd</code>中的字段，其与<code>/etc/shadow</code>文件中的字段保持一致：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spwd</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *sp_namp;     <span class="comment">/* Login name */</span></span><br><span class="line">    <span class="keyword">char</span> *sp_pwdp;     <span class="comment">/* Encrypted password */</span></span><br><span class="line">    <span class="keyword">long</span>  sp_lstchg;   <span class="comment">/* Date of last change</span></span><br><span class="line"><span class="comment">                                     (measured in days since</span></span><br><span class="line"><span class="comment">                                     1970-01-01 00:00:00 +0000 (UTC)) */</span></span><br><span class="line">    <span class="keyword">long</span>  sp_min;      <span class="comment">/* Min # of days between changes */</span></span><br><span class="line">    <span class="keyword">long</span>  sp_max;      <span class="comment">/* Max # of days between changes */</span></span><br><span class="line">    <span class="keyword">long</span>  sp_warn;     <span class="comment">/* # of days before password expires</span></span><br><span class="line"><span class="comment">                                     to warn user to change it */</span></span><br><span class="line">    <span class="keyword">long</span>  sp_inact;    <span class="comment">/* # of days after password expires</span></span><br><span class="line"><span class="comment">                                     until account is disabled */</span></span><br><span class="line">    <span class="keyword">long</span>  sp_expire;   <span class="comment">/* Date when account expires</span></span><br><span class="line"><span class="comment">                                     (measured in days since</span></span><br><span class="line"><span class="comment">                                     1970-01-01 00:00:00 +0000 (UTC)) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sp_flag;  <span class="comment">/* Reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面用一个例子来演示获取用户<code>alan</code>的加密密码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shadow.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spwd</span> *<span class="title">ptr</span>;</span></span><br><span class="line">    ptr = getspnam(<span class="string">"alan"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"getspnam"</span>) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Encrypted passwd:%s\n"</span>, ptr-&gt;sp_pwdp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Encrypted passwd:$6$NQqf17Ugjh./.9Ej$wH9EnSvyCGWj4CWF1Hea63OzRyO2kIpg12dGL0WRGvZGNo4H58VB5BkNRnxJpoBdDugVvSwaMhO58mCmslQ7d.</span><br></pre></td></tr></table></figure><p>需要注意的是，编译成功后，执行此程序需要通过<code>sudo</code>提升权限，或以<code>root</code>身份执行。</p><h4 id="遍历用户密码信息"><a href="#遍历用户密码信息" class="headerlink" title="遍历用户密码信息"></a>遍历用户密码信息</h4><p>遍历时需要使用的函数上图已经给出，分别是<code>getspent</code>、<code>setspent</code>和<code>endspent</code>。<code>getspent</code>函数返回指向下一个用户密码信息数据项的指针，<code>setspent</code>函数用于回转数据项到初始位置，当数据读取完毕后，还需要通过<code>endspent</code>函数关闭数据流以释放资源。下面通过代码演示如何遍历用户密码信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shadow.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spwd</span> *<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    setspent();</span><br><span class="line">    <span class="keyword">while</span> ((ptr = getspent()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"username:%20s      last change:%10ld\n"</span>, ptr-&gt;sp_namp, ptr-&gt;sp_lstchg);</span><br><span class="line">    &#125;</span><br><span class="line">    endspent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  sudo ./a.out </span><br><span class="line">username:                root      last change:     18179</span><br><span class="line">username:              daemon      last change:     18002</span><br><span class="line">username:                 bin      last change:     18002</span><br><span class="line">username:                 sys      last change:     18002</span><br><span class="line">username:                sync      last change:     18002</span><br><span class="line">username:               games      last change:     18002</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="组文件"><a href="#组文件" class="headerlink" title="组文件"></a>组文件</h3><p>组文件用于保存组信息，可以通过<code>cat /etc/group</code>命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:</span><br><span class="line">bin:x:2:</span><br><span class="line">sys:x:3:</span><br><span class="line">adm:x:4:syslog,noir</span><br><span class="line">sudo:x:27:noir</span><br><span class="line">ssh:x:117:</span><br><span class="line">gdm:x:128:</span><br><span class="line">noir:x:1000:</span><br><span class="line">sambashare:x:129:noir</span><br><span class="line">systemd-coredump:x:999:</span><br><span class="line">alan:x:1001:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>依旧使用冒号分隔，从左到右每个字段的分别代表：组名:组密码:组ID:组成员。</p><h4 id="查看组信息"><a href="#查看组信息" class="headerlink" title="查看组信息"></a>查看组信息</h4><p>可以使用下面两个函数来查看组相关信息：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191203/20191203191429.png" alt=""></p><p><code>getgrnam</code>用于查看指定组名<code>name</code>的相关信息，若已经有组ID，则可使用<code>getgrgid</code>来获取组信息。两者调用成功时，都返回结构体<code>group</code>；若没有相关数据或调用失败则返回NULL，并设置相应的errno值。</p><p>下面来看结构体<code>group</code>数据，与<code>/etc/group</code>中字段是保持一致的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>   *gr_name;        <span class="comment">/* group name */</span></span><br><span class="line">    <span class="keyword">char</span>   *gr_passwd;      <span class="comment">/* group password */</span></span><br><span class="line">    <span class="keyword">gid_t</span>   gr_gid;         <span class="comment">/* group ID */</span></span><br><span class="line">    <span class="keyword">char</span>  **gr_mem;         <span class="comment">/* NULL-terminated array of pointers to names of group members */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字段<code>gr_mem</code>是一个指针数组，其中每个指针指向一个属于该组的成员。该数组以NULL指针结尾。如同对密码文件进行操作的函数一样，这两个函数通常也返回指向一个静态变量的指针，在每次调用时都重写该静态变量。</p><p>下面通过代码来演示，读取组<code>adm</code>的相关信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shadow.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">ptr</span>;</span></span><br><span class="line">    ptr = getgrnam(<span class="string">"adm"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"getgrnam"</span>) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"group name:       %s\n"</span>, ptr-&gt;gr_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"group password:   %s\n"</span>, ptr-&gt;gr_passwd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"group ID:         %d\n"</span>, ptr-&gt;gr_gid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> **name = ptr-&gt;gr_mem;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"group member:     "</span>);</span><br><span class="line">    <span class="keyword">while</span> (*name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>, *name);</span><br><span class="line">        name++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">group name:       adm</span><br><span class="line">group password:   x</span><br><span class="line">group ID:         4</span><br><span class="line">group member:     syslog noir</span><br></pre></td></tr></table></figure><h4 id="遍历组信息"><a href="#遍历组信息" class="headerlink" title="遍历组信息"></a>遍历组信息</h4><p>估计你也猜到了，遍历组信息同样需要使用三个函数：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191203/20191203232028.png" alt=""></p><p><code>getgrent</code>函数从组文件中读取下一个记录，如若该文件尚未打开，则先打开它。<code>setgrent</code>函数打开组文件（如若它尚未被打开)，并回转到初始位置。<code>endgrent</code>函数关闭组文件。下面来看代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    setgrent();</span><br><span class="line">    <span class="keyword">while</span> ((ptr = getgrent()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"group name:%20s    group ID:%5d\n"</span>, ptr-&gt;gr_name, ptr-&gt;gr_gid);</span><br><span class="line">    &#125;</span><br><span class="line">    endgrent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">group name:                root    group ID:    0</span><br><span class="line">group name:              daemon    group ID:    1</span><br><span class="line">group name:                 bin    group ID:    2</span><br><span class="line">group name:                 sys    group ID:    3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="其他属性文件"><a href="#其他属性文件" class="headerlink" title="其他属性文件"></a>其他属性文件</h3><p>上面讨论了三个系统属性文件：密码文件、阴影文件和组文件。而实际应用中，Linux还使用了很多其他属性文件。幸运的是，这些属性文件的接口都与上述我们所演示的接口相似。一般情况下，对于每个系统属性文件的操作至少有3个函数接口：</p><ul><li>get函数：读取下一条记录，如果文件没打开，则会先打开文件。此类函数通常返回指向一个结构体的指针，需要依次遍历，当已达到文件尾端时返回空指针。大多数get函数返回指向一个静态存储类结构的指针，如果要保存其内容，则需复制它。</li><li>set函数：打开相应属性文件（若尚未打开），并回转到文件起始位置。如果希望在相应文件起始处开始处理，则调用此函数。</li><li>end函数：关闭相应属性文件。如之前所述，在结束对属性文件的读、写操作后，总应调用此函数关闭所有相关文件。</li></ul><p>另外，如果属性文件支持某种形式的键搜索，则也会提供通过键返回指定信息的函数接口。例如密码文件，提供了两个函数<code>getpwnam</code>和<code>getpwuid</code>，分别用于从用户名和用户ID查询并返回相关记录。</p><p>下面列举了一些常用的属性文件及其数据访问接口，以供参考：</p><table><thead><tr><th>说明</th><th>属性文件</th><th>头文件</th><th>结构体</th><th>键搜索函数</th></tr></thead><tbody><tr><td>密码</td><td>/etc/passwd</td><td>&lt;pwd.h&gt;</td><td>passwd</td><td>getpwnam、getpwuid</td></tr><tr><td>组</td><td>/etc/group</td><td>&lt;grp.h&gt;</td><td>group</td><td>getgrnam、getgrgid</td></tr><tr><td>阴影</td><td>/etc/shadow</td><td>&lt;shadow.h&gt;</td><td>spwd</td><td>getspnam</td></tr><tr><td>主机</td><td>/etc/hosts</td><td>&lt;netdb.h&gt;</td><td>hostent</td><td>getnameinfo、getaddrinfo</td></tr><tr><td>网络</td><td>/etc/networks</td><td>&lt;netdb.h&gt;</td><td>netent</td><td>getnetbyname、getnetbyaddr</td></tr><tr><td>协议</td><td>/etc/protocols</td><td>&lt;netdb.h&gt;</td><td>protoent</td><td>getprotobyname、getprotobynumber</td></tr><tr><td>服务</td><td>/etc/services</td><td>&lt;netdb.h&gt;</td><td>servent</td><td>getservbyname、getservbyport</td></tr></tbody></table><h3 id="系统标识"><a href="#系统标识" class="headerlink" title="系统标识"></a>系统标识</h3><p>通过命令<code>uname -a</code>可以查看主机和操作系统的相关信息，在代码中，则是使用<code>uname</code>系统调用做到：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191203/20191204100457.png" alt=""></p><p>参数<code>buf</code>是需要传入的结构体<code>utsname</code>的指针，当调用成功时，会自动填充此结构体，并返回0。失败时，返回-1，并设置相应的errno值。下面是<code>utsname</code>的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> sysname[];    <span class="comment">/* Operating system name (e.g., "Linux") */</span></span><br><span class="line">    <span class="keyword">char</span> nodename[];   <span class="comment">/* Name within "some implementation-defined network" */</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">release</span>[];    <span class="comment">/* Operating system release (e.g., "2.6.28") */</span></span><br><span class="line">    <span class="keyword">char</span> version[];    <span class="comment">/* Operating system version */</span></span><br><span class="line">    <span class="keyword">char</span> machine[];    <span class="comment">/* Hardware identifier */</span></span><br><span class="line">    <span class="keyword">char</span> domainname[]; <span class="comment">/* NIS or YP domain name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过代码来演示打印系统标识信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = uname(&amp;ptr);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"uname"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sysname:  %s\n"</span>, ptr.sysname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nodename: %s\n"</span>, ptr.nodename);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"release:  %s\n"</span>, ptr.<span class="built_in">release</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"version:  %s\n"</span>, ptr.version);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"machine:  %s\n"</span>, ptr.machine);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要讲解了如何通过系统调用和函数来访问系统属性文件，并列举了三个例子：密码文件、阴影文件和组文件。其实系统属性文件的操作方式都是类似，通常情况下会提供一组遍历接口和一组键查询接口。当然，还有些存在于<code>/etc</code>下的属性和配置文件并没有访问接口，此时需要我们通过传统的I/O方式进行操作。除了<code>/etc</code>下的文件，虚拟文件系统<code>/proc</code>则提供了诸多系统运行时所需要的信息，其中的各类文件也是以I/O的操作方式居多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux系统在运行时依赖大量的属性及配置文件，相信不少人深有体会。举个例子，比方说在执行&lt;code&gt;ls&lt;/code&gt;命令或登录时，其实就会查看&lt;code&gt;/etc/passwd&lt;/code&gt;和&lt;code&gt;/etc/group&lt;/code&gt;文件，来确认当前进程是否有足够权限来执行操作。由于历史原因，系统中很多属性和配置都是以文本文件来存储，通过I/O的方式来直接操作这些数据并不高效，但有时又不得不用。更多时候，则倾向于使用系统调用或C库函数来操作系统属性。
    
    </summary>
    
    
      <category term="Linux" scheme="https://linxiao.pro/categories/Linux/"/>
    
    
      <category term="C" scheme="https://linxiao.pro/tags/C/"/>
    
      <category term="系统编程" scheme="https://linxiao.pro/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux系统编程-文件与目录管理</title>
    <link href="https://linxiao.pro/2019/12/03/linux-programming-file-and-directory/"/>
    <id>https://linxiao.pro/2019/12/03/linux-programming-file-and-directory/</id>
    <published>2019-12-03T11:03:01.000Z</published>
    <updated>2019-12-03T03:03:01.309Z</updated>
    
    <content type="html"><![CDATA[<p>之前讨论过大量关于文件I/O的系统调用，现在我们的视角从文件内部回到文件本身。在Linux中一切皆为文件，而文件包含大量的元数据。诸如：类型、权限、硬链接、软连接、所属用户、所属组、最后访问时间、最后修改时间、最后状态改变时间等。本篇主要讲解文件这些属性的获取与管理。<a id="more"></a></p><h3 id="从ls说起"><a href="#从ls说起" class="headerlink" title="从ls说起"></a>从ls说起</h3><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191130/20191130090457.png" alt=""></p><p>当需要查看文件属性的时候，通常使用最多的命令是<code>ls -l</code>，上图说明了各列所代表的含义，这里挑出以下两列进行补充说明：</p><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p><code>ls -l</code>命令所列文件属性的中第一列第一个字母代表文件类型，Linux文件一共分为7大类，用字母和符号<code>-</code>表示，其含义分别是：</p><ul><li><code>-</code> 普通文件</li><li><code>d</code> 目录文件，用于管理目录项，保存文件名和文件节点</li><li><code>c</code> 字符设备文件，如：/dev/input 下的键盘、鼠标</li><li><code>b</code> 块设备文件，如：/dev/下的磁盘。与字符设备的区别在于：块设备文件是以块（如4096字节）为单位来操作数据，而前者是以字节为单位来操作数据</li><li><code>p</code> FIFO管道文件，用于实现不同进程之间的通信</li><li><code>s</code> socket文件，用于网络通信</li><li><code>l</code> 符号链接文件，类似于Windows中的快捷方式，实则是指向另外一个文件的路径</li></ul><h4 id="硬链接数"><a href="#硬链接数" class="headerlink" title="硬链接数"></a>硬链接数</h4><p>每个文件在文件系统中是用一个<code>inode(索引节点)</code>来表示，同时<code>inode编号</code>也是文件系统中表示此文件的唯一数值。通常一个<code>inode节点</code>至少有一个硬链接，由此我们便可通过硬链接对该文件节点进行索引。如果一个文件有多个硬链接，那么每个硬链接所指向的<code>inode</code>节点是一样的，换句话说，他们只是这个文件节点的不同名字而已。如果一个<code>inode节点</code>的所有硬链接都被删除，那么它也就没有存在的价值，相当于是文件节点被删除。通过<code>ls -li</code>命令可以查看一个文件的<code>inode编号</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  touch a.txt                                # 创建文件</span><br><span class="line">➜  ln a.txt b.txt                             # 创建该文件的硬链接</span><br><span class="line">➜  ls -l                                      # 查看文件硬链接数</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r-- 2 noir noir 0 11月 29 18:08 a.txt</span><br><span class="line">-rw-r--r-- 2 noir noir 0 11月 29 18:08 b.txt</span><br><span class="line">➜  ls -li                                     # 查看硬链接所指向的文件inode节点编号</span><br><span class="line">总用量 0</span><br><span class="line">1441898 -rw-r--r-- 2 noir noir 0 11月 29 18:08 a.txt</span><br><span class="line">1441898 -rw-r--r-- 2 noir noir 0 11月 29 18:08 b.txt</span><br></pre></td></tr></table></figure><h3 id="stat系统调用"><a href="#stat系统调用" class="headerlink" title="stat系统调用"></a>stat系统调用</h3><p>要想实现类似于<code>ls -l</code>这样的功能，我们先要了解<code>stat</code>相关的系统调用</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191130/20191130105045.png" alt=""></p><p><code>stat</code>是一组函数，用于获取文件的元数据。上面三个函数的区别在于：<code>stat</code>函数会返回由参数<code>pathname</code>所指定的文件信息，而<code>fstat</code>返回由文件描述符<code>fd</code>所指向的文件信息。<code>lstat</code>与<code>stat</code>类似，唯一的区别是对于符号链接，<code>lstat</code>返回的是链接本身而非目标文件。以上三个函数调用出错时会返回-1，并设置相应的errno值，而调用成功，则将元数据存储在<code>stat</code>结构体中，即<code>statbuf</code>参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_dev;         <span class="comment">/* 文件所位于的设备节点ID，若文件不在本地，如在网络文件系统上，则该值为0 */</span></span><br><span class="line">    <span class="keyword">ino_t</span>     st_ino;         <span class="comment">/* 文件属性信息所在inode节点的编号 */</span></span><br><span class="line">    <span class="keyword">mode_t</span>    st_mode;        <span class="comment">/* 文件类型和访问权限 */</span></span><br><span class="line">    <span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">/* 文件节点的所有硬链接数 */</span></span><br><span class="line">    <span class="keyword">uid_t</span>     st_uid;         <span class="comment">/* 文件所有者的ID */</span></span><br><span class="line">    <span class="keyword">gid_t</span>     st_gid;         <span class="comment">/* 文件所属组的ID */</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_rdev;        <span class="comment">/* 如果文件是设备节点，则该字段描述设备节点ID */</span></span><br><span class="line">    <span class="keyword">off_t</span>     st_size;        <span class="comment">/* 文件大小字节数 */</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize;     <span class="comment">/* 文件系统进行I/O操作时的块大小，该值（或倍数）为用户缓冲I/O的最佳块大小 */</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* 分配给文件的块数目 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* 最近一次文件被访问的时间（读） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* 最近一次文件被修改的的时间（写） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* 最近一次文件状态改变的时间（所有者、所属组或权限变更） */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面可以看到关于块设备、时间的数据，这是通过<code>ls -l</code>无法获取的，此时可以使用<code>stat</code>命令。没错，<code>stat</code>既是系统调用，同时也是一个Linux命令，用于查看文件属性详细信息。需要注意的是Linux并不保存文件创建时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  stat cmake-3.15.1.tar.gz</span><br><span class="line">  File: cmake-3.15.1.tar.gz</span><br><span class="line">  Size: 9268592   Blocks: 18104      IO Block: 4096   regular file</span><br><span class="line">Device: 801h/2049dInode: 1966105     Links: 1</span><br><span class="line">Access: (0664/-rw-rw-r--)  Uid: ( 1000/    noir)   Gid: ( 1000/    noir)</span><br><span class="line">Access: 2019-08-05 02:54:52.985260332 -0700</span><br><span class="line">Modify: 2019-08-05 02:54:26.640913268 -0700</span><br><span class="line">Change: 2019-08-05 02:54:30.236958359 -0700</span><br></pre></td></tr></table></figure><p>下面我们来写一个例子<code>main.c</code>，用来读取自身的基本信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">"main.c"</span>, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"文件类型及权限：%o\t"</span>, buf.st_mode);        <span class="comment">// 输出文件类型和权限</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"硬链接数：%ld\t"</span>, buf.st_nlink);           <span class="comment">// 输出文件硬链接数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者：%d\t"</span>, buf.st_uid);                <span class="comment">// 输出文件所有者</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组：%d\t"</span>, buf.st_gid);                <span class="comment">// 输出文件所属组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"大小：%ld字节\t"</span>, buf.st_size);            <span class="comment">// 输出文件大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最后访问时间：%ld\t"</span>, buf.st_atim.tv_sec); <span class="comment">// 输出文件最后访问时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件类型及权限：100664硬链接数：1所有者：1000所属组：1000大小：79字节最后访问时间：1574991522</span><br></pre></td></tr></table></figure><p>可见，除了硬链接数和文件大小能很清晰的知道其含义，其余几个字段并不像<code>ls -l</code>输出那般直观。但仔细想想，所有者和所属组用数字表示，应该是指代ID，从<code>/etc/passwd</code>和<code>/etc/group</code>文件中可以很容易找到其对应的名称。而最后访问时间，看这长度也能联想到，它指代Unix时间戳。如何从用户ID及组ID反向得到名称，以及解析时间属于系统信息相关内容，暂时先放到后续篇章吧。本文主要讲述文件属性，所以我们先把注意力放到文件类型解析和权限上面。</p><h4 id="文件类型解析"><a href="#文件类型解析" class="headerlink" title="文件类型解析"></a>文件类型解析</h4><p>通过代码来演示如何解析文件类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">"main.c"</span>, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File type:"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (buf.st_mode &amp; S_IFMT) &#123;</span><br><span class="line">        <span class="keyword">case</span> S_IFBLK:  <span class="built_in">printf</span>(<span class="string">"block device\n"</span>);            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR:  <span class="built_in">printf</span>(<span class="string">"character device\n"</span>);        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR:  <span class="built_in">printf</span>(<span class="string">"directory\n"</span>);               <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO:  <span class="built_in">printf</span>(<span class="string">"FIFO/pipe\n"</span>);               <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK:  <span class="built_in">printf</span>(<span class="string">"symlink\n"</span>);                 <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG:  <span class="built_in">printf</span>(<span class="string">"regular file\n"</span>);            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFSOCK: <span class="built_in">printf</span>(<span class="string">"socket\n"</span>);                  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:       <span class="built_in">printf</span>(<span class="string">"unknown?\n"</span>);                <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File type:regular file</span><br></pre></td></tr></table></figure><p>可以看到上述代码的关键步骤，其实是把<code>st_mode</code>&amp;<code>S_IFMT</code>，然后通过匹配一系列宏来得到具体文件类型。为什么可以这样做，首先我们从<code>st_mode</code>说起。上面打印出的<code>st_mode</code>是八进制的100664，我们将其转换成二进制来看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OCT    100 664</span><br><span class="line">BIN    1000 000 110 110 100</span><br></pre></td></tr></table></figure><p>上面的二进制位中，第0-8位代表访问权限，13-15位代表文件类型。先记住这个规律，然后再来看<code>S_IFMT</code>宏，我们可以先在<code>sys/stat.h</code>中找到其定义，然后在<code>bits/stat.h</code>中找到最终定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span>   S_IFMT__S_IFMT</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span>   __S_IFMT    0170000 <span class="comment">/* These bits determine file type.  *</span></span></span><br></pre></td></tr></table></figure><p>可以看到<code>S_IFMT</code>实际上是一串八进制码，现在将其转换成二进制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OCT    0170000</span><br><span class="line">BIN    1111 000 000 000 000</span><br></pre></td></tr></table></figure><p>所以，一旦<code>st_mode</code>&amp;<code>S_IFMT</code>，实际上也就是说，0-12位被屏蔽了，剩下的13-15位代表真正的文件类型，我们拿着它和文件类型的宏定义进行匹配就行了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st_mode    1000 000 110 110 100   </span><br><span class="line">&amp;</span><br><span class="line">S_IFMT     1111 000 000 000 000</span><br><span class="line">-------------------------------</span><br><span class="line">           1000 000 000 000 000</span><br></pre></td></tr></table></figure><p>再来看文件类型宏定义，同样先在<code>sys/stat.h</code>中找到其定义，然后在<code>bits/stat.h</code>中找到最终定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> S_IFDIR__S_IFDIR</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> S_IFCHR__S_IFCHR</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> S_IFBLK__S_IFBLK</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> S_IFREG__S_IFREG</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> S_IFIFO__S_IFIFO</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> S_IFLNK__S_IFLNK</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> S_IFSOCK__S_IFSOCK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* File types.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFDIR0040000<span class="comment">/* Directory. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFCHR0020000<span class="comment">/* Character device.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFBLK0060000<span class="comment">/* Block device.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFREG0100000<span class="comment">/* Regular file.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFIFO0010000<span class="comment">/* FIFO.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFLNK0120000<span class="comment">/* Symbolic link.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFSOCK0140000<span class="comment">/* Socket.  */</span></span></span><br></pre></td></tr></table></figure><p>上面的代码并不太直观，我们进行一个整理，列出下表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">文件类型    八进制码    二进制码  </span><br><span class="line">S_IFDIR   0040000    0100 000 000 000 000</span><br><span class="line">S_IFCHR   0020000    0010 000 000 000 000</span><br><span class="line">S_IFBLK   0060000    0110 000 000 000 000</span><br><span class="line">S_IFREG   0100000    1000 000 000 000 000</span><br><span class="line">S_IFIFO   0010000    0001 000 000 000 000</span><br><span class="line">S_IFLNK   0120000    1010 000 000 000 000</span><br><span class="line">S_IFSOCK   0140000    1100 000 000 000 000</span><br></pre></td></tr></table></figure><p>可见，上面由<code>st_mode</code>&amp;<code>S_IFMT</code>得到的文件类型二进制码刚好与<code>S_IFREG</code>相匹配，说明此文件是普通文件。实际上在<code>sys/stat.h</code>中提供了一系列带参宏，以方便我们进行快速文件判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Test macros for file types.*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_ISTYPE(mode, mask)(((mode) &amp; __S_IFMT) == (mask))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_ISDIR(mode) __S_ISTYPE((mode), __S_IFDIR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_ISCHR(mode) __S_ISTYPE((mode), __S_IFCHR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_ISBLK(mode) __S_ISTYPE((mode), __S_IFBLK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_ISREG(mode) __S_ISTYPE((mode), __S_IFREG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISFIFO(mode) __S_ISTYPE((mode), __S_IFIFO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISLNK(mode) __S_ISTYPE((mode), __S_IFLNK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISSOCK(mode)   __S_ISTYPE((mode), __S_IFSOCK)</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">"../main.c"</span>, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Is regular file: %d\n"</span>, S_ISREG(buf.st_mode));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Is directory:    %d\n"</span>, S_ISDIR(buf.st_mode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Is regular file: 1</span><br><span class="line">Is directory:    0</span><br></pre></td></tr></table></figure><p>到这里，文件类型解析部分已讲完，下面来看看文件权限解析。</p><h4 id="文件权限解析"><a href="#文件权限解析" class="headerlink" title="文件权限解析"></a>文件权限解析</h4><p>其实文件权限解析与文件类型解析的方式如出一辙，我们先来看代码，再进行讲解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">"../main.c"</span>, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者可读取：       %o\n"</span>, S_IRUSR&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者可写入：       %o\n"</span>, S_IWUSR&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者可执行：       %o\n"</span>, S_IXUSR&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者可读写执行：    %o\n"</span>, S_IRWXU&amp;buf.st_mode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组可读取：       %o\n"</span>, S_IRGRP&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组可写入：       %o\n"</span>, S_IWGRP&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组可执行：       %o\n"</span>, S_IXGRP&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组可读写执行：    %o\n"</span>, S_IRWXG&amp;buf.st_mode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他人可读取：       %o\n"</span>, S_IROTH&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他人可写入：       %o\n"</span>, S_IWOTH&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他人可执行：       %o\n"</span>, S_IXOTH&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他人可读写执行：    %o\n"</span>, S_IRWXO&amp;buf.st_mode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"文件权限：           %o\n"</span>, (S_IRWXU&amp;buf.st_mode)|(S_IRWXG&amp;buf.st_mode)|(S_IRWXO&amp;buf.st_mode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">所有者可读取：       400</span><br><span class="line">所有者可写入：       200</span><br><span class="line">所有者可执行：       0</span><br><span class="line">所有者可读写执行：    600</span><br><span class="line">所属组可读取：       40</span><br><span class="line">所属组可写入：       20</span><br><span class="line">所属组可执行：       0</span><br><span class="line">所属组可读写执行：    60</span><br><span class="line">其他人可读取：       4</span><br><span class="line">其他人可写入：       0</span><br><span class="line">其他人可执行：       0</span><br><span class="line">其他人可读写执行：    4</span><br><span class="line">文件权限：           664</span><br></pre></td></tr></table></figure><p>通过代码可以很直观的获取每个具体权限，并得到文件的整体权限是664，换句话说，该文件权限为<code>rw-rw-r--</code>。在<code>st_mode</code>中，0~8共9位二进制码分三组来表示所有者、所属组和其他人的读、写、执行权限。如下所示，1表示该位有权限，0表示没有。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OCT    664</span><br><span class="line">       所有者  所属组  其他人</span><br><span class="line">       rwx     rwx    rwx</span><br><span class="line">BIN    110     110    100</span><br></pre></td></tr></table></figure><p>而<code>S_IRUSR S_IWUSR S_IXUSR...</code>这类宏则是用于测试二进制位是否持有对应的权限，可以在<code>sys/stat.h</code>和<code>bits/stat.h</code>中找到他们的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IRUSR__S_IREAD<span class="comment">/* Read by owner.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IWUSR__S_IWRITE<span class="comment">/* Write by owner.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IXUSR__S_IEXEC<span class="comment">/* Execute by owner.  */</span></span></span><br><span class="line"><span class="comment">/* Read, write, and execute by owner.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IRWXU(__S_IREAD|__S_IWRITE|__S_IEXEC)  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IREAD0400<span class="comment">/* Read by owner.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IWRITE0200<span class="comment">/* Write by owner.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IEXEC0100<span class="comment">/* Execute by owner.  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IRGRP(S_IRUSR &gt;&gt; 3)<span class="comment">/* Read by group.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IWGRP(S_IWUSR &gt;&gt; 3)<span class="comment">/* Write by group.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IXGRP(S_IXUSR &gt;&gt; 3)<span class="comment">/* Execute by group.  */</span></span></span><br><span class="line"><span class="comment">/* Read, write, and execute by group.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IRWXG(S_IRWXU &gt;&gt; 3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IROTH(S_IRGRP &gt;&gt; 3)<span class="comment">/* Read by others.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IWOTH(S_IWGRP &gt;&gt; 3)<span class="comment">/* Write by others.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IXOTH(S_IXGRP &gt;&gt; 3)<span class="comment">/* Execute by others.  */</span></span></span><br><span class="line"><span class="comment">/* Read, write, and execute by others.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IRWXO(S_IRWXG &gt;&gt; 3)</span></span><br></pre></td></tr></table></figure><p>需要注意的是组相关权限二进制码是对所有者相关权限进行右移3位，而其他人相关权限又是对组用户相关权限进行右移3位操作。现在来举个例子，假如我们要判断所有者是否可读，那么需要通过<code>st_mode &amp; S_IRUSR</code>，换成二进制代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OCT    664</span><br><span class="line">BIN    110 110 100    </span><br><span class="line">&amp; S_IRUSR</span><br><span class="line">OCT    400</span><br><span class="line">BIN    100 000 000</span><br><span class="line">------------------</span><br><span class="line">       100 000 000</span><br></pre></td></tr></table></figure><p>可见，通过按位与操作后，屏蔽了0~7位，在第8位上标记了所有者可读的权限。其余的判断也是以此类推。至此，我们学完了文件权限解析。</p><h3 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h3><p>通过<code>stat</code>系统调用可以获取到文件权限属性，但仅获取是不够的，我们还需要学会设置权限。通常情况下，在Linux系统中设置访问权限和所有权最常用的命令是<code>chmod</code>及<code>chown</code>。而在系统编程这一层级，这两个命令内部的核心实现又是系统调用<code>chmod</code>和系统调用<code>chown</code>，我们可以通过<code>man 2 chmod</code>和<code>man 2 chown</code>来查看。</p><h4 id="访问权限设置"><a href="#访问权限设置" class="headerlink" title="访问权限设置"></a>访问权限设置</h4><p>先来看看<code>chmod</code>的定义：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202110139.png" alt=""></p><p><code>chmod</code>和<code>fchmod</code>都可以把文件权限设置为参数<code>mode</code>指定的值。对于<code>chmod</code>函数，参数<code>pathname</code>表示需要修改的文件的相对或绝对路径名。对于<code>fchmod</code>函数，文件是由文件描述符<code>fd</code>给定。类型<code>mode_t</code>(整形)表示的是参数<code>mode</code>的合法值，和结构体<code>stat</code>中字段<code>st_mode</code>返回的值一样。上面我们学到过一系列描述权限位的宏，在此我们可以通过或运算来组合这些权限位，生成合法的<code>mode</code>值。例如（S_IRUSR|S_IRGRP）会同时把文件所有者和所属组的权限都设置为可读。</p><p>需要注意的是，为了改变文件权限，调用<code>chmod</code>和<code>fchmod</code>的进程有效ID必须匹配文件所有者。换句话说，如果文件file的所有者是alan，那么必须alan这一用户执行系统调用，才能改变file的权限。当然，如果是root用户，就不会有这一限制。</p><p>调用成功时，<code>chmod</code>和<code>fchmod</code>都返回0，失败时，都返回-1，并设置相应的errno值。下面来举个例子，现有文件<code>test.txt</code>，权限为777，通过代码将其变成660：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ls -l test.txt </span><br><span class="line">-rwxrwxrwx 1 noir noir 0 12月  1 19:21 test.txt</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = chmod(<span class="string">"../test.txt"</span>, <span class="number">0660</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"chmod"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ls -l test.txt</span><br><span class="line">-rw-rw---- 1 noir noir 0 12月  1 19:21 test.txt</span><br></pre></td></tr></table></figure><p>之前说到过<code>mode</code>参数需要通过权限位宏进行组合来生成需要的值，这里我们直接使用了<code>0666</code>这样的八进制值也是可以的。并且如果你对Linux应用足够熟悉的话，这么做反而更加直观。</p><h4 id="所有权设置"><a href="#所有权设置" class="headerlink" title="所有权设置"></a>所有权设置</h4><p>在结构体<code>stat</code>中，我们看到过<code>st_uid</code>和<code>st_gid</code>，它们分别表示文件的所有者和所属组。通过以下三个系统调用可以改变这两个值，即改变文件的所有者和所属组：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202122005.png" alt=""></p><p><code>chown</code>和<code>lchown</code>设置路径<code>pathname</code>指定的文件的所有权。它们的作用是相同的，除非文件是个符号链接：前者会获取符号链接所指向的目标文件，并改变链接目标而不是链接本身的所有权，而<code>lchown</code>并不会获取符号链接所指向的目标文件，只是改变符号链接本身的所有权。<code>fchown</code>则设置文件描述符<code>fd</code>所指向的文件的所有权。</p><p>成功时，三个调用都会把文件所有者设置为<code>owner</code>，文件所属组设置为<code>group</code>，并返回0。如果参数<code>owner</code>或<code>group</code>的值为-1，说明值没有设定。失败时，均返回-1，并设置相应的errno值。需要注意的是，通常情况下只有root用户才有权限对文件所有权进行变更。一般用户，即无法改变自己文件的所有者和所属组，亦无法改变别人的文件。</p><p>下面进行演示，如何先使用<code>adduser</code>命令创建一个新用户<code>alan</code>和与之相应的用户组，然后再通过代码将所有权和所属组为<code>noir</code>的文件<code>test.txt</code>变更到<code>alan</code>下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  sudo adduser alan                               # 创建用户和用户组alan</span><br><span class="line">➜  cat /etc/passwd | tail -n1                </span><br><span class="line">alan:x:1001:1001:Alan,,,:/home/alan:/bin/bash       # 查看到alan的用户id为1001</span><br><span class="line">➜  cat /etc/group | tail -n1                 </span><br><span class="line">alan:x:1001:                                        # 查看到alan的用户组id也为1001</span><br><span class="line">➜  ls -l test.txt                                  </span><br><span class="line">-rw-rw---- 1 noir noir 0 12月  1 19:21 test.txt     # 查看到test.txt的所有者和所属组均为noir</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = chown(<span class="string">"test.txt"</span>, <span class="number">1001</span>, <span class="number">1001</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"chown"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件所有权修改成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成功后，需要使用<code>sudo</code>提升权限，或用<code>root</code>用户登录执行程序。执行成功查看<code>text.txt</code>文件所有权，已经成功变更：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ls -l test.txt </span><br><span class="line">-rw-rw---- 1 alan alan 0 12月  1 19:21 test.txt</span><br></pre></td></tr></table></figure><p>代码比较简单，只是在<code>chown</code>中把参数写死，而不是通过查询得到<code>uid</code>和<code>gid</code>，这种操作并不好。但由于本篇主要讲解的还是文件相关，所以如何通过用户名反查得到id，暂时先搁置，等到了解系统属性和用户相关的系统调用的时候再说。此外，不少人刚开始接触Linux的时候，对多用户和组的概念并不十分清晰，主要是因为我们现在用的都是个人计算机。而在以前，计算机可是庞然大物，一个学校和一个机构可能仅有一台计算机，大家都是通过终端来连接这台机器进行工作。为了划分权限，提高安全性以及分组管理，于是也就出现了文件所有者和所属组以及其他用户这些概念。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>前面讲到过，文件其实是用<code>inode节点来表示</code>，通过硬链接可以索引到相应的<code>inode节点</code>，也就是说链接相当于节点的名字。奇怪的是，我们使用<code>stat</code>系统调用查看文件属性的时候并没有看到描述文件名称的字段，只有硬链接数。这是因为，文件名并不保存在<code>inode节点</code>，而是保存在目录中。目录中的每个名字其实也就是一个硬链接。这样一来，也就维系了目录与文件<code>inode节点</code>的组织关系。需要注意的是，不同文件系统的<code>inode编号</code>并不一致，所以硬链接并不能跨磁盘。</p><p>文件的链接数可以是0、1或多个。大多数文件的链接数是1，也就是说只有一个目录项指向该文件，但有些文件可能有两个或甚至多个链接。链接数为0的文件在文件系统上没有对应的目录项。当文件链接计数达到0时，文件被标记为空闲，其占用的磁盘块就可被重用。当进程打开了这样一个文件时，文件仍在文件系统中保留。如果没有进程打开该文件，文件就会被删除。</p><p>Linux内核通过<code>链接计数</code>和<code>使用计数</code>来进行管理。使用计数是指文件被打开的实例数。只有当某个文件的链接计数和使用计数都为0时，该文件才会从文件系统中删除。</p><p>另一种链接是符号链接，它不是文件系统中文件名和<code>inode节点</code>的映射，而是更高层次的指针，在运行时解释。因此符号链接可跨域文件系统。</p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>通过<code>link</code>系统调用可以为已有的文件创建新的硬链接(或称作别名）：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202143001.png" alt=""></p><p>成功调用<code>link</code>会为<code>oldpath</code>所指向的文件，在路径<code>newpath</code>下创建新的硬链接，也可以说是别名。因为调用成功后，<code>oldpath</code>和<code>newpath</code>都会指向到同一个文件上，事实上并没有办法区分哪个是初始链接。调用失败，则返回-1，并设置相应的errno值。下面来看代码演示，我们为当前目录下的<code>test.txt</code>创建一个新的目录项（硬链接）<code>test2.txt</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = link(<span class="string">"./test.txt"</span>, <span class="string">"./test2.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"link"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建成功后我们删除<code>test.txt</code>，发现通过<code>test2.txt</code>依然可以访问原文件。只有把<code>test2.txt</code>删除，并且此时没有任何进程打开此文件的时候，那么该文件才算是彻底被删除。</p><p>需要注意的是，硬链接不能指向目录，因为硬链接映射的是文件<code>inode节点</code>，而目录不是<code>inode节点</code>。虽然硬链接无法指向目录，但是下面要讲的符号链接可以。</p><h4 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h4><p>符号链接，也称为<code>symlinks</code>或<code>软链接</code>。它和硬链接的相同之处在于二者均指向文件系统中的文件，不同点在于符号链接不会增加额外的目录项，而是一种特殊的文件类型。该文件包含了它所指向的目标文件的路径名。运行时，内核用该路径名代替符号链接的路径名(若使用以<code>l</code>开头的系统调用，例如<code>lstat</code>，它操作的则是链接本身而非目标文件)。一个硬链接与指向同一文件的另一个硬链接很难区分，但很容易区分符号链接以及其目标文件。软链接和硬链接相比，另一个很重要的区别点在于：由于它是对路径的映射而非<code>inode</code>节点的映射，所以可以跨越不同的文件系统。当然，符号链接也可以指向一个不存在的文件，但通常这没有任何意义。创建符号链接的系统调用和创建硬链接的系统调用非常类似：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202154031.png" alt=""></p><p><code>symlink</code>调用成功时，会创建符号链接<code>linkpath</code>，指向由<code>target</code>所表示的目标文件，并返回0，出错时返回-1，并设置相应的errno值。下面来看代码演示，与上例类似，我们为当前目录下的<code>test.txt</code>创建一个新的软链接<code>test2.txt</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = symlink(<span class="string">"./test.txt"</span>, <span class="string">"./test2.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"symlink"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读取符号链接路径"><a href="#读取符号链接路径" class="headerlink" title="读取符号链接路径"></a>读取符号链接路径</h5><p>通过<code>symlink</code>可以为指定的文件创建符号链接，也可通过<code>readlink</code>系统调用来反向读取符号链接所指向的目标文件路径：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202155931.png" alt=""></p><p><code>pathname</code>为需要反向读取的符号链接路径，<code>buf</code>用于存放目标文件路径，<code>bufsiz</code>用来指定读取多少个字节到<code>buf</code>中。当调用成功时，<code>readlink</code>返回读取的字节数，若返回的数值与<code>bufsiz</code>参数相等，则说明目标文件路径发生了截短。出错时，返回-1，并设置相应的errno值。上面我们已经有了符号链接<code>test2.txt</code>，下面通过代码来演示读取其目标路径：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    ret = readlink(<span class="string">"test2.txt"</span>, buf, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"readlink"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为路径字符串设置尾标记以方便读取</span></span><br><span class="line">    buf[ret] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.txt          # 此为符号链接所指向的目标文件路径</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>readlink</code>系统调用仅针对符号链接有效，而无法反向获取硬链接所指向的目标文件。前面已经讲过，多个硬链接指向同一个<code>inode节点</code>的时候，并没有主次之分。</p><h4 id="解除链接"><a href="#解除链接" class="headerlink" title="解除链接"></a>解除链接</h4><p> 建立链接的反向操作是解除链接，即从文件系统中删除路径名。只需要调用<code>unlink</code>，就可以完成任务：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202163535.png" alt=""></p><p><code>unlink</code>调用成功时，会从文件系统中删除<code>pathname</code>，并返回0。如果<code>pathname</code>是指向文件的最后一个硬链接，则会从文件系统中彻底删除该文件。如果进程已经打开文件，在进程关闭文件前，内核不会从文件系统中删除文件。若没有进程打开该文件，文件会被删除。如果<code>pathname</code>指向符号链接，则只会删除该链接，而不会删除目标文件。出错时，<code>unlink</code>返回-1，并设置相应的errno值。下面通过代码来演示删除软链接文件<code>test2.txt</code>和硬链接文件<code>test.txt</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 noir noir    8 12月  2 00:09 test2.txt -&gt; test.txt</span><br><span class="line">-rw-rw-r-- 1 noir noir    0 12月  1 23:52 test.txt</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret1 = unlink(<span class="string">"./test2.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"删除软连接失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret2 = unlink(<span class="string">"./test.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"删除硬连接失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一个<code>unlink</code>被调用时，删除的只是软链接文件，对目标文件<code>test.txt</code>并不会造成影响。而当第二个<code>unlink</code>调用时，由于此时<code>test.txt</code>硬链接总数只有1，因此该文件会被删除。</p><p>需要注意的是，<code>unlink</code>无法删除目录。</p><h5 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h5><p>通过<code>链接计数</code>和<code>使用计数</code>这两个特性，我们可以利用<code>unlink</code>来创建临时文件，即进程运行时，可正常访问，进程退出后，文件消失。下面通过代码来演示如何创建临时文件<code>data.tmp</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">// 创建新文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"./data.tmp"</span>, O_WRONLY|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件创建成功后，硬链接数为1，此时通过unlink解除链接</span></span><br><span class="line">    unlink(<span class="string">"./data.tmp"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处执行进程运行中的读写操作</span></span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"hello world"</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程退出前关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结下来，一共分四步：</p><ul><li>通过<code>open</code>或<code>creat</code>系统调用创建文件</li><li>文件创建成功后，马上通过<code>unlink</code>系统调用解除该文件的链接</li><li>正常使用此文件进行读写操作，此时目录无法索引此文件，但文件依然可用</li><li>进程退出前关闭文件描述符，进程退出后，文件便会自动被删除</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>前面通过使用<code>unlink</code>的方式删除文件，为了简化对各类型文件的删除，C语言提供了<code>remove</code>函数。由于此函数并非系统调用，我们需要通过<code>man 3 remove</code>来查看相应文档：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202171448.png" alt=""></p><p>成功调用<code>remove</code>时，会从文件系统删除<code>pathname</code>，并返回0。如果<code>pathname</code>是一个文件，<code>remove</code>会调用<code>unlink</code>；如果<code>pathname</code>是个目录，<code>remove</code>会调用<code>rmdir</code>完成目录删除。关于<code>rmdir</code>放到后面目录主题来讲解。出错时，<code>remove</code>返回-1，并设置相应errno值。下面通过代码来演示删除一个普通文件<code>test.txt</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = <span class="built_in">remove</span>(<span class="string">"test.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p><code>cp</code>拷贝应该是Linux系统中最常使用的命令之一，然而令人沮丧的是，它并没有直接对应的系统调用可供使用，而是通过一系列的文件I/O操作。举个例子，要拷贝文件<code>src</code>至文件<code>dst</code>，需要执行以下步骤：</p><ol><li>打开src</li><li>打开dst，如果dst不存在则创建，如果已存在则把其长度截断为零</li><li>把src数据块读取到内存</li><li>把该数据块写入dst</li><li>继续操作直到src全部读取完并已经都写入到dst中</li><li>关闭dst</li><li>关闭src</li></ol><p>下面我们根据这些步骤来写一段代码，以演示如何将当前源码文件<code>main.c</code>备份到<code>backup.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd_src, fd_dst;</span><br><span class="line">    fd_src = <span class="built_in">open</span>(<span class="string">"main.c"</span>, O_RDONLY);</span><br><span class="line">    fd_dst = <span class="built_in">open</span>(<span class="string">"backup.c"</span>, O_WRONLY | O_CREAT | O_TRUNC);</span><br><span class="line">    <span class="keyword">if</span> (fd_src == <span class="number">-1</span> || fd_dst == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 循环从fd_src中读取数据，并写入到fd_dst中</span></span><br><span class="line">    <span class="keyword">while</span> ((len = <span class="built_in">read</span>(fd_src, buf, <span class="number">100</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(fd_dst, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd_dst);</span><br><span class="line">    <span class="built_in">close</span>(fd_src);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，实际上Linux系统中的<code>cp</code>命令要复杂得多，需要考虑的情况也很多，这里只是做一个基本演示，详细可以查看<code>cp</code>命令源码：<a href="https://github.com/coreutils/coreutils/blob/master/src/cp.c" target="_blank" rel="noopener">点此查看</a></p><h3 id="移动、重命名"><a href="#移动、重命名" class="headerlink" title="移动、重命名"></a>移动、重命名</h3><p>与拷贝文件不同，UNIX提供了<code>rename</code>系统调用来进行移动和重命名操作：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202181701.png" alt=""></p><p>成功调用<code>rename</code>时会返回0，原来由<code>oldpath</code>指向的文件现在变成由<code>newpath</code>指向。失败时，调用返回-1，但不影响<code>oldpath</code>或<code>newpath</code>，并设置相应的errno值。下面通过代码来演示如何将文件<code>a.txt</code>重命名为<code>b.txt</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = rename(<span class="string">"./a.txt"</span>, <span class="string">"./b.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"rename"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得说明的是，在相同目录层级下，<code>rename</code>系统调用为重命名操作。而不同目录层级，则为移动。事实上并没有移动这么一说，文件<code>inode节点</code>没有发生任何变化，只是指向它的链接（路径）变了而已。这也就要求，在进行<code>rename</code>系统调用的时候必须在相同文件系统内，否则会发生未知错误。</p><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>在UNIX中，目录是个简单的概念：它包含一个文件名列表，每个文件名对应一个<code>inode编号</code>。每个文件名称为目录项，每个目录项到<code>inode节点</code>的映射称为链接。目录内容（就是用户执行ls命令所看到的结果）就是该目录下所有文件名列表。当用户打开指定目录下的文件时，内核会在该目录列表中查找文件名所对应的<code>inode编号</code>，并将该<code>inode编号</code>传递给文件系统，文件系统使用它来寻找文件在设备上的物理位置。</p><h4 id="获取当前工作目录"><a href="#获取当前工作目录" class="headerlink" title="获取当前工作目录"></a>获取当前工作目录</h4><p>每个进程都有一个当前工作目录，一般是在创建时从父进程继承的。当未指定绝对路径时，当前进程进行的任何文件操作，都是以此目录为相对路径进行。获取当前工作目录的方法是通过系统调用<code>getcwd</code>:</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202192634.png" alt=""></p><p>成功调用<code>getcwd</code>会把当前工作目录以绝对路径名形式拷贝到<code>buf</code>指向的长度为<code>size</code>字节的缓冲区中，并返回一个指向<code>buf</code>的指针。失败时，调用返回<code>NULL</code>，并设置相应的errno值，下面是使用<code>getcwd</code>的一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span> (!getcwd(buf, <span class="number">100</span>)) &#123;</span><br><span class="line">        perror(<span class="string">"getcwd"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前工作目录的绝对路径名大小要大于<code>size</code>个字节，那么会返回NULL；如果<code>buf</code>为NULL，则<code>getcwd</code>的行为是未定义的。在这种情况下，Linux的C库将分配一个长度为<code>size</code>的缓冲区，并在那存储当前工作目录。如果<code>size</code>为0，C库将分配足够大小的缓冲区存储当前工作目录。调用结束后，则由应用程序负责使用<code>free</code>函数来释放缓冲区。如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    path = getcwd(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"getcwd"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, path);</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux的C库也提供<code>get_current_dir_name</code>函数，当使用<code>getcwd</code>并且传递的<code>buf</code>为NULL，<code>size</code>为0时，其行为与前者一致：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    path = get_current_dir_name();</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"get_current_dir_name"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, path);</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>较早的BSD系统喜欢调用<code>getwd</code>，Linux对其提供向后兼容，调用<code>getwd</code>会把当前工作目录拷贝到<code>buf</code>中，<code>buf</code>的字节长度至少为<code>PATH_MAX</code>。成功时，调用会返回<code>buf</code>指针，而失败时，返回NULL。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[PATH_MAX];</span><br><span class="line">    <span class="keyword">if</span> (!getwd(path)) &#123;</span><br><span class="line">        perror(<span class="string">"getwd"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, path);</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的系统Ubuntu中，编译时会报警告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">警告： the `getwd' function is dangerous and should not be used.</span><br></pre></td></tr></table></figure><p>出于移植性与安全性双重原因，应用程序不应该使用<code>getwd</code>，推荐使用<code>getcwd</code>。</p><h4 id="改变当前工作目录"><a href="#改变当前工作目录" class="headerlink" title="改变当前工作目录"></a>改变当前工作目录</h4><p>Linux系统提供了两个系统调用来更改当前工作目录，一个接受目录路径名，而另一个接受指向已打开的目录的文件描述符：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202202837.png" alt=""></p><p><code>chdir</code>会把当前工作目录更改为<code>path</code>指定的路径名，该路径名可以是绝对路径，也可以是相对路径。同样，<code>fchdir</code>会把当前工作目录更改为文件描述符<code>fd</code>指向的路径名，而<code>fd</code>必须是打开的目录。成功时，两个调用都返回0；失败时，都返回-1，并设置相应的errno值。如下代码演示切换路径到根目录<code>/</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = chdir(<span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"chdir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    path = getcwd(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"getcwd"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, path);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>在Linux系统中创建目录使用<code>mkdir</code>命令，同样这也是一个系统调用：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202204218.png" alt=""></p><p>成功调用<code>mkdir</code>会创建参数<code>pathname</code>所指定的目录（可以是绝对也可以是相对），其权限位为mode（可以通过umask修改），并返回0。调用失败时，<code>mkdir</code>返回-1，并设置相应errno值。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = <span class="built_in">mkdir</span>(<span class="string">"./a"</span>, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"mkdir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在当前工作目录下创建文件夹<code>a</code>，权限为<code>0777</code>，由于我的umask为<code>002</code>，所以最终创建出的文件夹权限为<code>775</code>。需要注意的是，必须为文件夹设置可执行权限，才能进入文件夹内进行读写操作。</p><h4 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h4><p>与<code>mkdir</code>对应，<code>rmdir</code>系统调用会将目录从文件系统中删除</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202205756.png" alt=""></p><p>调用成功时，<code>rmdir</code>会从文件系统中删除<code>pathname</code>，并返回0。前提是<code>pathname</code>指向的目录必须为空，除了<code>.</code>和<code>..</code>目录以外。没有支持类似<code>rm -r</code>一样递归删除功能的系统调用。要实现<code>rm -r</code>功能，首先要执行文件系统的深度优先搜索，从叶节点开始删除所有文件与目录，并返回至<code>pathname</code>所指向的文件夹。当目录内的全部文件被删除时，则可以使用<code>rmdir</code>来删除该目录。下面是一个简单例子，我们将之前创建的<code>a</code>文件夹删除：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = <span class="built_in">rmdir</span>(<span class="string">"./a"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"rmdir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h4><p>读取目录并非由一个函数完成，而是多个函数配合使用。开始读取目录前，首先需要通过<code>opendir</code>打开目录，通过<code>man 3 opendir</code>命令查看此函数文档：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191203090001.png" alt=""></p><p><code>opendir</code>函数通过路径打开目录，<code>name</code>参数为要打开的目录路径，可以是绝对路径，也可以是相对路径。<code>fdopendir</code>函数则是通过文件描述符打开目录。调用成功后，两个函数都将创建指向目录的目录流对象（directory stream object）并返回，该对象的具体结构对用户不可见，我们也不需要过多了解。失败时，返回NULL，并设置相应的errno值。</p><p>通过<code>opendir</code>创建一个目录流后，就可以使用<code>readdir</code>从目录流，也就是<code>DIR</code>对象中依次返回目录项：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191203093612.png" alt=""></p><p>成功调用<code>readdir</code>，会返回<code>dirp</code>指向的下一个目录项。结构体<code>dirent</code>指向目录项，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="keyword">ino_t</span>          d_ino;       <span class="comment">/* Inode number */</span></span><br><span class="line">    <span class="keyword">off_t</span>          d_off;       <span class="comment">/* Not an offset; see below */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;    <span class="comment">/* Length of this record */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  d_type;      <span class="comment">/* Type of file; not supported by all filesystem types */</span></span><br><span class="line">    <span class="keyword">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>连续调用<code>readdir</code>，可获取目录中的每个文件，当整个目录读完时，返回NULL。</p><p>此外，当读取完目录不再使用时，应当通过<code>closedir</code>关闭由<code>opendir</code>打开的目录流：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191203094534.png" alt=""></p><p>调用成功时，会关闭<code>dirp</code>参数指向的目录流对象，包括目录的文件描述符，并返回0。失败时，返回-1，并设置相应的errno值。</p><p>下面通过代码来演示如何读取<code>/</code>下的目录项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    dir = opendir(<span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"opendir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"inode:%10ld    name:%20s\n"</span>, entry-&gt;d_ino, entry-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inode:        13    name:                 bin</span><br><span class="line">inode:        15    name:               lib32</span><br><span class="line">inode:   1966081    name:                 tmp</span><br><span class="line">inode:        22    name:         vmlinuz.old</span><br><span class="line">inode:        23    name:             vmlinuz</span><br><span class="line">inode:   1572865    name:               media</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>由此，目录操作就讲到这里。实际应用中会出现更多复杂情况，但核心系统调用及库函数的使用基本如上，不会有太多出入。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇主要讲解两大内容，一是文件，二是目录。文件其实是用<code>inode节点</code>来描述，通过链接进行索引。而目录则保存了目录项，也就是文件的链接。此外通过文件还引出了权限的查看与设置操作，以及文件的删除、拷贝、移动、重命名等。最后又讲解了一系列日常开发中很常用的目录操作函数，文中演示的代码很简单，详细需要用户考虑到自身应用场景，编写代码加以练习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前讨论过大量关于文件I/O的系统调用，现在我们的视角从文件内部回到文件本身。在Linux中一切皆为文件，而文件包含大量的元数据。诸如：类型、权限、硬链接、软连接、所属用户、所属组、最后访问时间、最后修改时间、最后状态改变时间等。本篇主要讲解文件这些属性的获取与管理。
    
    </summary>
    
    
      <category term="Linux" scheme="https://linxiao.pro/categories/Linux/"/>
    
    
      <category term="C" scheme="https://linxiao.pro/tags/C/"/>
    
      <category term="系统编程" scheme="https://linxiao.pro/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux系统编程-文件I/O基础</title>
    <link href="https://linxiao.pro/2019/11/29/linux-programming-basic-io/"/>
    <id>https://linxiao.pro/2019/11/29/linux-programming-basic-io/</id>
    <published>2019-11-28T18:29:39.000Z</published>
    <updated>2019-11-28T10:29:39.952Z</updated>
    
    <content type="html"><![CDATA[<p>当C语言标准库已经提供了标准IO操作相关的一系列函数，为什么我们还需要学习系统IO呢？相信不少刚开始学习Linux系统编程的同学一定有这样的疑问。我们不妨站在一个较高的层次来看这个问题，比方说操作系统用户和编程语言使用者的角度。<a id="more"></a>显而易见，除了C语言，类似C++、Java、Python这样的高级语言都有IO操作，那么他们的IO操作是通过什么来实现呢？显然，需要更底层源于操作系统内核的支持。这也就是为什么我们需要学习系统IO。因为它处于内核，位于更低的层面来提供基础IO支持，当你学会系统IO后，对于很多用户空间上的IO操作，或是行业领域内更复杂的应用场景都将得心应手。</p><h3 id="基本读写"><a href="#基本读写" class="headerlink" title="基本读写"></a>基本读写</h3><p>来看一个基本读写的例子，我们往文件<code>demo.txt</code>中写入字符串hello world！然后再将此字符串从文件中读出，打印到终端上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"demo.txt"</span>, O_RDWR|O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"hello world!"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> read_count = <span class="built_in">read</span>(fd, buf, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (read_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buf[read_count] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码以及注释可以看出文件读写的基本流程，大概分为4步：打开、写入、读取、关闭。看不懂不要紧，只需要有个基本印象即可。在接下来的几个小节当中，我将对每个步骤进行深入讲解，并且围绕讲解过程中提及的知识点进行一些进阶扩展。</p><h3 id="open打开文件"><a href="#open打开文件" class="headerlink" title="open打开文件"></a>open打开文件</h3><p>首先来看看打开操作，因为open是一个系统调用，所以在查看man手册时需要使用<code>man 2 open</code>命令。</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191127142436.png" alt=""></p><p>引入文档所述三个头文件后我们便可在代码中使用open打开<code>pathname</code>路径下的文件，并且设置一些<code>flags</code>参数进行操作。而<code>mode</code>则表示该文件的权限设置，通常只在创建文件时用得到。在open系统调用下方还有一个creat系统调用，用于创建文件。没错，你即可以用open来创建文件，也可以用creat来创建文件。打开或创建文件成功后，会返回一个指向该文件的文件描述符。</p><h4 id="flags-访问模式"><a href="#flags-访问模式" class="headerlink" title="flags 访问模式"></a>flags 访问模式</h4><p><code>pathname</code>十分容易理解，即需要打开的文件路径字符串指针。而flags你可以先简单的理解成文件的打开方式，不同的打开方式会导致不同的结果发生，若选择了错误的打开方式，轻则无法访问，重则覆盖掉文件内容。大家一定要小心！flags参数通过一个或多个标志位的按位或组合而成，它支持三种访问模式：<code>O_RDONLY</code> <code>O_WRONLY</code> <code>O_RDWR</code> ，分别表示只读、只写、可读可写。来举几个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd1 = <span class="built_in">open</span>(<span class="string">"a.txt"</span>, O_RDONLY);          <span class="comment">// 只读</span></span><br><span class="line"><span class="keyword">int</span> fd2 = <span class="built_in">open</span>(<span class="string">"b.txt"</span>, O_WRONLY);          <span class="comment">// 只写</span></span><br><span class="line"><span class="keyword">int</span> fd3 = <span class="built_in">open</span>(<span class="string">"d.txt"</span>, O_RDWR);            <span class="comment">// 可读可写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记得每次打开后需要判断文件描述符是否等于-1</span></span><br><span class="line"><span class="comment">// 如果等于-1,则说明打开失败,此处仅判断一个以演示</span></span><br><span class="line"><span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"open"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能对以只读模式打开的文件执行写操作，反之亦然。进程必须有足够的权限才能调用系统调用来打开文件。举个例子，假设用户对某个文件只有只读权限，该用户的进程只能以<code>O_RDONLY</code>模式打开文件，而不能以<code>O_WRONLY</code>或<code>O_RDWR</code>模式打开。 此外，flags还可以和其他值进行按位或运算，修改打开文件的行为。诸如：<code>O_APPEND</code> <code>O_ASYNC</code> <code>O_CLOEXEC</code> <code>O_CREAT</code> <code>O_DIRECT</code> <code>O_DIRECTORY</code> <code>O_DSYNC</code> <code>O_EXCL</code> <code>O_LARGEFILE</code> <code>O_NOATIME</code> <code>O_NOCTTY</code> <code>O_NOFOLLOW</code> <code>O_NONBLOCK</code> <code>O_NDELAY</code> <code>O_PATH</code> <code>O_SYNC</code> <code>O_TEMPFILE</code> <code>O_TRUNC</code>。详细信息，可以翻阅man手册。因为篇幅有限，无法一次性将这些flags讲解完，后续根据使用场景边用边讲。</p><h4 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h4><p>open系统调用除了能打开文件，也可根据指定的路径来新建文件。先来看看新建文件相关的两个flags：</p><ul><li>O_CREAT    当参数<code>pathname</code>指定的文件不存在时，内核自动创建。如果文件已存在，除非指定了标志位<code>O_EXCL</code>，否则该标志位无效。</li><li>O_EXCL     当和标志位<code>O_CREAT</code>一起使用时，如果参数<code>pathname</code>指定的文件已经存在，会导致open()调用失败。用于防止创建文件时出现竞争。如果没有和标志位<code>O_CREAT</code>一起使用，该标志位就没有任何含义。</li></ul><p>来写一个例子进行演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1, fd2;</span><br><span class="line">    <span class="comment">// 用新建模式打开不存在的文件test.txt</span></span><br><span class="line">    fd1 = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件创建成功！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若上面的代码创建test.txt成功，那么此时便会打开一个已存在的文件</span></span><br><span class="line">    fd2 = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT|O_EXCL);</span><br><span class="line">    <span class="keyword">if</span> (fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件创建成功!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="built_in">close</span>(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件创建成功！</span><br><span class="line">文件创建失败: File exists</span><br></pre></td></tr></table></figure><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p>除非新建文件，否则open系统调用会忽略mode参数。上面的示例使用了<code>O_CREAT</code>参数，却没有给出<code>mode</code>参数。 这通常会导致未定义的结果，并且很糟糕，如：创建的文件没有权限正常读写！我们来重新编写新建文件的代码，并加上<code>mode</code>参数。在重写之前，先要来了解一下<code>mode</code>参数的编写规则。实际上<code>mode</code>是常见的UNIX权限位集合，比如八进制数0644（文件所有者可以读写，其他人只能读）。通过翻阅<code>open</code>系统调用的手册，我们可以找到一组宏，每个宏通过按位或的方式来组合出权限集合，提供给<code>mode</code>参数。</p><table><thead><tr><th>S_IRWXU</th><th>00700</th><th>文件所有者有读、写和执行的权限</th></tr></thead><tbody><tr><td>S_IRUSR</td><td>00400</td><td>文件所有者有读权限</td></tr><tr><td>S_IWUSR</td><td>00200</td><td>文件所有者有写权限</td></tr><tr><td>S_IXUSR</td><td>00100</td><td>文件所有者有执行权限</td></tr><tr><td>S_IRWXG</td><td>00070</td><td>组用户有读、写和执行权限</td></tr><tr><td>S_IRGRP</td><td>00040</td><td>组用户有读权限</td></tr><tr><td>S_IWGRP</td><td>00020</td><td>组用户有写权限</td></tr><tr><td>S_IXGRP</td><td>00010</td><td>组用户有执行权限</td></tr><tr><td>S_IRWXO</td><td>00007</td><td>任何人都有读、写和执行的权限</td></tr><tr><td>S_IROTH</td><td>00004</td><td>任何人都有读权限</td></tr><tr><td>S_IWOTH</td><td>00002</td><td>任何人都有写权限</td></tr><tr><td>S_IXOTH</td><td>00001</td><td>任何人都有执行权限</td></tr></tbody></table><p>好，既然知道了<code>mode</code>参数的编写规则，那么来重写下新建文件的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT, S_IWUSR|S_IRUSR|S_IWGRP|S_IRGRP|S_IWOTH|S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件创建成功\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    oclose(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ ./a.out </span><br><span class="line">文件创建成功</span><br><span class="line">➜ ls -l test.txt </span><br><span class="line">-rw-r--r-- 1 noir noir 0 11月 27 01:11 test.txt</span><br></pre></td></tr></table></figure><p>实际运用中，用一组宏按位与组合成权限集合还是有点繁琐。因此<code>mode</code>参数可直接使用八进制数来表示，<code>S_IWUSR|S_IRUSR|S_IWGRP|S_IRGRP|S_IWOTH|S_IROTH</code> 这一组合等同于八进制数0666，千万别忘了写0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br></pre></td></tr></table></figure><p>虽然上面的代码成功创建了文件，也增加了权限<code>mode</code>参数，那为什么实际文件权限却是<code>-rw-r--r--</code>，也就是644呢？因为最终写入磁盘的权限位是由<code>mode</code>参数和用户的文件创建掩码（umask）执行按位与操作而得到的。在系统调用open()中，umask位要和参数<code>mode</code>取反。因此umask 022和mode参数0666取反后，结果是0644。通过Linux命令<code>umask 002</code>可以变更掩码位，也可在代码中调用<code>umask</code>系统调用来执行此操作。先看看文档：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191127175029.png" alt=""></p><p>然后我们尝试在创建文件前修改umask值，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umask(<span class="number">002</span>);</span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br></pre></td></tr></table></figure><p>程序执行完后，创建的新文件<code>test.txt</code>权限应该是0664。</p><h4 id="creat函数"><a href="#creat函数" class="headerlink" title="creat函数"></a>creat函数</h4><p>实际上，创建文件的操作十分常见，除了<code>open</code>，系统还为我们提供了<code>creat</code>函数专门用于文件创建。示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = creat(<span class="string">"test.txt"</span>, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码等同于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处引入了一个新的flags<code>O_TRUNC</code>：</p><ul><li>O_TRUNC    如果文件存在，并且有写权限，该标志位会把文件长度截断为0</li></ul><p>所以结合起来看，上面这段代码的含义是：创建新的文件<code>test.txt</code>，如果文件已存在，则清空内容。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>当<code>open</code>系统调用成功打开文件，会返回一个非负的整数数值，这个数值便称作文件描述符。 我们来打印一下该数值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1, fd2, fd3;</span><br><span class="line">    fd1 = <span class="built_in">open</span>(<span class="string">"test1.txt"</span>, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    fd2 = <span class="built_in">open</span>(<span class="string">"test2.txt"</span>, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    fd3 = <span class="built_in">open</span>(<span class="string">"test3.txt"</span>, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span> || fd2 == <span class="number">-1</span> || fd3 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fd1:%d fd2:%d fd3:%d\n"</span>, fd1, fd2, fd3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="built_in">close</span>(fd2);</span><br><span class="line">    <span class="built_in">close</span>(fd3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd1:3 fd2:4 fd3:5</span><br></pre></td></tr></table></figure><p>明明我们写的代码之前没有打开过任何文件，而文件描述符却是从3开始计数。这是因为当系统开启一个新进程的时候，内核会为每一个进程维护一张文件表，而这张表中会保存我们的文件描述符、文件<code>inode</code>节点以及读取位置指针等信息。并且，当进程创建的时候还将自动开启三个文件描述符：0、1和2。文件描述符0表示标准输入（stdin），1表示标准输出（stdout），2表示标准错误（stderr）。这就是为何我们在自己的代码中没有打开任何输入输出相关的文件，却能用<code>scanf</code>接收键盘输入，用<code>printf</code>打印到终端，用<code>perror</code>打印错误。现在，我们试着关闭这3个文件描述符，看看上述的三个函数是否还能正确执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">"file_not_exist.txt"</span>, O_WRONLY|O_TRUNC);</span><br><span class="line">    perror(<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，没有结果，上面三个函数均无法正常执行。</p><p>此外，Linux C标准库提供了三个宏来表示这3个整数，分别为<code>STDIN_FILENO</code> <code>STDOUT_FILENO</code> <code>STDERR_FILENO</code>，导入头文件<code>unistd.h</code>后即可使用。当<code>open</code>系统调用返回了正确的文件描述符，后面的读写等一系列函数就可使用此文件描述符作为参数，以进行更多文件操作。</p><h3 id="write写入文件"><a href="#write写入文件" class="headerlink" title="write写入文件"></a>write写入文件</h3><p>写文件使用<code>write</code>系统调用，先来看看其原型：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191127205248.png" alt=""></p><p><code>write</code>调用会从文件描述符<code>fd</code>指向的文件的当前位置开始，将<code>buf</code>中至多<code>count</code>个字节写入到文件中。<code>write</code>执行成功时，会返回写入的字节数，并更新文件位置。出错时，返回-1，并设置<code>errno</code>值。通常意义上，我们有文本文件写入和二进制文件写入。但这只是从用户的角度出发，对于操作系统来说，其实保存的都是二进制数据。只不过我们常用的文本编辑器帮我们将文本的二进制数据解析了出来，以便于阅读。而二进制文件格式各不相同，需要不同的程序来解析。诸如音乐播放器和电影播放器，就是很典型的例子。</p><h4 id="文本写入"><a href="#文本写入" class="headerlink" title="文本写入"></a>文本写入</h4><p>我们先来测试一下文本写入，将<code>hello world!</code>这条字符串写入到<code>str.txt</code>文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"str.txt"</span>, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="string">"hello world!"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功后，打开<code>str.txt</code>文件，发现字符串<code>hello world!</code>已经成功写入。</p><h4 id="二进制数据写入"><a href="#二进制数据写入" class="headerlink" title="二进制数据写入"></a>二进制数据写入</h4><p>再来看看二进制文件写入，将自定义的<code>struct Stu</code>结构体写入到<code>data</code>文件中。其实和上面的调用方式并无二致，仅仅是写入的数据变了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"data"</span>, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s.name, <span class="string">"Alan"</span>);</span><br><span class="line">    s.age = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, &amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功后，用文本编辑器打开<code>data</code>文件，发现乱码一串，什么鬼。因为我们没有合适的程序去读取其内容，所以你需要自己编写代码去读取。这也就是Java等高级语言中所谓的对象序列化技术。通过<code>od</code>命令来查看此文件，其实还是能看出点端倪的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  od -c data</span><br><span class="line">0000000   A   l   a   n  \0  \0  \0  \0 325 222   R 034   t   U  \0  \0</span><br><span class="line">0000020     213   U   %  \f  \0  \0  \0</span><br><span class="line">0000030</span><br></pre></td></tr></table></figure><h4 id="append-追加"><a href="#append-追加" class="headerlink" title="append 追加"></a>append 追加</h4><p>通常情况下除了创建新文件从头写入，在现有内容上进行追加的需求也不少见。我们需要在<code>open</code>系统调用的<code>flag</code>参数中加入一个新的标志位：<code>O_APPEND</code>，用来改变文件的访问模式为追加，先来看看定义</p><ul><li>O_APPEND    文件将以追加模式打开。也就是说，在每次写入操作之前，将会更新文件位置指针，指向文件末尾。即使有另一个进程也在向该文件写数据，以追加模式打开的进程在最后一次写操作时，还是会更新文件位置指针，指向文件末尾</li></ul><p>写个简单例子，我们先手动创建一个文件<code>append.txt</code>，并往其中写入文本<code>abc</code>，接着再通过代码向其追加文本<code>xyz</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "abc" &gt; append.txt</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"append.txt"</span>, O_WRONLY|O_APPEND);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"xyz"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功后，打开文件<code>append.txt</code>，发现其中有两行文本，分别是<code>abc</code>和<code>xyz</code>，为什么不是一行呢？因为前面用到的<code>echo</code>命令会自动换行。</p><h5 id="共享文件操作"><a href="#共享文件操作" class="headerlink" title="共享文件操作"></a>共享文件操作</h5><p>这里针对<code>O_APPEND</code>标志位进行一下扩展。假设在多个进程中需要对同一个文件进行写入操作，那么两个进程写入的顺序是怎样的？举个例子，现有文件<code>share.txt</code>，一个进程只对其写入<code>aaa</code>，另一个进程只对其写入<code>bbb</code>，那么执行数次后，文本所展示的内容是什么样子？两个进程都有自己的文件描述符，却又指向同一个文件，因此我们可以猜想出两种结果：</p><ul><li>交替写，结果为<code>aaabbbaaabbb</code>，即一个进程写完后更新文件节点位置指针到末尾，然后另一个进程从末尾开始写</li><li>覆盖写，结果为<code>bbbbbbbbbbbb</code>，即一个进程写完后不更新文件节点位置指针，然后另一个进程从自己的原始位置开始写，并覆盖上一个进程所写入的数据，比如A进程先写了<code>aaa</code>，然而B进程此时的文件位置指针还在<code>aaa</code>开头，而非结尾，所以写入<code>bbb</code>后，会将<code>aaa</code>覆盖</li></ul><p>那么实际写入效果如何，我们可以用代码来验证一下。由于尚未了解多进程相关知识，我们两次打开同一文件来模拟此行为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1,fd2;</span><br><span class="line">    fd1 = <span class="built_in">open</span>(<span class="string">"share.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    fd2 = <span class="built_in">open</span>(<span class="string">"share.txt"</span>, O_WRONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span> || fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count++ &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(fd1, <span class="string">"aaa"</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">write</span>(fd2, <span class="string">"bbb"</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line"><span class="built_in">close</span>(fd2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完成，打开<code>share.txt</code>文件，可以看到文本内容<code>bbbbbbbbbbbb</code>，也就是说共享文件写入时是覆盖写。如果想让它变成交替写，则需要在<code>open</code>系统调用中加上<code>O_APPEND</code>标志位。其余代码不变，我们将打开文件的两行代码进行修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd1 = <span class="built_in">open</span>(<span class="string">"share.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC|O_APPEND, <span class="number">0666</span>);</span><br><span class="line">fd2 = <span class="built_in">open</span>(<span class="string">"share.txt"</span>, O_WRONLY|O_APPEND);</span><br></pre></td></tr></table></figure><p>重新编译执行，再次打开<code>share.txt</code>文件，内容已变成<code>aaabbbaaabbbaaabbbaaabbb</code>。</p><h3 id="read读取文件"><a href="#read读取文件" class="headerlink" title="read读取文件"></a>read读取文件</h3><p>前面讨论了打开和写入文件操作，接下来谈谈文件读取。先看看原型：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128103049.png" alt=""></p><p>每次调用<code>read</code>，会从<code>fd</code>指向的文件的当前偏移开始读取<code>count</code>字节到<code>buf</code>所指向的内存中。执行成功时，返回写入<code>buf</code>中的字节数。出错时，返回-1，并设置<code>errno</code>值。<code>fd</code>的文件位置指针会向前移动，移动的长度由读取到的字节数决定。</p><p>前面我们在文本写入和二进制数据写入两小节中分别产生了两个文件<code>str.txt</code>和<code>data</code>，现在我们尝试用<code>read</code>把其中的内容读出来，并打印到终端上。</p><h4 id="文本读取"><a href="#文本读取" class="headerlink" title="文本读取"></a>文本读取</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"str.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// 读之前先清空buf数据</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">read</span>(fd, buf, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功，会输出<code>hello world!</code>，可以看到文本读取非常简单。</p><h4 id="二进制数据读取"><a href="#二进制数据读取" class="headerlink" title="二进制数据读取"></a>二进制数据读取</h4><p>现在来看看二进制文件读取，我们使用上述写入的<code>data</code>文件来进行测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"data"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="built_in">read</span>(fd, &amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, s.name, s.age);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功，会输出获取的结构体数据<code>Alan:12</code>。</p><h4 id="read返回值"><a href="#read返回值" class="headerlink" title="read返回值"></a>read返回值</h4><p>前面两段读取代码有个特点，即都是以知道<code>buf</code>缓冲区大小为前提来进行读取。比如第一段文本读取代码中，很明显我们知道要读取的字符串大小要小于100字节，所以创建了100字节的缓冲区。而第二段二进制数据读取代码中，可以很轻易通过<code>sizeof</code>运算符来得到<code>struct Stu</code>的大小。那如果并不知道要读取的文件大小是多少，缓冲区应该如何创建？通常情况下缓冲区不宜设置太小，因为读取的块太小，就会导致读取次数增加，造成效率低下。当然，也不能过大，这样会造成内存空间浪费或内存溢出。当设定好合适的缓冲区大小后，可以使用循环来读取内容。使用循环读取前，要先了解<code>read</code>系统调用的返回值，事实上调用<code>read</code>有很多种可能的返回结果，我们列出常见的几种，其余需要的时候再讲解：</p><ul><li>调用返回值等于<code>count</code>。读取到的所有<code>count</code>个字节都被存储在<code>buf</code>中。结果和预期一致。</li><li>调用返回值小于<code>count</code>，大于0。读取到的字节被存储到<code>buf</code>中。这种情况有很多原因，比如在读取过程中信号中断或在读取中出错，可读的数据大于0字节小于<code>count</code>字节，在读取<code>count</code>字节之前到达EOF。</li><li>调用返回0，表示EOF，没有更多可读的数据。</li></ul><p>了解完<code>read</code>的返回值后，我们摘录一段小王子的文本保存到文件<code>prince.txt</code>中，然后尝试循环读取到<code>buf</code>缓冲区中，并将其输出到终端，文本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.And now here is my secret, a very simple secret. It is only with the heart that one can see rightly; what is essential is invisible to the eyes.</span><br><span class="line"></span><br><span class="line">2.If you come at four o&apos;clock in the afternoon, then at three o&apos;clock I shall begin to be happy. I shall feel happier and happier as the hour advances. At four o&apos;clock, I shall already be worrying and jumping about. I shall show you how happy I am! But if you come at just any time, I shall never know at what hour my heart is to be ready to greet you…</span><br><span class="line"></span><br><span class="line">3.If someone loves a flower, of which just one single blossom grows in all the millions and millions of stars, it is enough to make him happy just to look at the stars.He can say to himself, &quot;Somewhere, my flower is there…&quot; But if the sheep eats the flower, in one moment all his stars will be darkened… And you think that is not important!</span><br><span class="line"></span><br><span class="line">4.If we do not go through the world, we do not know what is our spiritual and emotional sustenance, but once we go through the world, we find that we can no longer go back to that wonderful place to go. When we begin to seek, we have lost, and we are not seeking, we cannot know what is so precious to us.</span><br><span class="line"></span><br><span class="line">5.Only the children know what they are looking for. They waste their time over a rag doll and it becomes very important to them; and if anybody takes it away from them, they cry…</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"prince.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = <span class="built_in">read</span>(fd, buf, <span class="number">99</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们每次读取99字节，并且将最后1字节设置为<code>\0</code>，以表示这是一条字符串，方便<code>printf</code>函数打印。当读取到文件末尾，<code>len</code>会等于0，并结束循环。如无意外，执行成功后会输出上文文本。</p><h3 id="lseek查找"><a href="#lseek查找" class="headerlink" title="lseek查找"></a>lseek查找</h3><p>有些同学可能在执行完<code>write</code>操作后立马使用<code>read</code>来读数据，然而此时无法正确读取，这是因为文件描述符的位置指针已经移动到了数据末尾，如果是从头写入的数据，那么我们可以用如下代码将位置指针回移，然后再进行读操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *buf = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">lseek(fd, (<span class="keyword">off_t</span>)<span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">read</span>(fd, buf, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>当然<code>lseek</code>的用法并不仅限如此，我们先看看文档，再讲述其详细用法：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128123908.png" alt=""></p><p><code>lseek</code>系统调用能够将文件描述符的位置指针修改成指定值，它的行为依赖于<code>whence</code>参数，该参数可以是以下任意值之一</p><ul><li>SEEK_CUR    将文件位置设置成当前值再加上<code>offset</code>个偏移值，<code>offset</code>可以是负值、0或正值。如果<code>offset</code>值为0，返回当前文件位置值。</li><li>SEEK_END    将文件位置设置成文件长度再加上<code>offset</code>个偏移值，<code>offset</code>可以是负值、0或正值。如果<code>offset</code>值为0，就设置成文件末尾</li><li>SEEK_SET    将文件位置设置成<code>offset</code>值。如果<code>offset</code>值为0，就设置成文件开始。</li></ul><p>调用成功时返回新的文件位置，错误时返回-1，并设置相应<code>errno</code>值。</p><p>举个例子，以下代码把<code>fd</code>的文件位置指针设置为200：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> ret;</span><br><span class="line">ret = lseek(fd, (<span class="keyword">off_t</span>)<span class="number">200</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"lseek"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是把<code>fd</code>的文件位置设置成文件末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> ret;</span><br><span class="line">ret = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"lseek"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>lseek</code>返回更新后的文件位置，可以通过<code>SEEK_CUR</code>，把偏移<code>offset</code>设置成0，确定当前文件位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line">pos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"lseek"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稀疏文件"><a href="#稀疏文件" class="headerlink" title="稀疏文件"></a>稀疏文件</h3><p><code>lseek</code>也可将文件位置指针移动到文件末尾之后，比如以下代码会定位到<code>fd</code>指向文件末尾之后的1024*1024字节(1M) ，然后紧接着写入文本<code>end</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = lseek(fd, <span class="number">1024</span>*<span class="number">1024</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"lseek"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"end"</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>end</code>之前这段区间会用0来填充，称之为<code>空洞（hole）</code>。在UNIX系文件系统上，空洞不占用任何物理磁盘空间。包含空洞的文件称为<code>稀疏文件</code>。上面代码执行成功后，通过<code>ls -lh</code>命令查看，显示文件大小约为1M。而通过<code>du -h</code>命令查看物理空间大小，则显示为4k。这里的4k是因为最后写入的<code>end</code>，虽然<code>end</code>只占3字节，但由于Linux系统最小写入的块就是4k，所以文件物理大小为4k。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ls -l test.txt                 </span><br><span class="line">-rw-rw-r-- 1 noir noir 1003 11月 29 00:15 test.txt</span><br><span class="line">➜  du -h test.txt </span><br><span class="line">4.0k      test.txt</span><br></pre></td></tr></table></figure><p>为何需要空洞，打个比方，假如我们现在需要进行多线程下载，那么每条线程就必须通过<code>lseek</code>移动到不同位置创造出空洞，然后再通过<code>write</code>向空洞部分写入数据。最后所有部分的空洞都被填充，则完成整体文件下载。制造空洞不会产生任何物理I/O，对文件空洞部分的读请求则会返回相应的二进制0。</p><h3 id="截短文件"><a href="#截短文件" class="headerlink" title="截短文件"></a>截短文件</h3><p>通过使用<code>lseek</code>可以制造空洞，但这并非唯一做法，还有另一种方式就是使用<code>truncate</code>系统调用。先看看文档：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191129165547.png" alt=""></p><p><code>truncate</code>系统调用可以截短一个文件，<code>path</code>参数用于指定需截短的文件路径，<code>length</code>参数用于指定需截短的目标长度。而<code>ftruncate</code>与<code>truncate</code>不同的地方仅在于前者使用参数<code>fd</code>来指定需截短的文件，而非路径。当需要截短的长度实际大于文件本身长度时，便会造成空洞。我们使用<code>ftruncate</code>来改写上面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = ftruncate(fd, <span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"truncate"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功后，便创建了一个有1M大小空洞的稀疏文件。</p><p>上面的例子是截短的长度比文件原长度还要大，然而常规用法更多的是要截短的目标长度小于文件的原有长度。举个例子，我们现在有一个文本文件<code>test.txt</code>，里面包含一串字符串：<code>hello world</code>，现在我们使用<code>truncate</code>系统调用来截短6个字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = truncate(<span class="string">"test.txt"</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"truncate"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完成，再次打开<code>test.txt</code>文件，其中内容已经截短为<code>hello</code>。</p><h3 id="close关闭文件"><a href="#close关闭文件" class="headerlink" title="close关闭文件"></a>close关闭文件</h3><p>接下来说说<code>close</code>系统调用。其实上面的代码中一直有用到，只是没有详细说明，先看看函数原型：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128134727.png" alt=""></p><p>当程序完成对某个文件的操作后，系统调用<code>close</code>会取消当前进程的文件描述符<code>fd</code>与其关联的文件之间的映射。调用后，先前给定的文件描述符<code>fd</code>不再有效，内核可以随时重用它，当后续有<code>open</code>调用或<code>creat</code>调用时，重新把它作为返回值。举个例子，假如我们我们关闭了文件描述符0，那么接下来的<code>open</code>调用便会打开一个新文件，并且此文件的文件描述符为0。</p><h3 id="dup复制文件描述符"><a href="#dup复制文件描述符" class="headerlink" title="dup复制文件描述符"></a>dup复制文件描述符</h3><p><code>dup</code>系统调用用于复制文件描述符，先来看文档：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128141513.png" alt=""></p><p><code>oldfd</code>表示原始文件描述符，<code>dup</code>系统调用会根据原始文件描述符复制一个新的文件描述符并返回，而这个新的文件描述符是从系统可用的最小文件描述符开始计数。如：当前已打开3，则下一个文件描述符应为4。而<code>dup2</code>系统调用除了复制文件描述符外，还可通过<code>newfd</code>来指定新文件描述符的数值。倘若<code>newfd</code>已经被使用，则<code>dup2</code>会将其关闭再给自己使用。上述两个系统调用执行成功会返回新的文件描述符，而一旦失败，则返回-1，并设置相应的<code>errno</code>。</p><p>下面我们复制一个文件描述符，并同时使用两个文件描述符向同一文件写入文本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"dup.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> new_fd;</span><br><span class="line">    new_fd = dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本行代码与上一行等价</span></span><br><span class="line">    <span class="comment">// new_fd = dup2(fd, 4);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"dup"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">"world"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, str1, <span class="built_in">strlen</span>(str1));</span><br><span class="line">    <span class="built_in">write</span>(new_fd, str2, <span class="built_in">strlen</span>(str2));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功后打开文件<code>dup.txt</code>，发现写入文本内容<code>helloworld</code>，也就是说通过<code>new_fd</code>写入的文本并没有覆盖<code>fd</code>写入的文本。这主要是因为<code>dup</code>复制出的文件描述符和原文件描述符使用的是同一文件位置偏移量。</p><h4 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h4><p><code>dup dup2</code>系统调用除了能复制文件描述符，还能实现重定向操作。先来看看什么是重定向：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  echo "hello"               # 直接输出到屏幕上</span><br><span class="line">hello</span><br><span class="line">➜  echo "hello" &gt; hello.txt   # 重定向到文件中</span><br><span class="line">➜  cat &lt; hello.txt            # 从文件重定向到命令里</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>如果经常使用Linux，对重定向应该不会陌生，下面我们来使用<code>dup dup2</code>来实现一个将原本输出到终端重定向至文件的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">    <span class="keyword">int</span> new_fd;</span><br><span class="line">    new_fd = dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本行代码与上一行等价,并且不需要提前关闭文件描述符1</span></span><br><span class="line">    <span class="comment">// new_fd = dup2(fd, STDOUT_FILENO);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"dup"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"hello world!"</span>;</span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看出标准输出重定向操作主要分了三步：</p><ul><li>关闭标准输出文件描述符</li><li>复制文件描述符<code>fd</code>，此时会分配新的文件描述符1，并与<code>fd</code>所指向的文件绑定</li><li>向标准输出写入数据，此时数据会写入到<code>fd</code>所指向的文件中</li></ul><p>如果我们把下面这一行去掉，那么很明显，它会继续向标准输出打印，而不是输出到文件中，所以<code>close</code>是重定向中至关重要的一环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(STDOUT_FILENO);</span><br></pre></td></tr></table></figure><p>而<code>dup2</code>则更加简单，它可以不必提前关闭<code>STDOUT_FILENO</code>，当指定新的文件描述符为<code>STDOUT_FILENO</code>的时候，它会自动关闭，并将其与<code>fd</code>所指文件进行绑定。</p><h3 id="fcntl操作文件描述符"><a href="#fcntl操作文件描述符" class="headerlink" title="fcntl操作文件描述符"></a>fcntl操作文件描述符</h3><p><code>fcntl</code>主要作用是用来操作文件描述符，我们先看文档</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128172640.png" alt=""></p><p><code>fd</code>参数与上面所有的系统调用一样，指打开的文件描述符，而<code>cmd</code>则是控制命令，代表我们要针对此文件描述符进行的操作。由于命令较多，此处讲解两个以演示用法。</p><h4 id="模拟dup-dup2操作"><a href="#模拟dup-dup2操作" class="headerlink" title="模拟dup dup2操作"></a>模拟dup dup2操作</h4><p>除了使用<code>dup dup2</code>来复制文件描述符，通过<code>fcntl</code>也能做到，只是这种做法不常见而已。下面我们通过代码来演示如何操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> new_fd;</span><br><span class="line">    new_fd = fcntl(fd, F_DUPFD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"dup"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"hello"</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">write</span>(new_fd, <span class="string">"world"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完成，会成功往<code>test.txt</code>中写入<code>helloworld</code>，从上面的<code>fcntl</code>用法中我们发现了一个命令参数<code>F_DUPFD</code></p><ul><li>F_DUPFD    复制文件描述符，可用来模拟dup和dup2</li></ul><p>下面我们再演示一段模拟<code>dup2</code>重定向标准输出的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line"><span class="keyword">int</span> new_fd;</span><br><span class="line">new_fd = fcntl(fd, F_DUPFD, STDOUT_FILENO);</span><br></pre></td></tr></table></figure><p>这里需要注意的是，<code>dup2</code>设定文件描述符值之后，若此值已被使用则会先关闭，而<code>F_DUPFD</code>则不会，需要我们手动关闭，然后再设置新的文件描述符。</p><h4 id="设置文件访问模式"><a href="#设置文件访问模式" class="headerlink" title="设置文件访问模式"></a>设置文件访问模式</h4><p>由于实际开发中，很多时候我们获取到的文件描述符也许并非我们自行打开文件所得，而是由别的api返回。此时我们并不知道文件描述符的状态，也不知道是否具备我们需要的访问模式。这时也就引入了两个新的命令：</p><ul><li>F_GETFL    获取文件访问标志</li><li>F_SETFL    设置文件访问标志</li></ul><p>现在假设有一个文件描述符以可写模式打开，而我们想追加内容，来看看通过<code>fcntl</code>应该如何操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">// 获取原始文件描述符访问标志</span></span><br><span class="line">    flags = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="comment">// 在原有文件访问标志之上补充新的访问标志</span></span><br><span class="line">    flags = flags|O_APPEND;</span><br><span class="line">    <span class="comment">// 为文件描述符设定新的文件访问标志</span></span><br><span class="line">    fcntl(fd, F_SETFL, flags);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"hello"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功可以很清晰看到<code>test.txt</code>中的文本并未被覆盖，而是以追加的形式写入。通过上面的代码我们也看出了设置文件描述符标志的基本套路：</p><ul><li>获取原始文件描述符访问标志</li><li>在原有文件访问标志之上补充新的访问标志</li><li>为文件描述符设定新的文件访问标志</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的内容有点多，先是简要说明了文件读写的基本流程，然后针对文件打开、写入、读取进行了详细讲解。在文件读写过程中我们还需要注意文件共享写入、追加、lseek、空洞、关闭等小细节。最后又介绍了dup实现的文件共享以及重定向，还有fcntl操作文件描述符的简要方法。归根到底，其实文件I/O的基础操作并不难，也好理解，最重要的是一定要多看文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当C语言标准库已经提供了标准IO操作相关的一系列函数，为什么我们还需要学习系统IO呢？相信不少刚开始学习Linux系统编程的同学一定有这样的疑问。我们不妨站在一个较高的层次来看这个问题，比方说操作系统用户和编程语言使用者的角度。
    
    </summary>
    
    
      <category term="Linux" scheme="https://linxiao.pro/categories/Linux/"/>
    
    
      <category term="C" scheme="https://linxiao.pro/tags/C/"/>
    
      <category term="系统编程" scheme="https://linxiao.pro/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程-errno详解</title>
    <link href="https://linxiao.pro/2019/11/26/linux-programming-error/"/>
    <id>https://linxiao.pro/2019/11/26/linux-programming-error/</id>
    <published>2019-11-26T14:05:44.000Z</published>
    <updated>2019-11-26T06:05:44.608Z</updated>
    
    <content type="html"><![CDATA[<p>当进行系统编程的时候，知道一个系统调用或库函数的返回结果极其重要。通常情况下，函数执行正确，可以返回需要的结果或无返回。然而，一旦发生错误，除了知道出错以外，我们还需要更详细的错误信息来辅助定位问题并加以修正。在系统编程中，错误是通过函数的返回值和特殊变量errno来描述。<a id="more"></a>用函数返回值来描述错误应该是最常见的手段，比方说-1代表文件打开失败，-2代表参数缺失等等。但很多错误其实都是通用的，如果针对每一个函数用一个错误码来表示，那么不免有些冗余，二来函数的生命周期有限，仅能描述自身，而无法描述整个程序的错误状态。所以我们需要一个全局范围的错误码和对应的错误定义，来帮助我们描述错误。</p><h3 id="errno-变量"><a href="#errno-变量" class="headerlink" title="errno 变量"></a>errno 变量</h3><p>举个例子，当我们使用<code>ls</code>命令来打开一个不存在的目录<code>abc</code>，很明显此时会报错并返回错误信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ls abc</span><br><span class="line">ls: cannot access 'abc': No such file or directory</span><br></pre></td></tr></table></figure><p>但大部分人不知道的是，除了报错，ls命令还为系统设置了一个全局的errno来描述此程序错误。在shell中，我们可以通过查看<code>$?</code>来得到此errno</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ echo $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>可以看到，当前返回的错误码2实际上代表的是<code>No such file or directory</code>。如果我们已经知道了错误码，那么应该如何查看错误码对应的错误信息呢？总是用命令行或程序去试错，然后再记录下来成本有些大。所以此时便需要引入errno命令。</p><h3 id="errno-命令"><a href="#errno-命令" class="headerlink" title="errno 命令"></a>errno 命令</h3><p>没错，errno不仅是个特殊的环境变量，用<code>$?</code>来表示。与此同时，它也是一条Linux系统命令，使用<code>man errno</code>可以查看相关手册。如果你的系统中没有errno命令，那么需要安装<code>moreutils</code>，比如说在Ubuntu中：<code>sudo apt install moreutils</code></p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191126/20191126105824.png" alt=""></p><p>从上图可以看出errno命令的基本用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ errno 2                                     # 查看相应错误宏名称</span><br><span class="line">ENOENT 2 No such file or directory</span><br><span class="line">➜  ~ errno -s file                               # 通过给出的关键词来搜索错误描述</span><br><span class="line">ENOENT 2 No such file or directory</span><br><span class="line">EBADF 9 Bad file descriptor</span><br><span class="line">EEXIST 17 File exists</span><br><span class="line">...</span><br><span class="line">➜  ~ errno -l                                    # 列出所有的错误值</span><br><span class="line">EPERM 1 Operation not permitted</span><br><span class="line">ENOENT 2 No such file or directory</span><br><span class="line">ESRCH 3 No such process</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="error在系统编程中的使用"><a href="#error在系统编程中的使用" class="headerlink" title="error在系统编程中的使用"></a>error在系统编程中的使用</h3><p>上面从命令行角度来讲解了errno的用法，那么如果以开发者的角度来看，errno又该如何使用？可以从手册中找到答案。之前我们查看errno命令是直接使用<code>man errno</code>，但在代码编写中，errno是作为一个库全局变量存在，因此我们需要通过<code>man 3 errno</code>命令来查看相应用法：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191126/20191126111638.png" alt=""></p><p>以上仅截取了部分文档，详细可自行查看。但从文档头部我们得到了两条重要信息，首先errno在代码中表示最后一次函数调用出错的错误码。其次，当使用此值的时候，我们需要引入头文件<code>errno.h</code>。在文档后面，还可以看到一个基本的伪代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A common mistake is to do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (somecall() == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"somecall() failed\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (errno == ...) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，错误发生的时机源于Linux系统调用或库函数调用。<strong>而errno正确的使用方法是：当错误发生，我们需要检查errno对应的值，并且做出相应处理。</strong></p><p>可以试着用代码将这些错误描述打印，来简单实现一下<code>errno -l</code>命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">134</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %s\n"</span>, i, strerror(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0: Success</span><br><span class="line">1: Operation not permitted</span><br><span class="line">2: No such file or directory</span><br><span class="line">3: No such process</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>代码中的strerror函数返回由errno描述的错误信息的字符串指针。其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure><p>我们用上面学到的两个Api来写一个打开文件，并判断是否打开正确的简单例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"abc.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="comment">// 如果open函数返回-1，说明打开文件失败，此时我们将错误原因打印出来</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s:%s\n"</span>, <span class="string">"open"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我当前程序运行的文件夹下并没有abc.txt这一文件， 所以执行结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open:No such file or directory</span><br></pre></td></tr></table></figure><p>如此便可在程序出错时，知道出错的具体原因。</p><p>但既要使用errno又要使用strerror函数，才能输出错误，未免稍显麻烦了点，所以我们可以使用perror函数来简化这一过程。</p><h3 id="perror-函数"><a href="#perror-函数" class="headerlink" title="perror 函数"></a>perror 函数</h3><p>作用：打印系统错误信息</p><p>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure><p>现在我们用perror函数将上面的代码改造一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"abc.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时程序的运行输出已经变成了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure><p>执行结果与上面完全一致。也就是说，perror函数自动帮我们解析了errno这个特殊变量的值，并将值所对应的描述给打印了出来。此外我们还可以对perror传参，加上自己的标记。这会显示在输出开头。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在来小结一下，上面一共讲解了一个特殊的环境变量errno，当执行完程序或命令时，可以用<code>$?</code>来查看其结果。同时它也是一个Linux命令，可用来查看错误描述。而在系统编程中，它则用于保存系统调用或函数执行的错误结果。函数strerror可以解析出errno代码所对应的错误信息，而perror函数则可在系统编程中更好的输出错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当进行系统编程的时候，知道一个系统调用或库函数的返回结果极其重要。通常情况下，函数执行正确，可以返回需要的结果或无返回。然而，一旦发生错误，除了知道出错以外，我们还需要更详细的错误信息来辅助定位问题并加以修正。在系统编程中，错误是通过函数的返回值和特殊变量errno来描述。
    
    </summary>
    
    
      <category term="Linux" scheme="https://linxiao.pro/categories/Linux/"/>
    
    
      <category term="C" scheme="https://linxiao.pro/tags/C/"/>
    
      <category term="系统编程" scheme="https://linxiao.pro/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
