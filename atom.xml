<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Linxiao&#39;s Blog</title>
  
  <subtitle>学习、记录、分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://linxiao.pro/"/>
  <updated>2020-01-21T14:51:16.285Z</updated>
  <id>https://linxiao.pro/</id>
  
  <author>
    <name>Linxiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android架构-MVC、MVP、MVVM演化之路</title>
    <link href="https://linxiao.pro/2020/01/22/Android-architecture-mvc-mvp-mvvm/"/>
    <id>https://linxiao.pro/2020/01/22/Android-architecture-mvc-mvp-mvvm/</id>
    <published>2020-01-21T22:51:16.000Z</published>
    <updated>2020-01-21T14:51:16.285Z</updated>
    
    <content type="html"><![CDATA[<p>大部分人刚开始学习Android的时候，其实并没有用到什么框架结构，只是单纯的在Activity中写业务逻辑，layout中写界面，JavaBean中保存数据实体。尽管官方文档并没有提到任何MVC之类的字眼，但我们仍然信誓旦旦地将这种结构称为MVC。MVC有什么特性、优缺点，以及为何后来我们需要向MVP演化？MVP中的P与MVC中的C又有何异同？MVVM模式能否完全取代之前的框架结构，以及它和databinding到底有何关系，这就是我们下面需要探究的内容。<a id="more"></a></p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><h4 id="标准MVC结构"><a href="#标准MVC结构" class="headerlink" title="标准MVC结构"></a>标准MVC结构</h4><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20200121/20200121112150.png" alt=""></p><p>首先，标准的MVC模式有三个部分：模型（Model）、视图（View）、控制器（Controller）。</p><ul><li>模型（Model）用于封装数据和处理数据的方法</li><li>视图（View）用于对模型中的数据进行展示</li><li>控制器（Controller）用于组织模型和视图、对视图事件作出响应、根据业务逻辑控制程序流程</li></ul><h4 id="MVC在Android中的体现"><a href="#MVC在Android中的体现" class="headerlink" title="MVC在Android中的体现"></a>MVC在Android中的体现</h4><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20200121/20200121122841.png" alt=""></p><p>当应用MVC模式时，在Android中的流程是：</p><ul><li>View接收到用户的操作事件</li><li>View将用户的操作事件交给Controller处理</li><li>Controller完成具体的业务逻辑</li><li>处理完业务逻辑后得到结果，封装Model，再对View进行更新</li></ul><h4 id="五花八门的MVC结构"><a href="#五花八门的MVC结构" class="headerlink" title="五花八门的MVC结构"></a>五花八门的MVC结构</h4><p>但是，除了标准的MVC结构外，我们还经常能在网上找到下列这些结构：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20200121/20200121124457.png" alt=""></p><p>那么上面这些设计对不对呢？答案是：对的。因为Android官方并没有文档明确说明，Android遵循的MVC究竟该如何设计，以及不同开发人员都有各自的理解，因而导致MVC在Android中较为混乱。需要注意的是，上面的箭头方向，表示的不仅是依赖关系，更是MVC中的程序流程。我们就上面四个设计作出解释：</p><ul><li>左上 View的事件会传递给Controller进行处理，而Controller可以根据业务需求直接改变View的状态，不一定非要获取Model中的数据。如：点击View改变颜色，不需要通过Model。</li><li>右上 Controller可以通过Model中的数据刷新View的状态，然而Model也可能因为外界影响导致自身改变，从而影响Controller和View。如：Model观察到系统图库发生变化，通过Controller改变View的展示。</li><li>左下 Model和View属于双向绑定，不仅Model可以刷新View，并且View的状态改变能够影响Model中的数据。如：通过TextWatcher获取View的文本改变更新Model。</li><li>右下 View和Controller、Model同时进行双向绑定，即：除了Model和Controller可更新View外，View的改变也能影响Model中的数据和Controller中的业务逻辑。如：在支付的View中选择了支付方式，一来数据需要改变，二来支付逻辑也需要改变。</li></ul><p>也就是说，无论程序流程如何，只要MVC的这三个部分不发生变化，那么我们便可将以上这些设计都称作为MVC模式。很多时候，设计模式都不是固定不变的，而是在不断演化，根据不同场景和不同开发人员的理解，会做出一些调整。而这些调整和演化并不都是错误。</p><h4 id="MVC结构示例"><a href="#MVC结构示例" class="headerlink" title="MVC结构示例"></a>MVC结构示例</h4><p>下面通过一个例子来展示MVC模式的优缺点，大致类结构如下：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20200121/20200121222136.png" alt=""></p><ul><li>MainActivity 作为主界面，它主要做三件事：点击Button、从网络获取用户信息、展示在TextView上</li><li>HttpUtil 用于执行网络请求</li><li>Callback 用于执行网络请求成功后的回调</li><li>User 作为用户信息的JavaBean类</li><li>UserModel 用于封装用户操作方法，它也会处理三件事：通过HttpUtil获取指定的用户数据、将数据解析成User、通过Callback返回User数据</li><li>activity_main.xml用于表示MVC结构中的View层</li></ul><p>相信类似于上面这种代码结构，大家都已经写得不厌其烦，因此这里只列出Controller的代码来说明调用关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TextView tvUsername = findViewById(R.id.tv_username);</span><br><span class="line">        Button btnGetUser = findViewById(R.id.btn_get_user);</span><br><span class="line"></span><br><span class="line">        btnGetUser.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                UserModel.getUser(<span class="string">"123"</span>, <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">                        tvUsername.setText(user.username);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个示例我们可以发现，在Android中使用MVC最大的优点是：层次划分合理，Model层可被完全解耦。那么View和Controller层呢？先来看其对应的类和文件：</p><ul><li>Controller：MainActivity</li><li>View：MainActivity、CustomView、activity_main.xml</li></ul><p>可见，MainActivity既能充当Controller层，又能充当View层。作为Controller层主要是因为我们会在其中编写大量的业务逻辑，并将其作为View和Model的组织者。而充当View层，是因为Activity是一个界面，我们可以在Activity中创建和操作各种View。这也就说明了Android中MVC最大的缺点，即Activity职责过重，无法做到解耦。如此一来，我们原先所设想的MVC模式，实际上等同于如下形式：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20200121/20200121144949.png" alt=""></p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>MVP模式主要是为了解决MVC存在的两大问题：</p><ul><li>Controller层和View层定位模糊</li><li>Model层和View层耦合</li></ul><p>如何做呢？很简单：</p><ul><li>将Activity、Fragment、CustomView、layout等和视图相关的类与文件统一看做View层</li><li>抽取Presenter层作为Model层和View层的组织者，并处理相关业务逻辑</li><li>View从Presenter中获取用户事件反馈，Presenter处理用户事件并从Model中获取数据</li><li>Model层拿到数据后，交给Presenter进行业务处理，Presenter处理完后交由View进行展示</li></ul><h4 id="标准MVP结构"><a href="#标准MVP结构" class="headerlink" title="标准MVP结构"></a>标准MVP结构</h4><p>从上面的流程中，我们可以画出如下设计图：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20200121/20200121153146.png" alt=""></p><p>除了解决上述所说的MVC两大问题外，我们可以看出MVP的分层和程序流向其实更加严谨。</p><h4 id="MVP结构示例"><a href="#MVP结构示例" class="headerlink" title="MVP结构示例"></a>MVP结构示例</h4><p>下面我们改造之前的例子，将其变为MVP，先看类结构变化：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20200121/20200121221941.png" alt=""></p><p>Model维持不变，原先的MainActivity我们将其移动到View层中，并抽取其中的业务逻辑到Presenter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MainActivity activity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Presenter</span><span class="params">(MainActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        UserModel.getUser(id, <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">               activity.showUser(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Presenter 会同时持有View和Model，当从Model获取到数据后，便可通过activity的引用对View进行更新：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextView tvUsername;</span><br><span class="line">    <span class="keyword">private</span> Button btnGetUser;</span><br><span class="line">    <span class="keyword">private</span> Presenter presenter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        tvUsername = findViewById(R.id.tv_username);</span><br><span class="line">        btnGetUser = findViewById(R.id.btn_get_user);</span><br><span class="line"></span><br><span class="line">        presenter = <span class="keyword">new</span> Presenter(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        btnGetUser.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                presenter.getUser(<span class="string">"123"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        tvUsername.setText(user.username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来我们便做到了让Activity只处理View事件，而不参与业务逻辑。但上面只是一个简单的转化过程，实际项目中要复杂得多。当你准备大面积使用MVP模式的时候，更好的做法是对MVP进行一些抽象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showLoading</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hideLoading</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showError</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPresenter</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">IView</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attachView</span><span class="params">(V view)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detachView</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三个接口分别是对M、V、P三层的抽象</p><ul><li>IView接口中包含一些常用的视图操作方法</li><li>IPresenter中包含附加View和分离View两个方法，前者较好理解，拿到View的引用后可更新视图。而需要分离View方法的主要原因是避免Prensenter在执行耗时任务时持有View的引用，从而造成内存泄漏</li><li>IModel接口定义了一个cancel方法，主要用于取消数据请求</li></ul><p>为了更方便使用，现在针对Activity和Presenter写两个抽象类，用于简化操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseMVPActivity</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">IView</span>, <span class="title">P</span> <span class="keyword">extends</span> <span class="title">IPresenter</span>&lt;<span class="title">V</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>  P presenter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        presenter = createPresenter();</span><br><span class="line">        presenter.attachView((V) <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> P <span class="title">createPresenter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        presenter.detachView();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseMVPPresenter</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">IView</span>, <span class="title">M</span> <span class="keyword">extends</span> <span class="title">IModel</span>&gt; <span class="keyword">implements</span> <span class="title">IPresenter</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> V view;</span><br><span class="line">    <span class="keyword">private</span> M model;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseMVPPresenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        model = createModel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachView</span><span class="params">(V view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.view = view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detachView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.view = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">M <span class="title">createModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要用到Activity或Presenter时只需要继承上面的抽象类即可，同理，你也可以针对Fragment进行抽象，此处便不再列举。需要注意的是，在BaseMVPPresenter中，并没有强制要求创建Model。这也是因为有些界面太过简单，甚至不需要Model层。</p><h4 id="MVP带来的问题"><a href="#MVP带来的问题" class="headerlink" title="MVP带来的问题"></a>MVP带来的问题</h4><p>虽然MVP对MVC模式进行了一些优化和改进，然而它依然存在问题：</p><ul><li>Presenter是否应该持有Context？如果持有会方便使用Android组件，然而Presenter层就无法独立进行单元测试</li><li>Intent是否该交由Presenter处理？如果仅仅是处理Intent中数据，那么交由Presenter处理没问题。而关键在于Intent往往用于Activity跳转，倘若交给Presenter处理会加重其职责，并让View层再次定位模糊</li></ul><p>类似于上述这种Presenter是否该使用Android Api所引发的迷惑点还有很多，这也说明了，虽然我们解决了MVC的混乱问题，但是却无法根本解决MVP中Presenter的职责定位问题。而上面两个实际问题也没有什么最优解，关键还是看开发人员的抉择。</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM模式基本上与MVP模式一致，不同点在于MVVM采用双向绑定（data-binding）。当View改变时会更新Model中的数据，反之，当Model更新时也会刷新View的状态。</p><p><img src="C:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200121204825153.png" alt="image-20200121204825153"></p><p>在Android中一提到MVVM就必然会涉及到data-binding这个库。那么MVVM和data-binding是什么关系呢？如果说MVC和MVP模式是一种设计规范的话，那么MVVM更像是一个框架。所谓框架就是服务于你快速开发的模型，而data-binding这个库则是帮助你实现了此模型。</p><h4 id="data-binding基本使用流程"><a href="#data-binding基本使用流程" class="headerlink" title="data-binding基本使用流程"></a>data-binding基本使用流程</h4><p>data-binding的基本使用并不复杂，主要分为三步：</p><p>首先是在build.gradle中开启dataBinding</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">...</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">       enabled <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<layout>标签包裹原布局文件并添加<data>布局变量，这一步可以通过Android Studio自动完成</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20200121/20200121214827.png" alt=""></p><p>转化之后，布局文件会变成如下样式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag"><span class="attr">...</span></span></span><br></pre></td></tr></table></figure><p>最后，我们在<data>中绑定一些数据，并通过布局表达式在元素属性中使用这些值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"String"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"lastName"</span> <span class="attr">type</span>=<span class="string">"String"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">"@+id/plain_name"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:text</span>=<span class="string">"@&#123;name&#125;"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>事实上，通过布局表达式可以完成更多复杂的操作。上面仅演示了有限的单向绑定操作，你可以使用一些更复杂的特性来完成双向绑定。由于我们主要是探究架构模式的演化，此处便不再赘述。详细可参考Google官方的data-binding库文档：<a href="https://developer.android.com/topic/libraries/data-binding" target="_blank" rel="noopener">点击此处</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面我们演示了为了解决实际项目结构问题，如何一步步从MVC、MVP到MVVM的演化。那么我们可以直接用MVVM取代前两者么？或是用MVP取代MVC？答案是否定的。如果页面足够简单，那么使用MVC当然没有问题。当页面复杂度和耦合性增强的时候，我们可以考虑MVP。为何不一步到位使用MVVM呢？主要是因为目前data-binding库会导致编译速度严重变慢，并且经常会出现binding文件生成错误等坑。还有一点是，当展示的数据需要通过复杂逻辑进行计算时，布局表达式可能无法胜任，并带来阅读难、易出错等问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大部分人刚开始学习Android的时候，其实并没有用到什么框架结构，只是单纯的在Activity中写业务逻辑，layout中写界面，JavaBean中保存数据实体。尽管官方文档并没有提到任何MVC之类的字眼，但我们仍然信誓旦旦地将这种结构称为MVC。MVC有什么特性、优缺点，以及为何后来我们需要向MVP演化？MVP中的P与MVC中的C又有何异同？MVVM模式能否完全取代之前的框架结构，以及它和databinding到底有何关系，这就是我们下面需要探究的内容。
    
    </summary>
    
    
      <category term="Android" scheme="https://linxiao.pro/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Java设计模式-面向对象设计原则</title>
    <link href="https://linxiao.pro/2020/01/08/java-design-pattern-principles/"/>
    <id>https://linxiao.pro/2020/01/08/java-design-pattern-principles/</id>
    <published>2020-01-07T21:39:46.000Z</published>
    <updated>2020-01-07T13:39:46.255Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说得好：自古真情留不住，唯有套路得人心。所谓套路即达成目的的便捷之法，而程序设计中也有套路这么一说，称之为设计模式。设计模式最早起源于建筑领域，于上个世纪80年代引入计算机，它为设计出可靠、灵活、健壮的面向对象程序提供了指导意义。一般而言，掌握了设计模式也就真正掌握了面向对象。但正如套路，模式这种东西也是可多可少可衍化，切勿生搬硬套。最重要的还是究其本质，设计模式的本质说白了就是下面要讲的面向对象设计原则。<a id="more"></a></p><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</p><p>另一种定义：就一个类而言，应该仅有一个引起它变化的原因。</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>单一职责原则说白了就是保持专注。这和Unix哲学非常类似：让程序只关注一个目标，并且把它做好。我们通过一个实例来说明为什么要使用单一职责原则，以及如何设计。假设现在有个厨子想开个面馆，做点小生意。租好店面后，他就开始忙活，厨子的类就先简单定义为如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chef</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 点菜</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderDish</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下厨</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上菜</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serveDish</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然只有简单的三个方法，但即便从生活经验上来看也觉得不妥，因为一个厨子既要承担点菜和上菜，又要承担下厨的任务。这种一人兼任多职的方式未免职责太重，时间久了必会让其手忙脚乱。就一个厨子而言，应该只有料理相关的任务才让他承担才对。这就是我们上面提到过的，仅有一个引起类变化的原因。那如何解决厨子职责过重的问题呢？很明显是请一个服务员来分担任务。经过职责划分，我们定义如下两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chef</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下厨</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 点菜</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderDish</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上菜</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serveDish</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一优化，也就解决了职责过重的问题。</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>上面我们从类的角度说明了单一职责原则，除此之外，接口、方法也应当遵循这一原则进行设计。虽然听上去貌似这一原则很简单，但现实生活远比理想情况更加复杂。很多时候，一个角色的职责定义并没有那么的清晰。</p><p>举个例子，我家里最近淘汰了一台惠普打印机，它集扫描、复印、打印于一身。虽然功能多，但是设计丑还占地方。后来我又买了台小米喷墨打印机，它设计简约耐看，却没有扫描和复印功能，必须依靠App来实现。理论上，现在智能手机人人必备，所以小米打印机的做法更加可取。但真实情况是，当家人需要扫描和复印功能时，我必须挨个教会他们使用App，还不如他们直接在以前的扫描、打印、复印一体机上捣鼓方便。那么，一体机它是职责过重么？毫无疑问，是的。那这样好用吗？你也不得不承认，好用！再比方说，上面厨子的问题，可能人家根本就没有财力再请一个服务生。</p><p>虽然这两个例子是和生活相关，但在程序设计中，类似尴尬的情况也屡见不鲜。如果要编码好看，那么就可能不实用；如果要用起来方便，那么代码可能写起来很丑，没啥规范。甚至有的公司一方面业务逻辑混乱，导致代码层面职责无法明确拆分；另一方面，却要求做代码review，甚至代码质量和绩效挂钩。有时候真是再好的设计，也敌不过没经过大脑的业务逻辑。</p><p>说了这么多，单一职责原则的特点就是：当你准备践行这一原则时，你必须在代码和业务逻辑层面找到平衡。</p><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。</p><p>另一种定义：所有引用基类的地方必须能透明地使用其子类的对象。</p><p>通俗而言，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。</p><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p>实际上，当使用继承和实现接口这两种特性的时候，就已经用到了里氏替换原则。我们现在假设这样一个场景，士兵需要枪来杀敌，但战场上应当随机应变，能捡到什么枪就用什么枪。以下使用AbstractGun来表示枪的抽象类，Handgun和Rifle来表示具体的手枪和步枪：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractGun</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handgun</span> <span class="keyword">extends</span> <span class="title">AbstractGun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用手枪射击敌人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rifle</span> <span class="keyword">extends</span> <span class="title">AbstractGun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用步枪射击敌人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义的AbstractGun有一个抽象方法表示射击敌人，Handgun和Rifle均实现了此方法，可提供给士兵杀敌。士兵需要能射击敌人的枪，而不在乎是什么枪。此时这两种正确的实现均符合里氏替换原则。那么假设此时士兵捡到了一个玩具泡泡枪呢？我们用代码来描述下泡泡枪：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleGun</span> <span class="keyword">extends</span> <span class="title">AbstractGun</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用泡泡枪喷泡泡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然泡泡枪也是枪，但泡泡枪的shoot()方法实现是喷泡泡，而并非射击敌人。 士兵捡到后肯定会一脸懵逼。也就是说泡泡枪这一子类已经抹杀了父类AbstractGun期望的射击敌人这一特性。这种场景下，也就破坏了里氏替换原则。</p><h5 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h5><p>里氏替换原则通常是定义一种约束，它规定了子类必须实现符合父类特征的方法。这对于设计继承或实现接口等，具有层级抽象概念的代码，具有一定指导意义。如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生”畸变”，则建议断开父子继承关系，采用依赖、聚合、组合等关系来代替继承。</p><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><p>通俗点说：要针对接口编程，不要针对实现编程。</p><h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><p>依赖倒置原则强调的是抽象，而不是具体，这也就意味着程序能够解耦，拥有更高的灵活性。从Java层面而言，这一原则直接体现是面向接口编程。我们都知道，接口定义了一组标准，只要符合此标准，其实具体实现如何不需要特别关心。日常生活中，可以列举的实例比比皆是。就像我们使用的手机充电器，大部分人其实拥有不止一部手机，而手机充电器基本上都是USB头，大部分手机都能通用。下面通过代码来描述此场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Charger</span> </span>&#123;</span><br><span class="line">     <span class="function">String <span class="title">charge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiCharger</span>  <span class="keyword">implements</span> <span class="title">Charger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">charge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"使用华为充电器"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiCharger</span> <span class="keyword">implements</span> <span class="title">Charger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">charge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"使用小米充电器"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(Charger charger)</span> </span>&#123;</span><br><span class="line">        System.out.println(charger.charge() + <span class="string">"为手机充电"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上描述了充电器抽象层级，以及手机对充电器的依赖关系。下面我们编写测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        Charger xiaomi = <span class="keyword">new</span> XiaomiCharger();</span><br><span class="line">        Charger huawei = <span class="keyword">new</span> HuaweiCharger();</span><br><span class="line"></span><br><span class="line">        phone.charge(xiaomi);</span><br><span class="line">        phone.charge(huawei);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用小米充电器为手机充电</span><br><span class="line">使用华为充电器为手机充电</span><br></pre></td></tr></table></figure><p>可见，只要符合接口标准。无论使用哪个品牌的充电器，其实都能为手机充电</p><h5 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h5><p>所谓依赖倒置，其实涉及到两个概念，一是依赖关系，二是上层抽象。在上例中，我们通过方法传参的方式传递依赖对象。事实上，依赖的传递在面向对象程序设计中主要有三种办法：</p><ul><li>通过构造方法传递依赖</li><li>通过Setter方法传递依赖（上例的charge方法便可当做Setter的一种）</li><li>通过接口方法声明依赖关系</li></ul><p>所谓依赖传递，主要发生在将被依赖的对象注入到需要的组件这一场景当中，俗称依赖注入。依赖注入的方式不仅上述三种，还有一些高级手段，比如Dagger。与此同时，依赖注入的对象也可能是组件、模块、简单参数等。千万不要以为依赖注入仅是简简单单传递一个被new出来的java object，你应当有更宽广的视角，即传递的object它所代表的是背后的抽象层级关系的体现。这也就是依赖倒置原则中的第二个概念，上层抽象。</p><p>事实上，上面充电器例子的类结构，和前面里氏替换原则中讲到的士兵与枪的类结构是一样的。为什么同样的类结构可以描述两种不同的原则，那么如何用代码区分呢？答案是，不需要刻意区分。设计原则只是一种指导思想，而实际编写的代码是多种思想混合在一起的实体。我们在里氏替换原则中强调的是，继承关系间的特征约束。而在依赖倒置原则中强调的则是抽象层次和依赖传递。</p><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><p>客户端不应该依赖那些它不需要的接口。</p><p>另一种定义：一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需要知道与之相关的方法即可。</p><h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><p>我们知道接口的存在是为了定义一组标准，然而问题就出在这里的一组上。日常生活中经常听到小组的概念，而大组却相对较少，这是因为小组对整体进行了更灵活的划分。接口隔离说白了就是接口中定义的一大组方法按职责进行分隔，变为小组。举个例子吧，假设现在我们是触摸板程序的API设计者，现在要设计一个监听触摸板事件的接口给其他开发人员使用，这里的接口我们简称OnTouchListener，其包含onClick， onDoubleClick，onSlide等方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnTouchListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单击</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 双击</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDoubleClick</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 滑动</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSlide</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当触控板解析了用户各种事件，然后需要回调给应用开发人员，那么触控板程序可以提供一个监听器的注入接口，注入的方法我们定义为setOnTouchListener：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Touchpad</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OnTouchListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnTouchListener</span><span class="params">(OnTouchListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.listener = listener;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于监听器的使用也非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Touchpad touchpad = <span class="keyword">new</span> Touchpad();</span><br><span class="line">        touchpad.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"接收到单击事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDoubleClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"接收到双击事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSlide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"接收到滑动事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍看貌似没啥问题，但是应用开发人员对你的API设计提出了质疑：假如我只想监听单击事件，而不想监听其他事件该怎么办？你一脸不以为然的说，当然是忽略其他回调方法。那么问题来了，明明不使用这些方法，却还不得不将这些方法实现，不仅难以维护，看上去还恶心。当碰到这种情况，就需要引入接口隔离原则了。我们可以将OnTouchListener分隔为不同的小接口，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单击</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnDoubleClickListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双击</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDoubleClick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnSlideListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 滑动</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSlide</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当回调接口被分隔为更小的粒度后，此时触控板也可以对更小的事件作出响应，即设置更具体监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Touchpad</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OnClickListener clickListener;</span><br><span class="line">    <span class="keyword">private</span> OnDoubleClickListener doubleClickListener;</span><br><span class="line">    <span class="keyword">private</span> OnSlideListener slideListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clickListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnDoubleClickListener</span><span class="params">(OnDoubleClickListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doubleClickListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnSlideListener</span><span class="params">(OnSlideListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.slideListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，如果现在只想对触摸板的单击事件作出监听，那么只需要这么做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Touchpad touchpad = <span class="keyword">new</span> Touchpad();</span><br><span class="line">        touchpad.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"接收到单击事件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h5><p>接口隔离原则其实是采用了一种分而治之的思想，这么做可极大提高代码的灵活性，不会因为修改部分接口，导致牵一发而动全身。与此同时，将接口内的一组方法，按照功能职责分隔为不同接口下的不同方法，这一做法本身也符合单一职责原则。所以说接口隔离原则与单一职责原则是相辅相成的，但与此同时前者也存在后者的缺点，即如何划分接口成了最令人困惑的难题。接口粒度太细则不便于维护，而太大又导致灵活性减少。就像是上例中的onClick和onDoubleClick两个方法，因为同属于点击事件，因此将它们放在同一接口下看上去也完全没问题。那到底是分开好呢，还是组合在一起好呢？和单一职责原则的设计思路一样，这取决于开发人员所选择的平衡。</p><h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h5><p>迪米特法则又称为最少知识原则，它有多种定义方法，其中几种典型定义如下：</p><ul><li>不要和陌生人说话</li><li>只与你的直接朋友通信</li><li>一个对象应该对其他对象有最少的了解</li></ul><p>简单来说，迪米特法则就是指一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他模块，扩展也会相对容易。</p><p>在迪米特法则中，对于一个对象，其朋友包括以下几类：</p><ul><li>当前对象本身(this)</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象时一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象</li></ul><p>任何一个对象，如果满足上面的条件之一，就是当前对象的”朋友”，否则就是”陌生人”。</p><h5 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h5><p>虽然迪米特法则的定义不易理解，但它想表达的意思却很简单。也就是隐藏不必要暴露的信息或接口，降低类之间的耦合。我们通过一个例子来说明。相信大家都吃过饭吧，哦不，是做过饭吧？其实做一顿饭成本还是挺大的，因为要买菜、洗菜、切菜、炒菜….等一系列过程。通过代码描述如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"买菜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"洗菜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"切菜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"炒菜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当要做一顿饭时，则需要依次进行如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cook cook = <span class="keyword">new</span> Cook();</span><br><span class="line">        cook.buy();</span><br><span class="line">        cook.wash();</span><br><span class="line">        cook.cut();</span><br><span class="line">        cook.cook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说，步骤多，流程杂，所以现在大多数忙于拼搏的年轻人选择了外卖。我们设计一个外卖类，来帮助我们把饭做好，我们只需要下单，然后开吃就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TakeoutService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cook cook = <span class="keyword">new</span> Cook();</span><br><span class="line">        cook.buy();</span><br><span class="line">        cook.wash();</span><br><span class="line">        cook.cut();</span><br><span class="line">        cook.cook();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"饭菜就绪，开始送外卖"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，你需要交互的就仅仅是外卖服务，做饭那些方法和流程统统与你无关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TakeoutService service = <span class="keyword">new</span> TakeoutService();</span><br><span class="line">        service.order();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">买菜</span><br><span class="line">洗菜</span><br><span class="line">切菜</span><br><span class="line">炒菜</span><br><span class="line">饭菜就绪，开始送外卖</span><br></pre></td></tr></table></figure><p>在此例中，我们添加的外卖服务类，则是迪米特法则的体现，因为它屏蔽了所有你不需要了解的细节。</p><h5 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h5><p>很多时候我们以为类的设计应该是越简练越好，但在迪米特法则中，为了实现对信息隐藏，很可能需要添加额外的控制类。类的增加反倒使业务逻辑变得更加清晰，这也就是迪米特法则的好处。就像日常生活中煮个泡面，你不会自己去买面，买调料，买蔬菜，买肉，而是选择了买一袋或买一桶包装好的方便面。包装给我们的日常生活带来了巨大的便利，而迪米特法则就是包装在面向对象设计过程中的体现。</p><h4 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h4><h5 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h5><p>尽量使用对象组合，而不是继承来达到复用的目的。</p><h5 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h5><p>合成复用原则理解起来并不难，即将代码复用方式由继承转化为组合。 我们现在假设有两个程序员，类Beginner表示初级程序员，只会写HTML，现在需要用C语言干活儿；而类CProgrammer表示C语言程序员，拥有丰富的C编码经验。现在Beginner需要向CProgrammer学习C语言。用代码表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CProgrammer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我会写C语言"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beginner</span> <span class="keyword">extends</span> <span class="title">CProgrammer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeHtml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我会写HTML"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过继承的方式，类Beginner拥有了writeC的能力。那假如初级程序员Beginner又需要用到Java语言呢，同样是向Java程序员学习，继承其能力么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaProgrammer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeJava</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我会写Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么想当然也没错，但是你别忘了，在Java中，类不允许多重继承。好了，这下尴尬了。但回过头来仔细想想，其实初级程序员Beginner也并非一定要继承C程序员和Java程序员的能力，在需要的时候，请后两者帮把手即可。实际工作中，这种情况也经常发生。我们使用这种思路，对类Beginner进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beginner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeHtml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我会写HTML"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeC</span><span class="params">(CProgrammer programmer)</span> </span>&#123;</span><br><span class="line">        programmer.writeC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeJava</span><span class="params">(JavaProgrammer programmer)</span> </span>&#123;</span><br><span class="line">        programmer.writeJava();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设现在领导布置了开发任务给初级程序员，那么初级程序员就可以这么做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Beginner beginner = <span class="keyword">new</span> Beginner();</span><br><span class="line">        beginner.writeHtml();</span><br><span class="line">        beginner.writeC(<span class="keyword">new</span> CProgrammer());</span><br><span class="line">        beginner.writeJava(<span class="keyword">new</span> JavaProgrammer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我会写HTML</span><br><span class="line">我会写C语言</span><br><span class="line">我会写Java</span><br></pre></td></tr></table></figure><p>上例中，我们经过二次修改的Beginner类也就符合了合成复用原则。</p><h5 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h5><p>在面向对象程序设计中，要想达到代码复用效果，其实无论采用继承还是组合的方式均可。但在Java中，会存在单继承的问题。即便是在Python、C++等允许多继承的语言中，使用多继承依然会带来代码结构混乱等后果。再来就是，使用继承会将父类的实现细节暴露给子类，也就破坏了封装性。</p><p>通过组合对象的方式来复用代码或功能，不仅不会将类抽象层次加深，影响可阅读性。并且，也不会破坏封装性。还有一个好处就是，组合使得类与类之间的耦合度降低，提高了灵活性。</p><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><h5 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h5><p>一个软件实体应当对扩展开放，对修改关闭。</p><p>也就是说，要想改变一个实体的行为不应该修改其源码，而是应当对其扩展。</p><h5 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h5><p>不修改源码好理解，那么对其扩展呢？在面向对象程序设计中，最容易的扩展方式也就是使用继承。举个例子，以前人们用的手机是功能机，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sentMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来智能手机和移动互联网开始崛起，手机的通话和短信能力没有本质变化，但其他功能越发丰富：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拍照"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfInternet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"上网"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenMusic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"听音乐"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的SmartPhone通过继承的方式对Phone的功能进行了扩展，而没有修改Phone的代码，这其实就符合开闭原则。</p><h5 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h5><p>虽然看上去开闭原则实现起来并不复杂，而实际情况并非如此。以上仅仅是针对一个简单类做出开闭设计，试想一些复杂的接口、模块呢？当功能越复杂，实现开闭原则就越困难。以至于，有时候为了实现开闭原则，你还需要类似于上述其他设计原则作为参考依据。既然开闭原则设计起来困难重重，那么为何我们还需要设计出符合开闭原则的类、接口或模块？一个重要的原因是，可能你编写的代码出于商业目的，无法向使用方直接提供，而是通过编译好的jar包等方式共享。此时，使用方开发人员无法直接修改代码，只能通过扩展。另一个原因是出于测试目的，现有的代码一旦经过测试，就不应该再次轻易修改，这会增加测试工作量，导致程序的不稳定性增加。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;俗话说得好：自古真情留不住，唯有套路得人心。所谓套路即达成目的的便捷之法，而程序设计中也有套路这么一说，称之为设计模式。设计模式最早起源于建筑领域，于上个世纪80年代引入计算机，它为设计出可靠、灵活、健壮的面向对象程序提供了指导意义。一般而言，掌握了设计模式也就真正掌握了面向对象。但正如套路，模式这种东西也是可多可少可衍化，切勿生搬硬套。最重要的还是究其本质，设计模式的本质说白了就是下面要讲的面向对象设计原则。
    
    </summary>
    
    
      <category term="Java" scheme="https://linxiao.pro/categories/Java/"/>
    
    
      <category term="设计模式" scheme="https://linxiao.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式-单例</title>
    <link href="https://linxiao.pro/2020/01/06/java-design-pattern-singleton/"/>
    <id>https://linxiao.pro/2020/01/06/java-design-pattern-singleton/</id>
    <published>2020-01-06T15:10:43.000Z</published>
    <updated>2020-01-06T07:10:43.683Z</updated>
    
    <content type="html"><![CDATA[<p>所谓单例，即系统或程序运行期间只允许某个类存在唯一实例。单例设计模式的实际应用场景很多，比如Windows系统中的回收站和任务管理器，你永远也无法将它们各自打开多个，因为它们是被全局共享的，且是唯一的。再比如中国古代的皇帝，同一时期也只能存在一个。这些例子告诉我们，单例的存在往往和资源有关，它能防止一个类的资源被重复加载。<a id="more"></a></p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><h5 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h5><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20200105/20200105223101.png" alt=""></p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>由于在内存中只有一个实例，减少了内存开销</li><li>可以避免对资源的多重占用，节约系统资源</li><li>设置了全局唯一访问点，可以严格控制访问时机和访问权限</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>单例模式通常没有抽象层，因此扩展很困难，通常只能依靠修改代码，这违反了开闭原则</li><li>单例类职责过重，它既充当了工厂角色又要包含实际业务逻辑，违背了单一职责原则</li></ul><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>要求生成唯一序列号的系统环境</li><li>web页面的计数器</li><li>需要定义大量静态常量和静态方法的工具类</li><li>创建对象需要消耗过多资源的类</li></ul><h5 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h5><ul><li>私有化类构造器</li><li>在类中创建一个私有的本类对象成员</li><li>创建一个公开方法，返回该类对象</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><h5 id="饿汉式-静态成员变量实现"><a href="#饿汉式-静态成员变量实现" class="headerlink" title="饿汉式-静态成员变量实现"></a>饿汉式-静态成员变量实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式的实现非常简单，只需要在定义静态变量的时候实例化单例类即可。当类被加载时，单例对象也随之被创建。也同样是因为此特性，它可能会带来资源浪费。因为某些情况下，类或许已经被加载，而单例对象却并未有机会使用。为了让单例对象实例化操作延迟到需要时才执行，我们可以采取懒汉式的单例实现。</p><h5 id="懒汉式-非线程安全实现"><a href="#懒汉式-非线程安全实现" class="headerlink" title="懒汉式-非线程安全实现"></a>懒汉式-非线程安全实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式与饿汉式的主要区别在于，前者仅声明单例变量却并未创建实例，直到使用时才开始创建并返回，而后者则是在声明单例时便已定义。虽然懒汉式达到了延迟初始化单例的目的，但与此同时它的实现也带来了新的问题，即在多线程场景下，可能会产生多个实例，而非单例。我们可以写一段代码来进行验证，下面的例子中通过线程池创建了10个线程，然后往这10个线程中提交了10000次请求单例对象的操作，并打印请求到的单例对象地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                Singleton instance = Singleton.getInstance();</span><br><span class="line">                System.out.println(instance);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Singleton@599c9795</span><br><span class="line">Singleton@2e249d35</span><br><span class="line">Singleton@72d978a5</span><br><span class="line">Singleton@2e249d35</span><br><span class="line">Singleton@2e249d35</span><br><span class="line">Singleton@2e249d35</span><br><span class="line">Singleton@2e249d35</span><br><span class="line">Singleton@5581e36e</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>输出显示了多个实例地址，而非单例。</p><p>为什么会这样呢？我们通过画图来分析一下，产生多个实例的原因：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20200105/20200105112855.png" alt=""></p><ul><li>当线程1执行到红色节点时，此时INSTANCE为null，线程1准备创建实例</li><li>在线程1创建实例前，CPU时间片耗完，线程陷入阻塞。此时线程2执行到红色节点，发现INSTANCE依然为null，于是也准备创建实例</li><li>线程2创建完实例后并返回，此时线程1在红色节点处被唤醒</li><li>线程1被唤醒后继续创建实例并返回，而此时返回了两个不同实例</li></ul><p>经过上面一系列步骤后，我们发现了创建多个实例的主要原因，在于创建实例这一过程不是原子性的，即每个线程都可能在创建过程中对INSTANCE进行修改，从而引发线程安全性问题。为了让创建过程变为原子性，我们需要在创建方法上加锁。</p><h5 id="懒汉式-synchronized实现"><a href="#懒汉式-synchronized实现" class="headerlink" title="懒汉式-synchronized实现"></a>懒汉式-synchronized实现</h5><p>创建实例过程中加锁的方式有很多，可以使用ReentrantLock，也可以对代码块加锁，原理都一样。此处为了方便，我们直接在getInstance()方法上使用synchronized加锁，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，再次执行上面的重复请求单例对象测试代码，可以看到，输出的对象都为同一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Singleton@783fadc2</span><br><span class="line">Singleton@783fadc2</span><br><span class="line">Singleton@783fadc2</span><br><span class="line">Singleton@783fadc2</span><br><span class="line">Singleton@783fadc2</span><br><span class="line">Singleton@783fadc2</span><br><span class="line">Singleton@783fadc2</span><br><span class="line">Singleton@783fadc2</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>虽然synchronized实现方式解决了懒汉式带来的可能会创建多个实例的bug，但与此同时，synchronized实现方式依旧带来了一定的性能损耗，损耗的原因主要在于并发场景下，通过加锁会使多线程变为串行访问，我们通过画图说明：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20200105/20200105120145.png" alt=""></p><p>我们把单例的创建过程通过加锁的方式变为原子性操作，也就是上图紫色区域。此时多线程无法随意进入此区域，每次只有一个线程持有锁后可以访问此区域代码，访问结束后释放锁，其他线程开始争夺锁并访问。换句话说，当多个线程需要单例时，由于锁的存在会产生阻塞，然后逐个以串行的方式来获取单例，而并发的优势此刻全无。为了解决此问题，我们可以使用双重检查锁实现来进行优化。</p><h5 id="懒汉式-双重检查锁实现"><a href="#懒汉式-双重检查锁实现" class="headerlink" title="懒汉式-双重检查锁实现"></a>懒汉式-双重检查锁实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查锁实现的关键在于，我们将锁的粒度减小了，因此造成性能浪费的范围也就更小。上面的代码有几个地方需要额外注意：</p><ul><li>第一次检查单例是否创建时不需要加锁</li><li>当实例不存在，需要创建新实例时，开始加锁</li><li>在加锁的代码中，需要二次检查实例是否存在。这是因为，可能在创建之前多个线程就已经执行完INSTANCE == null的判断，并准备接下来创建实例。仅对创建代码加锁而不二次检查实例是否存在，则依然可能产生创建多个实例的问题</li></ul><p>经过双重检查锁的优化，貌似创建单例的问题彻底解决了，但事实上并发如此。在我们没有注意的地方，暗藏着新的问题，它可能会导致空指针或其他异常发生，并难以复现。产生问题的原因在new Singleton()这一行。虽然从代码层面上看，创建对象是一条语句，但在Java执行过程中，它实际等效于三个指令：</p><ul><li>为对象分配内存</li><li>初始化对象</li><li>将INSTANCE引用指向分配的内存地址</li></ul><p>由于Java会进行一些优化行为，因此上面三个指令可能会发生指令重排序，变成如下顺序</p><ul><li>为对象分配内存</li><li>将INSTANCE引用指向分配的内存地址</li><li>初始化对象</li></ul><p>顺序虽然变了，但从结果上看，即便发生了指令重排序，创建的实例和没有发生指令重排序时完全一样。况且，进行指令重排序优化可以提高CPU执行效率，何乐而不为呢？但事实并非如此，我们通过图例来说明指令重排序会导致的问题：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20200105/20200106095555.png" alt=""></p><p>当线程1执行完前两个指令时，INSTANCE便已经不为null。此时线程2进入方法，发现INSTANCE不为null则直接进行对象访问。而尴尬之处在于，虽然INSTANCE不为null，但由于指令重排序，INSTANCE的初始化过程是在为INSTANCE引用赋值之后，也就是说此时对象中的资源也许尚未加载完成。一旦线程2在这一间隙访问，则有可能引发未知异常。</p><p>前面通过添加synchronized关键字，虽然能保证线程间的可见性及原子性，但并不能阻止Java对某些语句进行指令重排序。为了防止指令重排序给INSTANCE初始化带来的问题，我们应当为其加上volatile标记，即把声明语句变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE;</span><br></pre></td></tr></table></figure><h5 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h5><p>除了懒汉式和饿汉式两种实现方式，也可以采用静态内部类实现，它兼顾了前两者的优点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingleton</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerSingleton.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部类Singleton没有static属性，所以不会像饿汉式那样立即加载单例对象。只有真正调用getInstance()方法时，才会加载静态内部类和其中的static成员INSTANCE。由于INSTANCE是static final类型，因此虚拟机保证了线程安全，内存中只有这样一个实例存在，而且只能被赋值一次。通过这种方法兼备了并发的高效调用和延迟加载的优势。</p><h5 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于枚举本身就是一个单例，因此JVM从根本上保证了它的安全性，这种实现方式不仅简单，还可以避免通过反射和反序列化破坏单例的漏洞。</p><p>为什么枚举是个单例呢？我们通过jad工具对上述代码生成的class文件进行反编译，得到如下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span></span><br><span class="line"><span class="comment">// Jad home page: http://www.kpdus.com/jad.html</span></span><br><span class="line"><span class="comment">// Decompiler options: packimports(3) </span></span><br><span class="line"><span class="comment">// Source File Name:   Singleton.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Singleton[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">valueOf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Singleton)Enum.valueOf(Singleton, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton(<span class="string">"INSTANCE"</span>, <span class="number">0</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Singleton[] &#123;</span><br><span class="line">            INSTANCE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以提取到下列关键信息：</p><ul><li>枚举类其实是一个final class</li><li>枚举类的构造方法被声明为private，即无法在外部创建枚举实例</li><li>枚举类成员INSTANCE 是static final类型，并且会在枚举类的static代码块中进行定义</li></ul><p>可以看出使用枚举实现单例，其实和饿汉式是类似的，因此它也无法做到延迟加载。</p><h4 id="破坏单例"><a href="#破坏单例" class="headerlink" title="破坏单例"></a>破坏单例</h4><h5 id="通过反射破坏单例"><a href="#通过反射破坏单例" class="headerlink" title="通过反射破坏单例"></a>通过反射破坏单例</h5><p>除了枚举，采用饿汉式、懒汉式和静态内部类实现的单例都可以通过反射进行破坏。下面代码用来演示流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取单例类无参构造器</span></span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line">        <span class="comment">// 设置私有的构造为可访问</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个对象</span></span><br><span class="line">        Singleton singleton1 = constructor.newInstance();</span><br><span class="line">        Singleton singleton2 = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(singleton1);</span><br><span class="line">        System.out.println(singleton2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Singleton@330bedb4</span><br><span class="line">Singleton@2503dbd3</span><br></pre></td></tr></table></figure><p>可见此处创建了两个不同对象。要解决反射破坏也很简单，只需要在构造方法中进行判断即可。若类已构造出一个对象，则再次调用构造器时抛出异常。下面针对静态内部类实现的单例进行演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (InnerSingleton.INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Singleton object can be created"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行后，输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "main" java.lang.reflect.InvocationTargetException</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">at JavaMain.main(JavaMain.java:15)</span><br><span class="line">Caused by: java.lang.RuntimeException: Only one Singleton object can be created</span><br><span class="line">at Singleton.&lt;init&gt;(Singleton.java:8)</span><br><span class="line">... 5 more</span><br></pre></td></tr></table></figure><p>通过在构造方法中判断INSTANCE是否被初始化来阻挡反射攻击这一方式，仅针对饿汉式和静态内部类方式有效。原因在于，这两者都在类加载时为INSTANCE赋值，并且为final类型，所以后续通过反射调用构造方法时，其中的非空判断总为true。而饿汉式为了懒加载，其中的INSTANCE为null，因此在使用反射时调用私有的构造方法，判断总为false，所以还是会创建多个实例。</p><p>针对懒汉式单例阻挡反射攻击无效，网上有一种方案是添加一个额外的flag，标记单例是否已经被初始化过，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Singleton object can be created"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次尝试通过反射攻击后，报出异常。看上去貌似可行，但我们现在改变攻击方式，通过反射将flag的值重置为true：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取单例类无参构造器</span></span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line">        <span class="comment">// 设置私有的构造方法为可访问</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Field flag = Singleton.class.getDeclaredField("flag");</span><br><span class="line">        flag.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个对象</span></span><br><span class="line">        Singleton singleton1 = constructor.newInstance();</span><br><span class="line">        <span class="comment">// 设置静态变量flag的值为false</span></span><br><span class="line">        flag.set(Singleton<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>)</span>;</span><br><span class="line">        <span class="comment">// 再次创建对象</span></span><br><span class="line">        Singleton singleton2 = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(singleton1);</span><br><span class="line">        System.out.println(singleton2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Singleton@4b67cf4d</span><br><span class="line">Singleton@7ea987ac</span><br></pre></td></tr></table></figure><p>可见，当采用懒汉式单例的时候不论如何预防，总能通过反射进行破坏。</p><h5 id="通过序列化破坏单例"><a href="#通过序列化破坏单例" class="headerlink" title="通过序列化破坏单例"></a>通过序列化破坏单例</h5><p>除了通过反射可以破坏单例，如果一个类实现了Serializable接口，那么也可以通过反序列化的方式破坏单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将单例写入文件</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"./instance.obj"</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        oos.writeObject(instance1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件读取单例</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"./instance.obj"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        Singleton instance2 = (Singleton) ois.readObject();</span><br><span class="line">        </span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Singleton@29453f44</span><br><span class="line">Singleton@7b23ec81</span><br></pre></td></tr></table></figure><p>上面输出了两个不同实例。产生多个实例的原因，主要是因为在反序列化读取对象文件的过程中重新生成了对象，要解决此问题，可以在单例类中添加一个readResolve()方法，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ObjectStreamException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当添加readResolve()方法后，使用反序列化读取对象时就不会从对象流中通过反射创建新的对象，而是强制从readResolve()方法中返回当前类的静态成员变量INSTANCE。</p><h5 id="为何无法破坏枚举单例"><a href="#为何无法破坏枚举单例" class="headerlink" title="为何无法破坏枚举单例"></a>为何无法破坏枚举单例</h5><p>枚举不仅使用简便，并且它能阻挡反射和反序列化攻击。在演示攻击枚举单例前，我们需要先熟悉下枚举类的构造方法。枚举类的源代码文件位于jdk\src.zipjava\lang\Enum.java，其构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sole constructor.  Programmers cannot invoke this constructor.</span></span><br><span class="line"><span class="comment"> * It is for use by code emitted by the compiler in response to</span></span><br><span class="line"><span class="comment"> * enum type declarations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name - The name of this enum constant, which is the identifier</span></span><br><span class="line"><span class="comment"> *               used to declare it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ordinal - The ordinal of this enumeration constant (its position</span></span><br><span class="line"><span class="comment"> *         in the enum declaration, where the initial constant is assigned</span></span><br><span class="line"><span class="comment"> *         an ordinal of zero).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道枚举类的构造方法参数类型后，我们便可通过反射进行攻击，需要注意的是下面获取构造方法需填入类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取单例类无参构造器</span></span><br><span class="line">        Constructor&lt;Singleton&gt; constructor = Singleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">String</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 设置构造方法为可访问</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个对象</span></span><br><span class="line">        Singleton singleton1 = constructor.newInstance(<span class="string">"singleton1"</span>, <span class="number">1</span>);</span><br><span class="line">        Singleton singleton2 = constructor.newInstance(<span class="string">"singleton2"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(singleton1);</span><br><span class="line">        System.out.println(singleton2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "main" java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:417)</span><br><span class="line">at JavaMain.main(JavaMain.java:12)</span><br></pre></td></tr></table></figure><p>可见攻击失败，我们根据提示，找出Constructor.java类的417行，看看究竟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, <span class="keyword">null</span>, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --------------------下面是第417行----------------------</span></span><br><span class="line">    <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)                       </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br><span class="line">    ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ca == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ca = acquireConstructorAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T inst = (T) ca.newInstance(initargs);</span><br><span class="line">    <span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，417行做出了一个判断，在通过反射创建实例时，如果构造器的类型是枚举类型，则会抛出一个IllegalArgumentException，即通过反射攻击失败。</p><p>下面我们尝试通过反序列化来攻击，代码基本上与之前写过的一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将单例写入文件</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"./instance.obj"</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        oos.writeObject(instance1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件读取单例</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"./instance.obj"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        Singleton instance2 = (Singleton) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance1 + <span class="string">"@"</span> + instance1.hashCode());</span><br><span class="line">        System.out.println(instance2 + <span class="string">"@"</span> + instance2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSTANCE@312714112</span><br><span class="line">INSTANCE@312714112</span><br></pre></td></tr></table></figure><p>通过反序列化创建的实例依旧和直接获取的单例一致，即通过序列化攻击也失败。</p><p>之所以使用其他方式实现的单例可以攻击成功，是因为它们在反序列化过程中，会通过反射来创建新实例。而枚举在获取实例这一阶段比较特殊，我们可以深入到ObjectInputStream中探究其实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Enum&lt;?&gt; readEnum(<span class="keyword">boolean</span> unshared) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="keyword">if</span> (bin.readByte() != TC_ENUM) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ObjectStreamClass desc = readClassDesc(<span class="keyword">false</span>);</span><br><span class="line">       <span class="keyword">if</span> (!desc.isEnum()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">"non-enum class: "</span> + desc);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> enumHandle = handles.assign(unshared ? unsharedMarker : <span class="keyword">null</span>);</span><br><span class="line">       ClassNotFoundException resolveEx = desc.getResolveException();</span><br><span class="line">       <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">           handles.markException(enumHandle, resolveEx);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       String name = readString(<span class="keyword">false</span>);</span><br><span class="line">       Enum&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">       Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">       <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);</span><br><span class="line">               result = en;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidObjectException(</span><br><span class="line">                   <span class="string">"enum constant "</span> + name + <span class="string">" does not exist in "</span> +</span><br><span class="line">                   cl).initCause(ex);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!unshared) &#123;</span><br><span class="line">               handles.setObject(enumHandle, result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       handles.finish(enumHandle);</span><br><span class="line">       passHandle = enumHandle;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面的代码用于读取枚举类实例并返回，其中有一行非常关键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);</span><br></pre></td></tr></table></figure><p>这一行的目的在于从枚举类中获取name的值，而此值正是枚举类的实例。这也就解释了，为何通过反序列化也无法破坏枚举类实现的单例，因为在其反序列化过程中根本没有生成新的枚举值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓单例，即系统或程序运行期间只允许某个类存在唯一实例。单例设计模式的实际应用场景很多，比如Windows系统中的回收站和任务管理器，你永远也无法将它们各自打开多个，因为它们是被全局共享的，且是唯一的。再比如中国古代的皇帝，同一时期也只能存在一个。这些例子告诉我们，单例的存在往往和资源有关，它能防止一个类的资源被重复加载。
    
    </summary>
    
    
      <category term="Java" scheme="https://linxiao.pro/categories/Java/"/>
    
    
      <category term="设计模式" scheme="https://linxiao.pro/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程-ThreadLocal解析</title>
    <link href="https://linxiao.pro/2019/12/28/java-concurrency-thread-local/"/>
    <id>https://linxiao.pro/2019/12/28/java-concurrency-thread-local/</id>
    <published>2019-12-28T14:46:25.000Z</published>
    <updated>2019-12-28T06:46:25.968Z</updated>
    
    <content type="html"><![CDATA[<p>生活中往往会出现如下场景：家里只有一台电视，姐姐想看CCTV，弟弟想看AV。两个人为了电视互掐，你换我的频道，我换你的频道，谁也没法把一段节目完整看完。假设姐姐和弟弟分别是两条线程，电视是线程间共享的资源，那么此时便属于线程安全事故。解决线程安全问题的方法有很多，而其中一种是使用ThreadLocal。<a id="more"></a></p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>通常情况下，导致线程安全问题发生的主要原因在于多个线程在同一时刻访问同一资源，对资源访问的代码我们称之为临界区。要想达到线程安全，一个常用的手段是对临界区加锁。这样可以保证只有持有锁的线程才能访问临界区，而没有锁的线程就会阻塞，直到锁被释放，然后重新开始竞争锁。虽然这么做线程安全的问题是解决了，但每次只有一个线程访问资源其他线程都在等待，未免时间成本太高。此时，ThreadLocal便可派上用武之地。</p><p>ThreadLocal用于提供线程局部变量，换句话说，它会为每个线程提供一份变量的拷贝。此处的变量即是共享资源，为每个线程提供一份共享资源的副本，并且线程间的资源副本相互隔离，于是也就达到了线程安全的目的。虽热这样会浪费一些内存空间，但用空间换时间的做法，在计算机领域屡见不鲜。</p><h5 id="访问共享资源"><a href="#访问共享资源" class="headerlink" title="访问共享资源"></a>访问共享资源</h5><p>这么纯粹说概念可能不太容易讲清问题，我们先用代码把上面姐弟俩争电视的场景给模拟出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TV tv = <span class="keyword">new</span> TV();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    tv.watch(<span class="string">"cctv"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"姐姐"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    tv.watch(<span class="string">"av"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">"弟弟"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String channel;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(String c)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.channel = c;</span><br><span class="line">            <span class="comment">// 此处模拟观看时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在观看"</span> + channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">弟弟正在观看av</span><br><span class="line">姐姐正在观看av</span><br><span class="line">姐姐正在观看cctv</span><br><span class="line">弟弟正在观看cctv</span><br><span class="line">弟弟正在观看av</span><br><span class="line">姐姐正在观看av</span><br><span class="line">姐姐正在观看cctv</span><br><span class="line">弟弟正在观看cctv</span><br><span class="line">弟弟正在观看av</span><br><span class="line">姐姐正在观看av</span><br></pre></td></tr></table></figure><p>假设姐弟二人各争夺5次遥控器，那么根据上面的输出我们已经可以得出两种结论：</p><ul><li>姐姐抢到遥控器，切换到CCTV，弟弟只能跟着看CCTV</li><li>弟弟抢到遥控器，切换到AV，姐姐只能跟着看AV</li></ul><p>换句话说，姐弟俩各无法将自己想看的节目完整看完。这并非他们想要的效果，他们想要的是自己在看电视的过程中并不会受到任何干扰。于是他们改变了策略，姐姐在看一段节目时，为了避免弟弟来争夺遥控器，于是把自己锁在了房间里，不准弟弟进来看，直到看完节目后才打开房间。弟弟也是同样操作。</p><h5 id="使用synchronized"><a href="#使用synchronized" class="headerlink" title="使用synchronized"></a>使用synchronized</h5><p>现在我们来模拟锁在房间里看电视这一行为，其实只需要给<code>watch</code>方法加上synchronized关键字即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(String c)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = c;</span><br><span class="line">    <span class="comment">// 此处模拟观看时间</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"正在观看"</span> + channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译运行完整程序后，输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">姐姐正在观看cctv</span><br><span class="line">姐姐正在观看cctv</span><br><span class="line">姐姐正在观看cctv</span><br><span class="line">姐姐正在观看cctv</span><br><span class="line">姐姐正在观看cctv</span><br><span class="line">弟弟正在观看av</span><br><span class="line">弟弟正在观看av</span><br><span class="line">弟弟正在观看av</span><br><span class="line">弟弟正在观看av</span><br><span class="line">弟弟正在观看av</span><br></pre></td></tr></table></figure><p>从输出可以看到，姐姐完整观看了5部CCTV节目，弟弟完整观看了5部AV。但是他们都是以串行的方式观看，即只有当姐姐观看完一部或多部节目后，弟弟才能观看，反之亦是如此。周末的时光往往飞快逝去，且想看的节目不一定还会重播。看个电视还需要轮番上阵，人生未免太过艰难。为了从源头解决这个问题，家里必须添加一个电视了。从程序的角度而言，也就是多个线程想访问同一共享资源，为了避免竞争，索性创建共享资源的副本，让每个线程可以独享。</p><h4 id="ThreadLocal基本用法"><a href="#ThreadLocal基本用法" class="headerlink" title="ThreadLocal基本用法"></a>ThreadLocal基本用法</h4><h5 id="适用场景一"><a href="#适用场景一" class="headerlink" title="适用场景一"></a>适用场景一</h5><p>为线程创建共享资源（变量）的副本这一工作，可以交由ThreadLocal来做。现在我们来改写程序，为姐弟俩各创建一个电视资源，这样便可做到同时观看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化threadlocal，方式一</span></span><br><span class="line">        ThreadLocal&lt;TV&gt; threadLocal = ThreadLocal.withInitial(<span class="keyword">new</span> Supplier&lt;TV&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> TV <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TV();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TV tv = threadLocal.get();</span><br><span class="line">                    tv.watch(<span class="string">"cctv"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"姐姐"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TV tv = threadLocal.get();</span><br><span class="line">                    tv.watch(<span class="string">"av"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">"弟弟"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String channel;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(String c)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.channel = c;</span><br><span class="line">            <span class="comment">// 此处模拟观看时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"正在观看"</span> + channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">弟弟正在观看av</span><br><span class="line">姐姐正在观看cctv</span><br><span class="line">弟弟正在观看av</span><br><span class="line">姐姐正在观看cctv</span><br><span class="line">弟弟正在观看av</span><br><span class="line">姐姐正在观看cctv</span><br><span class="line">弟弟正在观看av</span><br><span class="line">姐姐正在观看cctv</span><br><span class="line">姐姐正在观看cctv</span><br><span class="line">弟弟正在观看av</span><br></pre></td></tr></table></figure><p>这次姐弟俩终于完整观看完了想看的节目。诀窍在于姐弟俩各拥有一台电视，也就是每个线程各自拥有希望独享的资源。虽然这样是对资源及空间的一种浪费，但是毕竟你也知道，人生在世难有公平，有些人家里就是有矿啊，你只能干瞪眼。而在计算机领域中，采用锁，即消耗时间来解决共享资源访问问题；还是采用ThreadLocal，即消耗空间来解决此问题。这完全取决于业务和编码者所做出的选择。</p><h5 id="适用场景二"><a href="#适用场景二" class="headerlink" title="适用场景二"></a>适用场景二</h5><p>上面的例子演示了线程间各自持有资源副本，但ThreadLocal的含义是线程局部变量，既然是变量，那么它除了可访问，并且还是可修改的。而局部的意思是，针对每个线程的变量修改，并不会影响其他线程的同名变量。这应该很好理解，比方说上例姐弟俩各自看电视，每个人针对电视状态的改变，肯定不会影响到对方的电视。</p><p>下面我们通过例子来演示如何设置线程内局部变量，此处我们将每个线程TV对象中的channel进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化threadlocal，方式二</span></span><br><span class="line">        ThreadLocal&lt;TV&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;TV&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> TV <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TV();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            TV tv = threadLocal.get();</span><br><span class="line">            System.out.println(<span class="string">"姐姐电视的原始频道："</span> + tv.getChannel());</span><br><span class="line">            tv.setChannel(<span class="string">"cctv"</span>);</span><br><span class="line">            System.out.println(<span class="string">"姐姐电视的当前频道："</span> + tv.getChannel());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;, <span class="string">"姐姐"</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            TV tv = threadLocal.get();</span><br><span class="line">            System.out.println(<span class="string">"弟弟电视的原始频道："</span> + tv.getChannel());</span><br><span class="line">            tv.setChannel(<span class="string">"av"</span>);</span><br><span class="line">            System.out.println(<span class="string">"弟弟电视的当前频道："</span> + tv.getChannel());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;, <span class="string">"弟弟"</span>).start();</span><br><span class="line">        </span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String channel = <span class="string">"mtv"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> channel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChannel</span><span class="params">(String channel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姐姐电视的原始频道：mtv</span><br><span class="line">姐姐电视的当前频道：cctv</span><br><span class="line">弟弟电视的原始频道：mtv</span><br><span class="line">弟弟电视的当前频道：av</span><br></pre></td></tr></table></figure><p>两个线程运行中间，特地休眠了2秒，好让其中一个线程先执行，以验证是否会对另一个线程的同一变量产生影响。结果显而易见，每个线程都能获取到同名变量，而对其所做的任何修改并不会影响到其他线程。</p><h5 id="适用场景小结"><a href="#适用场景小结" class="headerlink" title="适用场景小结"></a>适用场景小结</h5><p>根据上面两个例子，我们基本可以得出ThreadLocal适用的两个场景：</p><ul><li>在多个线程间通过创建资源副本的方式来共享资源，以达到线程安全的目的</li><li>为多个线程创建同名的局部变量，用来保存上下文信息，且对其他线程不影响</li></ul><p>但这两个适用场景，甚至更多其他适用场景，其实都殊途同归。ThreadLocal最主要的目的还是维护单个线程内的局部变量，变量的用法取决于每个线程各自的需求。</p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p>经过上面的代码，我们总结下ThreadLocal的常用方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>ThreadLocal()</td><td>构造方法，用于创建一个线程本地变量</td></tr><tr><td>withInitial(Supplier supplier)</td><td>ThreadLocal类中的静态方法，用于创建一个线程本地变量，并且可指定初始值</td></tr><tr><td>initialValue()</td><td>返回当前线程thread-local变量的初始值，此方法会在第一次访问变量时调用</td></tr><tr><td>get()</td><td>返回当前线程thread-local变量的值</td></tr><tr><td>set()</td><td>设置当前线程thread-local变量的值</td></tr><tr><td>remove()</td><td>移除当前线程的thread-local变量</td></tr></tbody></table><h4 id="ThreadLocal解析"><a href="#ThreadLocal解析" class="headerlink" title="ThreadLocal解析"></a>ThreadLocal解析</h4><p>要了解ThreadLocal的原理，我们可以先从一些常用的方法入手，来阅读源码。</p><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 根据当前线程来获取线程中存储的ThreadLocalMap对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以当前ThreadLocal对象作为key查找保存在ThreadLocalMap对象中的实体Entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果能找到保存在当前线程中的ThreadLocal对象，则取出其值并返回</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果未能找到当前线程中存储的ThreadLocal对象，那么需要对当前线程中的ThreadLocal变量进行初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的源码中有两个关键点，一个是<code>getMap</code>方法，另一个是<code>setInitialValue</code>方法，先来看前者。</p><h5 id="getMap"><a href="#getMap" class="headerlink" title="getMap"></a>getMap</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>t</code>指代当前线程，<code>getMap</code>会返回当前线程中的<code>threadLocals</code>字段，它的类型是ThreadLocalMap，可以猜测他用于保存ThreadLocal的键值对。</p><h5 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue"></a>setInitialValue</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过initialValue方法获取初始化值，前提是在构造ThreadLocal对象时，此方法已经被复写</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    <span class="comment">// 以下两行代码同上述get方法一样，都是用于获取当前线程中保存ThreadLocal对象的ThreadLocalMap</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果ThreadLocalMap对象已经被初始化，那么以当前的ThreadLocal对象作为key，直接设置value进去</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果ThreadLocalMap对象没有被初始化，那么先创建当前线程中的此对象，并把value作为第一个值丢进去</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看<code>setinitialValue</code>，其中的<code>initialValue</code>方法是用于返回ThreadLocal的初始值，而关键点在于<code>createMap</code>方法</p><h5 id="createMap"><a href="#createMap" class="headerlink" title="createMap"></a>createMap</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createMap</code>方法比较简单，它用于创建一个ThreadLocalMap对象，而参数<code>t</code>则是指代当前线程。从源码可知，创建的ThreadLocalMap对象其实是被当前线程的<code>threadLocals</code>字段所引用。换句话说，每个线程内部都会存在一个ThreadLocalMap对象，从语义可以猜测它应该类似于一个Map类型的结构，而存储的key是ThreadLocal对象的引用，存储的value是ThreadLocal对象的值。</p><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 以当前ThreadLocal对象为key，保存value的值到ThreadLocalMap对象中</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 为当前线程创建一个新的ThreadLocalMap</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面几个方法的阅读经验，到了<code>set</code>就没什么好说了，此方法会先判断当前线程中的ThreadLocalMap对象是否已经初始化，如果是则保存ThreadLocal的值，否则通过<code>createMap</code>创建一个新的ThreadLocalMap对象保存到当前线程中，上述已经讲解过。</p><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后说下<code>remove</code>方法，它主要用于获取当前线程的ThreadLocalMap对象，并且从中移除当前ThreadLocal的值</p><h5 id="结构关系"><a href="#结构关系" class="headerlink" title="结构关系"></a>结构关系</h5><p>从我们的使用经验，以及对上面源码的阅读过程，现在可以发掘三个主要的类，分别是Thread、ThreadLocal、ThreadLocalMap。那么它们三者有什么关系呢？我们可以通过画图来说明：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191228/20191228130106.png" alt=""></p><p>从上面的图可以得出三条结论：</p><ul><li>每个线程都会一个ThreadLocalMap对象</li><li>每个ThreadLocalMap对象会存储多个ThreadLocal</li><li>每个ThreadLocal对象的存储方式其实是以对象自身作为key，其包装的value作为值</li></ul><p>很多时候使用ThreadLocal感到晕的主要原因在于其类结构和存储结构不一致，我们根据类结构画一张图：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191228/20191228132319.png" alt=""></p><p>这里的Entry即保存ThreadLocal的对象，它是ThreadLocalMap类的静态内部类；而ThreadLocalMap类又是ThreadLocal类的静态内部类。至于Thread对于ThreadLocal是依赖关系，也就是对其可用可不用。而Thread对于ThreadLocalMap则是聚合的关系，因为其内部含有一个ThreadLocalMap类型的属性。经过梳理，我们可以得出如下结论</p><ul><li>ThreadLocal即是一个辅助类用于保存线程局部变量，亦可作为一个存储key来使用</li><li>Entry则由ThreadLocal对象作为key，ThreadLocal包装的值作为value来构成</li></ul><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>由于ThreadLocal和多线程以及共享资源相关，稍有使用不当，可能会造成内存泄漏。要了解内存泄漏的原因需从ThreadLocal的存储说起。前面已经讲到过，ThreadLocalMap会存储多个ThreadLocal对象，而ThreadLocal对象并非直接存储在ThreadLocalMap中，而是由ThreadLocalMap的静态内部类Entry封装后再进行存储。我们先来看一下Entry类的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry类继承了WeakReference，所以理论上当虚拟机进行垃圾回收时，ThreadLocal对象会被回收掉。并且，当线程被销毁时，线程内的ThreadLocalMap生命周期也随之结束，因此不会产生内存泄漏。</p><p>然而实际应用中存在另一种情况，即线程可能会被线程池复用，而不被销毁。此时线程内ThreadLocalMap的生命周期会一直持续，即便部分使用弱引用作为key的ThreadLocal对象已经被销毁，但是其value却还在，并且无法被引用。长期运行下去，便有可能发生内存泄漏。要想预防内存泄漏的发生，那么最后每次在线程使用完ThreadLocal后，都调用它的<code>remove</code>方法清除其值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生活中往往会出现如下场景：家里只有一台电视，姐姐想看CCTV，弟弟想看AV。两个人为了电视互掐，你换我的频道，我换你的频道，谁也没法把一段节目完整看完。假设姐姐和弟弟分别是两条线程，电视是线程间共享的资源，那么此时便属于线程安全事故。解决线程安全问题的方法有很多，而其中一种是使用ThreadLocal。
    
    </summary>
    
    
      <category term="Java" scheme="https://linxiao.pro/categories/Java/"/>
    
    
      <category term="并发" scheme="https://linxiao.pro/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM探究-类加载机制</title>
    <link href="https://linxiao.pro/2019/12/22/jvm-classloader/"/>
    <id>https://linxiao.pro/2019/12/22/jvm-classloader/</id>
    <published>2019-12-22T09:53:38.000Z</published>
    <updated>2019-12-22T01:53:38.769Z</updated>
    
    <content type="html"><![CDATA[<p>编译器可以把Java代码编译成Class文件，Class文件描述了类中各种详细信息，但是它们都是静态的二进制码。通过虚拟机将Class文件加载到内存中，并对其数据进行连接和初始化，最终形成可以直接使用的类型，这一过程便称作虚拟机的类加载机制。<a id="more"></a></p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>任何一个类型在使用之前都将经历上述所说的三个类加载过程：加载、连接和初始化。一个类型在成功经历这三个步骤后便可被开发人员在程序中访问，它们被称作Class类型，通常用java.lang.class来表示。其中，在连接这一部分又分为：验证、准备和解析三个子步骤，如下图所示：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191219/20191219174109.png" alt=""></p><p>Class只有在必须要使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须进行初始化。这里指的使用，是指主动使用，主动使用只有下列几种情况：</p><ul><li>当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化</li><li>当调用类的静态方法时，即当使用了字节码invokestatic指令</li><li>当使用类或接口的静态字段时（final常量除外），比如，使用getstatic或者putstatic指令</li><li>当使用java.lang.reflect包中的方法反射类的方法时</li><li>当初始化子类时，要求初始化父类</li><li>作为启动虚拟机，含有main()方法的那个类</li></ul><p>除了以上的情况属于主动使用，其他的情况均属于被动调用。被动使用不会引起类的初始化。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p><code>加载</code>是<code>类加载</code>过程的第一个阶段，在加载阶段，虚拟机会完成以下工作：</p><ul><li>通过类的全名，获取类的二进制数据流</li><li>解析类的二进制数据流为方法区内的数据结构</li><li>创建java.lang.Class类的实例，表示该类型</li></ul><p>关于类的二进制数据流，虚拟机可以通过多种途径获得，比如class后缀的文件、从jar、zip包中提取或通过网络加载等等。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上看，验证阶段大致上会完成4个检验动作：文件格式验证、元数据验证、字节码验证、符合引用验证</p><h5 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h5><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，包括：</p><ul><li><p>是否以魔数0xCAFEBABE开头</p></li><li><p>主、次版本号是否在当前虚拟机处理范围内</p></li><li><p>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）</p></li><li><p>指向常量中的各种索引值中是否有指向不存在的常量或不符合类型的常量</p></li><li><p>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据</p></li><li><p>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</p><p>……</p></li></ul><p>此验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。</p><h5 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h5><p>对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，包括：</p><ul><li><p>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）</p></li><li><p>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</p></li><li><p>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</p></li><li><p>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）</p><p>……</p></li></ul><p>此阶段的主要目的是对类的元数据进行语义校验，保证不存在不符合Java语言规范的元数据信息。</p><h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><p>对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，包括：</p><ul><li><p>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。</p></li><li><p>保证跳转指令不会跳转到方法体以外的字节码指令上</p></li><li><p>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的</p><p>……</p></li></ul><p>此阶段的目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p><h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><p>符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，包括：</p><ul><li><p>符号引用中通过字符串描述的类名是否能找到对应的类</p></li><li><p>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</p></li><li><p>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问</p><p>……</p></li></ul><p>此阶段的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出异常。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>当成功经历验证阶段后，JVM接下来要做的事情就是对存放在方法区中类数据信息的类变量执行初始化，这里所执行的初始化操作并非是指加载阶段中的初始化操作，这里仅仅是为类中的所有静态变量分配内存空间，并未其设置一个初始值（由于还没有产生对象，因此实例变量将不在此操作范围内），而非用户手动执行赋值。</p><table><thead><tr><th>变量类型</th><th>初始值</th></tr></thead><tbody><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>在准备阶段完成后也就进入了解析阶段，解析阶段的工作就是将类、接口、字段和方法的符号引用转为直接引用。符号引用就是一些字面量的引用，和虚拟机的内部数据结构及内存无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但仅有符号引用是不够的，当我们需要调用一个类的方法的时候，就需要明确知道方法的位置。通过解析操作，可以将符号引用转化为直接引用，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类加载过程中的最后一个阶段就是初始化，在这个阶段中，JVM会将一个类所有被static关键字标示的代码统统执行一遍，如果执行的是静态变量，那么就会使用用户指定的值覆盖掉之前在准备阶段中JVM为其设置的初始值，当然如果程序中并没有为静态变量显示指定赋值操作，那么所持有的的值仍然是之前的初始值；反之，如果执行的是static代码块，那么在初始化阶段中，JVM就将会执行static代码块中定义的所有操作。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器是JVM执行类加载机制的前提，简单来说类加载器的主要任务就是根据一个类的全限定名来读取此类的二进制字节流到JVM内部，然后转换为一个与目标类对应的java.lang.Class对象实例。</p><p>从代码层面来看，类加载器ClassLoader是一个抽象类，它提供了一些重要的接口，用于自定义Class的加载流程和加载方式。ClassLoader的主要方法如下：</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>getParent()</td><td>返回该类加载器的父类加载器</td></tr><tr><td>loadClass(String name)</td><td>加载名称为name的类，返回结果为java.lang.Class类的实例</td></tr><tr><td>findClass(String name)</td><td>查找名称为name的类，返回结果为java.lang.Class类的实例</td></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td></tr><tr><td>defineClass(String name, byte[] b, int off, int len)</td><td>把字节数组b中的内容转换为一个Java类，返回结果为java.lang.Class类的实例</td></tr><tr><td>resolveClass(Class&lt;?&gt; c)</td><td>连接指定的一个Java类</td></tr></tbody></table><h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><p>在标准的Java程序中，Java虚拟机会创建3类ClassLoader为整个应用程序服务。它们分别是：BootStrap ClassLoader（启动类加载器）、Extension ClassLoader（扩展类加载器）和App ClassLoader（应用类加载器，也称为系统类加载器）。此外，每一个应用程序还可以拥有自定义的ClassLoader，扩展Java虚拟机获取Class数据的能力。</p><p>当系统需要使用一个类时，在判断类是否被加载时，会先从当前底层类加载器进行判断。当系统需要加载一个类时，会从顶层类开始加载，依次向下尝试，直到成功。</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191219/20191220101551.png" alt=""></p><p>我们可以通过代码获取当前所使用的类加载器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取应用类加载器</span></span><br><span class="line">        ClassLoader cl = ClassLoaderTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(cl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩展类加载器</span></span><br><span class="line">        cl = cl.getParent();</span><br><span class="line">        System.out.println(cl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取启动类加载器</span></span><br><span class="line">        cl = cl.getParent();</span><br><span class="line">        System.out.println(cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>由于我们并没有使用自定义类加载器，因此这里会直接由AppClassLoader开始打印。比较特别的是Bootstrap ClassLoader并没有打印出来，而是返回了null。这主要是因为其由C++编写并嵌套在Java虚拟机中，在Java层面没有对象可与之对应。</p><p>不同的类加载器加载的范围并不相同，如下表所示：</p><table><thead><tr><th>类加载器</th><th>加载范围</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME/lib目录中的所有类型，或者由选项-Xbootclasspath指定路径中的所有类型</td></tr><tr><td>ExtClassLoader</td><td>JAVA_HOME/lib/ext扩展目录中的所有类型，或者被java.ext.dirs系统变量指定路径中的所有类型</td></tr><tr><td>AppClassLoader</td><td>ClassPath目录中的所有类型</td></tr></tbody></table><p>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>在上图所描述的类加载器层级关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的方式来实现，而是都使用组合关系来复用父加载器的代码。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。使用双亲委派模型来组织类加载器之间的关系，有两个好处，一是确保每个类加载器都能加载自己范围内的类型；二是确保一个类不会被重复加载。它的主要实现代码都集中在java.lang.ClassLoader的loadClass()方法中，其逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">                <span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在父类加载器无法加载的时候</span></span><br><span class="line">                <span class="comment">// 再调用本身的findClass方法来进行类加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编译器可以把Java代码编译成Class文件，Class文件描述了类中各种详细信息，但是它们都是静态的二进制码。通过虚拟机将Class文件加载到内存中，并对其数据进行连接和初始化，最终形成可以直接使用的类型，这一过程便称作虚拟机的类加载机制。
    
    </summary>
    
    
      <category term="Java" scheme="https://linxiao.pro/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://linxiao.pro/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>linux系统编程-线程</title>
    <link href="https://linxiao.pro/2019/12/13/linux-programming-thread/"/>
    <id>https://linxiao.pro/2019/12/13/linux-programming-thread/</id>
    <published>2019-12-12T22:29:04.000Z</published>
    <updated>2019-12-12T14:29:04.169Z</updated>
    
    <content type="html"><![CDATA[<p>当你使用线程时，毫无疑问，你已经准备在刀刃上跳舞。线程的复杂度，以及不易调试等特性让绝大部分程序员望而却步。然而对于中大型应用程序来说，它又必不可少。线程是一项让人又爱又恨的技术，熟练运行线程解决复杂的并发问题，已经成为优秀程序员的基本素养之一。<a id="more"></a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h4><p>要了解什么是线程先要从进程说起。当磁盘上的一个二进制程序被加载到内存开始执行时，此时它就是一个进程。操作系统会为进程分配虚拟内存空间、文件描述符等资源，而CPU会将一个进程作为一个独立的任务来执行。一般而言，CPU在任一时刻只能执行一个任务，它会为每个任务分配一定的时间片，时间片耗完又开始另外一个任务。靠着高速的切换，你仿佛看到多个任务在并行运算，实际上并不是，这叫并发。但现代CPU工艺较高，通常我们所说的4核8线，实际上是真的能同时运行4个进程，8条线程，这是真正意义上的并行运算。</p><h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><p>说到线程，它是操作系统所能调度的最小执行单位，也就是说真正干活的是线程，而进程仅仅是作为资源分配的基本单位。但是线程并不能独立存在，它被包含在进程之中。一个进程至少有一个或多个线程，它们会共享进程的内存空间。</p><h4 id="为什么使用线程"><a href="#为什么使用线程" class="headerlink" title="为什么使用线程"></a>为什么使用线程</h4><p>其实多进程编程模式就已经能够实现并发任务，那为何还需要多线程呢？一个最主要的理由就是降低性能开销。多进程的性能开销主要来源于两方面：首先当使用<code>fork</code>时会复制父进程的整块内存空间，虽然后续有写时复制这种优化技术，但复制本身就已经浪费性能；其次，多进程之间的通信复杂而繁琐，带来性能开销的同时还增加了工作量。而线程很好的解决了这两点，由于线程是共享进程的内存空间，所以不存在复制这一说。同样，也是由于这一特性，线程之间的通信直接使用进程中的内存数据就好，而不需要采用其他手段。因此，线程也被称之为轻量级进程。</p><h4 id="线程带来的问题"><a href="#线程带来的问题" class="headerlink" title="线程带来的问题"></a>线程带来的问题</h4><p>虽然多线程解决了多进程存在的性能开销问题，但与此同时它也带来了许多新问题。所谓是它的优点也正是它的缺点，当涉及到多个线程共享内存时就会引发数据竞争。举个例子，假设你卡里有2W块钱，你正准备在苹果店刷一台1.8W的MacBook。而你的老婆支付宝也绑定了这张银行卡，好巧不巧，她正下单买件5000块的大衣。两人在同一时刻消费了2.3W，等于说银行还要倒贴你3000块。除了数据竞争，有时候还会引发死锁。再举个例子，狭窄的路上有两辆汽车针锋相对，A车等B先让，B车等A先让，两人都在争夺道路资源谁也不让谁，这就是死锁现象。通常情况下，我们所使用的线程库为解决这些问题提供了一系列方法，包括：互斥锁、信号量、条件变量等等，这些会放到后面再讲。</p><h4 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h4><p>Linux系统并没有直接提供多线程相关的系统调用，且不同编程语言都有各自的多线程实现方案。在Linux环境系统编程中比较通用C和C++线程解决方案是POSIX线程，或简称Pthreads。它定义了一套C语言的类型、函数与常量，这些内容被包含在<code>pthread.h</code>中。Pthreads API提供了100多个接口，全部以<code>pthread_</code>开头，它们大致可以划分为四类：</p><ul><li>线程管理    用于创建、分离、连接等。它们还包括设置/查询线程属性（可连接，调度等）</li><li>互斥    用于管理同步，包括创建、销毁、锁定和解锁互斥，以及设置互斥锁相关的属性</li><li>条件变量    用于处理共享互斥锁的线程之间的通信，可针对指定变量进行创建、销毁、等待和发出信号，也包括对变量属性进行设置</li><li>同步    用于管理读/写锁和屏障</li></ul><p>我们可以通过函数名称前缀来识别函数所代表的功能：</p><table><thead><tr><th align="left">前缀</th><th>功能</th></tr></thead><tbody><tr><td align="left">pthread_</td><td>线程本身相关函数</td></tr><tr><td align="left">pthread_attr_</td><td>线程属性对象</td></tr><tr><td align="left">pthread_mutex_</td><td>互斥锁</td></tr><tr><td align="left">pthread_mutexattr_</td><td>互斥锁属性对象</td></tr><tr><td align="left">pthread_cond_</td><td>条件变量</td></tr><tr><td align="left">pthread_condattr_</td><td>条件变量属性对象</td></tr><tr><td align="left">pthread_key_</td><td>线程数据键</td></tr><tr><td align="left">pthread_rwlock_</td><td>读写锁</td></tr><tr><td align="left">pthread_barrier_</td><td>同步屏障</td></tr></tbody></table><p>通常情况下，你可以通过<code>man</code>手册查询到这些函数的定义和使用方法，如果函数说明不全，则需要安装手册页。如在我的系统Ubuntu中可使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install manpages-posix manpages-posix-dev</span><br></pre></td></tr></table></figure><p>此外POSIX的信号量<code>Semaphore API</code>可以与Pthreads协同工作，但这并不是Pthreads的标准。因而这部分API是以<code>sem_</code>打头，而非<code>pthread_</code>。关于信号量的内容会放到后面说明。</p><p>当C代码中使用了<code>pthread.h</code>头文件后，那么在编译时应该链接pthread函数库，编译方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc pthread_demo.c -o pthread_demo -lpthread</span><br></pre></td></tr></table></figure><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="创建简单线程"><a href="#创建简单线程" class="headerlink" title="创建简单线程"></a>创建简单线程</h4><p>我们先看一个创建线程的例子，再针对示例进行讲解。在示例中，我们会创建一个新线程，并给该线程传参，当新线程开始运行后打印自己的线程ID和传入的附加信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"新线程ID：%ld\n"</span>, pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"线程附加信息:%s\n"</span>, (<span class="keyword">char</span> *) arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pt;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * str = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前线程ID：%ld\n"</span>, pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始创建新线程...\n"</span>);</span><br><span class="line">    ret = pthread_create(&amp;pt, <span class="literal">NULL</span>, start_thread, (<span class="keyword">void</span> *)str);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    pthread_join(pt, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"新线程运行结束\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当前线程ID：139680535287616</span><br><span class="line">开始创建新线程...</span><br><span class="line">新线程ID：139680535283456</span><br><span class="line">线程附加信息:hello world</span><br><span class="line">新线程运行结束</span><br></pre></td></tr></table></figure><p>可以看到，上面的代码用到了三个函数，<code>pthread_self</code>用于输出当前线程ID，<code>pthread_join</code>和进程的<code>wait</code>类似，用于等待线程结束运行。而关键点在<code>pthread_create</code>，它用于创建新的线程。其定义如下：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191211134806.png" alt=""></p><ul><li>thread    创建成功后用于保存线程唯一表示，它是一个无符号长整形</li><li>attr    用于改变所创建的新线程的属性，如果传NULL则采用默认属性</li><li>start_route    创建成功后开始执行的线程函数指针</li><li>arg    给新线程传递的参数，可以为NULL</li></ul><p>需要注意的地方有两点：一是传递给线程运行的函数必须满足返回值和参数的类型均为<code>void *</code>；二是向线程传递的参数必须强转为<code>void *</code>，当需要在线程中使用时，可从上面说的函数参数中取出并强转回去，这也就意味着线程支持任意类型的传参，但通常情况下，如果有复杂类型，会传递结构体。</p><p>当创建成功时，该函数会返回0，否则返回错误值。</p><h4 id="为线程设置属性"><a href="#为线程设置属性" class="headerlink" title="为线程设置属性"></a>为线程设置属性</h4><p>默认情况下，创建线程时会为我们设定一些特定属性，这些属性已经足够我们使用，此时只需要将<code>attr</code>参数传NULL即可。但是，如有特殊情况，我们也可以在创建线程时主动设置属性。而<code>pthread_attr_init</code>和<code>pthread_attr_destroy</code>函数用于初始化/销毁线程属性信息，我们先看定义：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191211154652.png" alt=""></p><p>此外还有一些函数用于查询和设置线程相关的属性，其中包括：</p><ul><li>分离和连接状态</li><li>调度继承</li><li>调度策略</li><li>调度竞争范围</li><li>堆栈大小</li><li>堆栈地址</li><li>堆栈保护（溢出）大小</li></ul><p>详细可翻阅文档，这些函数在调用成功时都会返回0，失败时返回一个非0的错误码。下面我们通过一个例子来演示修改线程堆栈大小，通常情况下，在一些嵌入式或内存空间较小的设备上，这么做很有意义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> stack_size;</span><br><span class="line">    pthread_attr_getstacksize(&amp;attr, &amp;stack_size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"线程堆栈大小修改为:%ld字节\n"</span>, stack_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化线程属性</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> attr_ret;</span><br><span class="line">    attr_ret = pthread_attr_setstacksize(&amp;attr, <span class="number">1024000</span>);</span><br><span class="line">    <span class="keyword">if</span> (attr_ret != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pthread_attr_setstacksize"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> pt;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;pt, &amp;attr, start_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    pthread_join(pt, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 销毁线程属性</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程堆栈大小修改为:1024000字节</span><br></pre></td></tr></table></figure><h4 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h4><p>获取线程ID的函数在前面其实已经使用过了</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191211160246.png" alt=""></p><p>该函数会返回调用线程的线程ID，且不会有失败的可能。</p><h4 id="比较线程ID"><a href="#比较线程ID" class="headerlink" title="比较线程ID"></a>比较线程ID</h4><p>由于Pthread标准不需要<code>pthread_t</code>是个算数类型，因此不能确保等号可以正常工作。为了比较线程ID，Pthread库提供了一个特定接口</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191211160836.png" alt=""></p><p>当两个线程ID相同返回一个非0值，否则返回0，同样该函数也不会有调用失败的可能。</p><h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>和创建线程对应的是终止线程。线程终止和进程终止很类似，差别在于当线程终止时，进程中的其他线程会继续运行。线程会在某些情况下终止，所有这些情况都和进程终止类似：</p><ul><li>如果线程返回，该线程就结束。这和main函数结束有点类似</li><li>如果线程调用了<code>pthread_exit</code>函数，它就会终止，这和调用<code>exit</code>返回类似</li><li>如果线程是被另一个线程通过<code>pthread_cancel</code>函数取消，它就会终止。这和通过<code>kill</code>发送SIGKILL信号类似</li></ul><p>这三个示例都只会杀死有问题的线程。在以下场景中，进程中的所有线程都被杀死，因此整个进程被杀死：</p><ul><li>进程从<code>main</code>函数返回</li><li>进程通过<code>exit</code>函数终止</li><li>进程通过<code>exec</code>执行新的二进制程序</li></ul><h4 id="线程自杀"><a href="#线程自杀" class="headerlink" title="线程自杀"></a>线程自杀</h4><p>最简单的线程自杀方式是直接使用<code>return</code>返回，而Pthreads提供了<code>pthread_exit</code>函数</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191211175449.png" alt=""></p><p>此函数会终止调用线程，并通过<code>retval</code>返回一个值，如果线程是可连接的（joinable)，则该值可用于<code>pthread_join</code>，前提是调用<code>pthread_join</code>的线程与终止的线程位于同一进程中。以下代码演示了如何在子线程中终止自己，并返回消息给主线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"线程退出\n"</span>);</span><br><span class="line">    pthread_exit(<span class="string">"goodbye"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pt;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;pt, <span class="literal">NULL</span>, start_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">char</span> **retval;</span><br><span class="line">    pthread_join(pt, (<span class="keyword">void</span> *)retval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *retval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程退出</span><br><span class="line">goodbye</span><br></pre></td></tr></table></figure><h4 id="终止其他线程"><a href="#终止其他线程" class="headerlink" title="终止其他线程"></a>终止其他线程</h4><p>线程可以通过调用<code>pthread_cancel</code>来向其他线程发送取消请求</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191211181711.png" alt=""></p><p>调用成功<code>pthread_cancel</code>函数会将取消请求发送到参数<code>thread</code>所表示的目标线程中。目标线程是否以及何时响应取消请求取决于该线程控制的两个属性：可取消状态和类型。成功时，<code>pthread_cancel</code>会返回0。注意，返回成功只是表示成功执行取消请求，而实际的取消操作是异步的。出错时，返回一个非0的错误码。</p><p><code>pthread_setcancelstate</code>用于设置线程的可取消状态为开启或禁用，新线程默认为开启，即允许取消。如果线程不允许取消，则取消请求会加入到队列，直到允许取消。如果线程允许取消，则其取消类型会决定何时发生取消。</p><p><code>pthread_setcanceltype</code>用于设置线程的取消类型，它可以是异步的，也可以是延迟的（deferred），默认是后者。异步取消意味着线程可能随时被取消（通常是立即取消线程，但系统不做保证），如果线程此时在操作共享数据被终止，那么可能会造成数据的不完整。延迟取消意味着取消将被延迟到线程下一次的安全调用。</p><p>以下是这两个函数的定义：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191211183614.png" alt=""></p><p>参数<code>state</code>的可选值有<code>PTHREAD_CANCEL_ENABLE</code>或<code>PTHREAD_CANCEL_DISABLE</code>，分别表示允许取消和不允许取消。调用成功时，取消状态将被设为<code>state</code>的值，并将老的状态保存到<code>oldstate</code>中，返回0。出错时，返回一个非0的错误码。</p><p>参数<code>type</code>的可选参数有<code>PTHREAD_CANCEL_ASYNCHRONOUS</code>或<code>PTHREAD_CANCEL_DEFERRED</code>，分别表示异步和延迟。调用成功时，取消类型将被设为<code>type</code>的值，并将老的类型保存到<code>oldtype</code>中，返回0。出错时，返回一个非0的错误码。</p><p>以下我们通过代码来演示，将子线程的可取消状态设为开启，并将取消类型设为延迟，接着在主线程中发送取消请求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pthread_setcancelstate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pthread_setcanceltype"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"睡一会儿...\n"</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pt;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;pt, <span class="literal">NULL</span>, start_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    pthread_cancel(pt);</span><br><span class="line"></span><br><span class="line">    pthread_join(pt, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">睡一会儿...</span><br><span class="line">睡一会儿...</span><br><span class="line">睡一会儿...</span><br><span class="line">睡一会儿...</span><br><span class="line">睡一会儿...</span><br></pre></td></tr></table></figure><p>子线程每隔2秒会输出一次，而主线程在10秒后发送的取消请求，因此上面一共输出了5句</p><h4 id="线程清理"><a href="#线程清理" class="headerlink" title="线程清理"></a>线程清理</h4><p>上面我们讲到如何终止线程，事实上无论是被其他线程请求取消也好还是线程自我了结也好，总有些清理工作需要做，这就类似于退出进程时使用的<code>atexit</code>注册的清理函数，线程也有类似的做法</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191211192230.png" alt=""></p><p>这两个函数用于操作调用线程的清理函数堆栈，清理函数是在取消线程时自动执行的。<code>pthread_cleanup_push</code>会将清理函数推向清理函数栈的顶部，参数<code>routine</code>为清理函数的指针，<code>arg</code>为传递给清理函数的参数。<code>pthread_cleanup_pop</code>用于删除位于清理函数栈顶部的函数，如果传递的执行参数<code>execute</code>非0，则会执行该函数。</p><h5 id="正常退出时清理"><a href="#正常退出时清理" class="headerlink" title="正常退出时清理"></a>正常退出时清理</h5><p>下面通过代码来演示子线程在正常退出时，如何执行清理操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"clean up:%s\n"</span>, (<span class="keyword">char</span> *)arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    pthread_cleanup_push(cleanup, (<span class="keyword">void</span> *)<span class="string">"first"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup, (<span class="keyword">void</span> *)<span class="string">"second"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count++ &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"睡一会儿...\n"</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pt;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;pt, <span class="literal">NULL</span>, start_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(pt, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">睡一会儿...</span><br><span class="line">睡一会儿...</span><br><span class="line">睡一会儿...</span><br><span class="line">clean up:second</span><br></pre></td></tr></table></figure><p>可以看到，最后打印的是第二个push进清理函数栈的函数的输出，这刚好符合栈的这一特性。之所以执行了栈顶第一个函数而没有执行栈顶第二个函数，是因为在调用<code>pthread_cleanup_pop</code>的时候，第一次执行参数为1，第二次为0。需要注意的是，<code>return NULL</code>不能放置在<code>pthread_cleanup_push</code>和<code>pthread_cleanup_pop</code>直接，否则线程会直接退出，而不会执行清理任务。</p><h5 id="被请求取消时清理"><a href="#被请求取消时清理" class="headerlink" title="被请求取消时清理"></a>被请求取消时清理</h5><p>下面来演示子线程正在长时间运行，而被主线程请求取消时，如何执行清理工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"clean up:%s\n"</span>, (<span class="keyword">char</span> *)arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    pthread_cleanup_push(cleanup, (<span class="keyword">void</span> *)<span class="string">"first"</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup, (<span class="keyword">void</span> *)<span class="string">"second"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count++ &lt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"睡一会儿...\n"</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pt;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;pt, <span class="literal">NULL</span>, start_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    pthread_cancel(pt);</span><br><span class="line"></span><br><span class="line">    pthread_join(pt, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">睡一会儿...</span><br><span class="line">睡一会儿...</span><br><span class="line">clean up:second</span><br><span class="line">clean up:first</span><br></pre></td></tr></table></figure><p>可以看到，当子线程还在while循环中工作时，由于收到取消请求，相继执行了清理函数栈中的函数。</p><h3 id="连接和分离线程"><a href="#连接和分离线程" class="headerlink" title="连接和分离线程"></a>连接和分离线程</h3><p>通常情况下，在子线程执行结束后，依然会占用一些系统资源，比如堆栈等。只有当线程被连接或分离后，其资源才能正确被释放。</p><h4 id="join-连接"><a href="#join-连接" class="headerlink" title="join 连接"></a>join 连接</h4><p><code>join</code>用于等待一个线程终止</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191211203817.png" alt=""></p><p>调用成功会返回0，调用线程会被阻塞，直到由<code>thread</code>指定的目标线程终止，如果目标线程已经终止，<code>pthread_join</code>会立即返回。一旦函数返回，调用线程就会被唤醒，然后继续执行。如果<code>retval</code>值不为NULL，被等待线程传递给<code>pthread_exit</code>函数的值就会放到<code>retval</code>中。当调用失败，则会返回一个非0的错误码。其实之前的示例代码已经多次用到过<code>pthread_join</code>，下面再写一个简单例子来演示一遍：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"子线程运行\n"</span>);</span><br><span class="line">    pthread_exit(<span class="string">"子线程已退出"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pt;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;pt, <span class="literal">NULL</span>, start_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> **str;</span><br><span class="line">    pthread_join(pt, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子线程运行</span><br><span class="line">子线程已退出</span><br></pre></td></tr></table></figure><h4 id="detach-分离"><a href="#detach-分离" class="headerlink" title="detach 分离"></a>detach 分离</h4><p>虽然join可以等待子线程执行完并回收其资源，但是对于某些需要长时间运行的任务来说，一个线程阻塞去等待另一个线程是得不偿失的。为了同样能达到线程资源回收效果，而无需等待，这时可以分离线程</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191211212029.png" alt=""></p><p>调用成功时，<code>pthread_detach</code>会分离由<code>thread</code>指定的目标线程，并返回0。如果在一个已经分离的线程上调用<code>pthread_detach</code>，那么结果是未知的。出错时，返回一个非0的错误码。以下代码演示了如何分离一个线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"子线程结束运行\n"</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pt;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;pt, <span class="literal">NULL</span>, start_thread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_detach(pt);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"主线程结束运行\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子线程结束运行</span><br><span class="line">主线程结束运行</span><br></pre></td></tr></table></figure><p>为了模拟出主线程可继续执行自己的任务，且能看到子线程的执行结果，这里在主线程中添加休眠5秒。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>在了解互斥锁之前，我们先来写一个经典的卖票程序。假设现在有10张票，线程A和线程B同时在卖，直到卖完为止。来看看会出现什么效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADS_NUM 2</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 休眠是为了让CPU有机会执行其他线程</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s卖出一张票，还剩%d张\n"</span>, (<span class="keyword">char</span> *)arg, --tickets);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[THREADS_NUM];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *thread_name[] = &#123;<span class="string">"线程A"</span>, <span class="string">"线程B"</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_NUM; ++i) &#123;</span><br><span class="line">        ret = pthread_create(&amp;threads[i], <span class="literal">NULL</span>, start, thread_name[i]);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(threads[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(threads[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">线程A卖出一张票，还剩9张</span><br><span class="line">线程B卖出一张票，还剩8张</span><br><span class="line">线程A卖出一张票，还剩7张</span><br><span class="line">线程B卖出一张票，还剩6张</span><br><span class="line">线程B卖出一张票，还剩5张</span><br><span class="line">线程A卖出一张票，还剩4张</span><br><span class="line">线程B卖出一张票，还剩3张</span><br><span class="line">线程A卖出一张票，还剩2张</span><br><span class="line">线程B卖出一张票，还剩1张</span><br><span class="line">线程A卖出一张票，还剩0张</span><br><span class="line">线程B卖出一张票，还剩-1张</span><br></pre></td></tr></table></figure><p>经过反复验证输出，发现时不时会出现还剩-1张票的情况，这显然不合逻辑。我们可以分析一下出现这种情况的原因：</p><ol><li>当还剩1张票的时候，线程A进入循环，开始休眠</li><li>此时线程B也发现还剩1张票，于是也进入循环开始休眠</li><li>线程A被唤醒，然后卖出1张票，此时还剩0张</li><li>线程B此时也被唤醒，然后卖出1张票，此时就成了剩-1张</li></ol><p>其实产生这个问题的根本原因在于发生了数据竞争，即同一份数据在同一时刻被多个线程同时读写。所以说，如果我们能保证在同一时刻只有一条线程能读写共享的数据，那么问题就能得到解决。这时我们可以考虑当线程在访问数据之前给数据上一把锁，只允许一条线程访问，在读写完数据后再把锁打开，允许其他线程访问。如果把线程比作人，数据比作厕所的话，那么这里的锁即是互斥锁。</p><p>互斥锁主要用于保护共享数据结构不受并发修改的影响，它通常由两种可能的状态：解锁（不属于任何线程）和锁定（由一个线程拥有）。互斥锁永远不能同时被两个不同的线程拥有。若一个线程试图锁定已被另一个线程锁定的互斥锁，那么该线程会被挂起，直到拥有互斥锁的线程先将互斥锁解锁。</p><h4 id="初始化和销毁"><a href="#初始化和销毁" class="headerlink" title="初始化和销毁"></a>初始化和销毁</h4><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191212091616.png" alt=""></p><p>互斥锁使用<code>pthread_mutex_t</code>对象表示，你可以通过<code>pthread_mutex_init</code>函数对其进行初始化，<code>attr</code>表示初始化时所使用的属性，如果传NULL则使用默认属性。当然你也可以直接使用<code>PTHREAD_MUTEX_INITIALIZER</code>对一个互斥锁进行初始化。而<code>pthread_mutex_destroy</code>则用于销毁互斥锁。调用成功时，这两个函数返回0，否则返回一个非0的错误码。</p><h4 id="加锁和解锁"><a href="#加锁和解锁" class="headerlink" title="加锁和解锁"></a>加锁和解锁</h4><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191212094804.png" alt=""></p><p><code>pthread_mutex_lock</code>用于锁定给定的互斥锁。如果互斥锁当前处于解锁状态，则它将被调用线程锁定并拥有，然后<code>pthread_mutex_lock</code>立即返回。如果互斥锁已经被另一个线程锁定，<code>pthread_mutex_lock</code>将阻塞调用线程，直到互斥锁被解锁。</p><p><code>pthread_mutex_trylock</code>的行为与<code>pthread_mutex_lock</code>相同，不同之处在于，如果互斥锁已被另一个线程锁定，那么它不会阻塞调用线程。相反，它会立即返回错误代码EBUSY。</p><p><code>pthread_mutex_unlock</code>用于解锁给定的互斥锁。</p><p>以上函数调用成功时均返回0，否则返回非0的错误码。下面我们对之前卖票的程序进行修改，用互斥锁锁定共享数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADS_NUM 2</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 休眠是为了让CPU有机会执行其他线程</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s卖出一张票，还剩%d张\n"</span>, (<span class="keyword">char</span> *)arg, --tickets);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当票售完时需解锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环终止时也需解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[THREADS_NUM];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *thread_name[] = &#123;<span class="string">"线程A"</span>, <span class="string">"线程B"</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_NUM; ++i) &#123;</span><br><span class="line">        ret = pthread_create(&amp;threads[i], <span class="literal">NULL</span>, start, thread_name[i]);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(threads[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(threads[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对共享数据的读写加锁后，就不会存在并发修改异常。但上面的代码依然有两个地方需要注意：</p><ul><li>加锁后，所有有可能退出循环体的地方都必须解锁，不然会有线程阻塞</li><li>由于我们对整个循环体进行了加锁，数据量太小可能无法模拟出线程切换效果，此时增大基数就好</li></ul><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>在学习条件变量前我们先变更下上面卖票程序的需求：</p><ul><li>现有一个票池，用于存放所有票据</li><li>主线程每隔一段时间发放新票到票池中，两个子线程分别从票池中拿票进行售卖</li><li>当票池中的票卖完后，子线程结束，进程退出</li></ul><p>经过分析可见以上需求的关键点在于，如果票池有票，子线程还能正常售卖。若票池已经无票，主线程放出新票到票池后，此时如何提醒子线程可以正常售卖？你可能会想到轮询，即写一个死循环，不断去判断票池内的票数。但这样未免效率太低下。合理的做法应当是子线程被阻塞，等待主线程的通知，再重新售卖。这样一个通知机制，就是我们所说的条件变量。</p><p>条件变量是一种同步设备，它允许线程暂停执行并放弃处理器，直到共享数据上的某个条件得到满足。条件变量的基本操作是：向条件发出信号，然后等待条件，暂停线程执行，直到另一个线程发出条件信号为止。一个条件变量必须始终与互斥锁相关联，以避免线程准备等待一个条件变量时，另一个线程也开始等待相同的条件，从而引发的竞争关系。</p><h4 id="初始化和销毁-1"><a href="#初始化和销毁-1" class="headerlink" title="初始化和销毁"></a>初始化和销毁</h4><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191212150844.png" alt=""></p><p>条件变量用<code>pthread_cond_t</code>对象来表示。函数<code>pthread_cond_init</code>使用<code>attr</code>中指定的条件属性来初始化条件变量<code>cond</code>，如果<code>attr</code>为NULL，则使用默认属性。此外也可以使用<code>PTHREAD_COND_INITIALIZER</code>来静态初始化条件变量。而<code>pthread_con_destroy</code>用于销毁一个条件变量，释放它可能持有的资源。</p><h4 id="等待和唤醒"><a href="#等待和唤醒" class="headerlink" title="等待和唤醒"></a>等待和唤醒</h4><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191212152633.png" alt=""></p><p><code>pthread_cond_wait</code>用于等待条件变量<code>cond</code>发出信号，它会阻塞调用线程，但是在条件变量发出信号前不消耗任何CPU时间。<code>pthread_cond_timedwait</code>与<code>pthread_cond_wait</code>一样，唯一的区别是它限制了由结构体<code>timespec</code>表示的等待时间。</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191212152712.png" alt=""></p><p><code>pthread_cond_signal</code>会唤醒在条件变量<code>cond</code>上等待的线程之一。如果没有线程等待<code>cond</code>，则什么也不会发生。如果有多个线程在<code>cond</code>上等待，则仅会唤醒一个线程，但并未指定哪个线程。而<code>pthread_cond_broadcast</code>会唤醒所有在条件变量<code>cond</code>上等待的线程。如果没有线程等待<code>cond</code>，则也不会发生任何事情。</p><p>以上这些函数在调用成功时均返回0，出错时返回非0的错误码。下面我们来演示刚刚所说的程序，在主线程产生票源，子线程进行售卖：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADS_NUM 2</span></span><br><span class="line"><span class="comment">// 默认先将票数初始化为0</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 标记票源是否卖完</span></span><br><span class="line"><span class="keyword">int</span> sold_out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">// 初始化条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 有票的情况下继续售卖</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s卖出1张, 还剩%d张\n"</span>, (<span class="keyword">char</span> *)arg, --tickets);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sold_out == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 当票源清空时，释放互斥锁，并准备退出线程</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无票的情况下阻塞线程，等待唤醒</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 休眠1秒以让出CPU给其他线程执行</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[THREADS_NUM];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *thread_name[] = &#123;<span class="string">"线程A"</span>, <span class="string">"线程B"</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_NUM; ++i) &#123;</span><br><span class="line">        ret = pthread_create(&amp;threads[i], <span class="literal">NULL</span>, start, thread_name[i]);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 修改票数时需给共享数据加锁,以防止和子线程产生竞争</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 此处用一个伪随机数来表示释放的新票数</span></span><br><span class="line">        <span class="keyword">new</span> = rand() % <span class="number">10</span>;</span><br><span class="line">        tickets += <span class="keyword">new</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"新发%d张票, 票池共%d张...........\n"</span>, <span class="keyword">new</span>, tickets);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 唤醒所有线程开始售票</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 票源清空时，设置标记，留给子线程判断用</span></span><br><span class="line">    sold_out = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pthread_join(threads[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(threads[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="comment">// 销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">新发3张票, 票池共3张...........</span><br><span class="line">线程A卖出1张, 还剩2张</span><br><span class="line">线程B卖出1张, 还剩1张</span><br><span class="line">线程B卖出1张, 还剩0张</span><br><span class="line">新发6张票, 票池共6张...........</span><br><span class="line">线程B卖出1张, 还剩5张</span><br><span class="line">线程B卖出1张, 还剩4张</span><br><span class="line">线程A卖出1张, 还剩3张</span><br><span class="line">线程B卖出1张, 还剩2张</span><br><span class="line">线程A卖出1张, 还剩1张</span><br><span class="line">新发7张票, 票池共8张...........</span><br><span class="line">线程A卖出1张, 还剩7张</span><br><span class="line">线程B卖出1张, 还剩6张</span><br><span class="line">线程B卖出1张, 还剩5张</span><br><span class="line">线程A卖出1张, 还剩4张</span><br><span class="line">线程A卖出1张, 还剩3张</span><br><span class="line">线程B卖出1张, 还剩2张</span><br><span class="line">新发5张票, 票池共7张...........</span><br><span class="line">线程A卖出1张, 还剩6张</span><br><span class="line">线程B卖出1张, 还剩5张</span><br><span class="line">线程B卖出1张, 还剩4张</span><br><span class="line">线程A卖出1张, 还剩3张</span><br><span class="line">线程B卖出1张, 还剩2张</span><br><span class="line">线程A卖出1张, 还剩1张</span><br><span class="line">新发3张票, 票池共4张...........</span><br><span class="line">线程B卖出1张, 还剩3张</span><br><span class="line">线程A卖出1张, 还剩2张</span><br><span class="line">线程A卖出1张, 还剩1张</span><br><span class="line">线程B卖出1张, 还剩0张</span><br></pre></td></tr></table></figure><p>由此可见，票池不时会有新票释出，而子线程则会分别进行售卖，直至卖光后线程各自终止。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量并不属于Pthread标准，但它可用于管理可同时访问共享资源的线程数。打个比方，信号量就像是一串备用钥匙，但是数量有限，只有拥有了钥匙的人（线程）才能进去房间（访问共享资源）。当房间里的人出来后，会归还钥匙，此时另外一个人就可以拿到钥匙进去。 但是，同时进去房间里的人数是一定的，其他人必须等待。</p><p>信号量是一个数值，当一个线程访问共享资源时，它必须得到一个信号量，获取信号量的操作会将信号量的值减1。如果当前信号量的值为0，那么调用线程无法获取到信号量，此时它将被阻塞，直到有其他线程释放信号量为止（信号量的值加1）。如果信号量只有0和1两种值，此时它就是一个互斥锁 。</p><h4 id="初始化和销毁-2"><a href="#初始化和销毁-2" class="headerlink" title="初始化和销毁"></a>初始化和销毁</h4><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191212215423.png" alt=""></p><p><img src="C:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191212220122497.png" alt="image-20191212220122497"></p><p>信号量对象用<code>set_t</code>类型表示，它通过<code>set_init</code>函数初始化。当参数<code>pshared</code>为非0值时，表示信号量可以在进程间共享，参数<code>value</code>用于设置信号量的初始值。而<code>sem_destroy</code>函数用于销毁信号量。</p><h4 id="锁定和解锁"><a href="#锁定和解锁" class="headerlink" title="锁定和解锁"></a>锁定和解锁</h4><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191212220653.png" alt=""></p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191211/20191212220735.png" alt=""></p><p> <code>sem_wait</code>用于递减（锁定）<code>sem</code>指向的信号量，如果信号量的值大于0，则递减后继续运行，函数立即返回。如果信号量当前的值为0，那么调用就会阻塞，直到信号量的值被其他线程恢复到0以上。<code>sem_trywait</code>与<code>sem_wait</code>功能相同，唯一的区别在于当无法递减（锁定）信号量时，它会立即返回错误，而不是阻塞。至于<code>sem_timedwait</code>则是设定了阻塞的时间限制。</p><p><code>sem_post</code>用于递增（解锁）<code>sem</code>指向的信号量。如果信号量的值因此大于0，那么在<code>sem_wait</code>调用中阻塞的另一个线程将会被唤醒并继续锁定信号量。</p><p>以上介绍的这些信号量相关函数在调用成功时会返回0，失败时返回-1，并设置相应的errno值。下面我们通过一段代码来演示如何利用信号量模拟互斥锁，我们将对互斥锁小节中多线程卖票的程序进行修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADS_NUM 2</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 休眠是为了让CPU有机会执行其他线程</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 锁定信号量</span></span><br><span class="line">        sem_wait(&amp;sem);</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s卖出一张票，还剩%d张\n"</span>, (<span class="keyword">char</span> *)arg, --tickets);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当票售完时需解锁</span></span><br><span class="line">            sem_post(&amp;sem);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环终止时也需解锁</span></span><br><span class="line">        sem_post(&amp;sem);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量，并设置初始值为1，即只允许一条线程访问共享资源</span></span><br><span class="line">    sem_init(&amp;sem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[THREADS_NUM];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *thread_name[] = &#123;<span class="string">"线程A"</span>, <span class="string">"线程B"</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_NUM; ++i) &#123;</span><br><span class="line">        ret = pthread_create(&amp;threads[i], <span class="literal">NULL</span>, start, thread_name[i]);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"pthread_create"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(threads[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(threads[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线程B卖出一张票，还剩9张</span><br><span class="line">线程A卖出一张票，还剩8张</span><br><span class="line">线程B卖出一张票，还剩7张</span><br><span class="line">线程A卖出一张票，还剩6张</span><br><span class="line">线程B卖出一张票，还剩5张</span><br><span class="line">线程A卖出一张票，还剩4张</span><br><span class="line">线程B卖出一张票，还剩3张</span><br><span class="line">线程A卖出一张票，还剩2张</span><br><span class="line">线程A卖出一张票，还剩1张</span><br><span class="line">线程B卖出一张票，还剩0张</span><br></pre></td></tr></table></figure><p>可见，使用信号量模拟的互斥锁并没有造成共享数据的并发修改异常。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a></p><p><a href="https://computing.llnl.gov/tutorials/pthreads/" target="_blank" rel="noopener">POSIX Threads Programming</a></p><p><a href="http://homes.dsi.unimi.it/~boccignone/GiuseppeBoccignone_webpage/MatDidatSOD2009_files/pthread-Tutorial.pdf" target="_blank" rel="noopener">pthread Tutorial</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-pthred/index.html" target="_blank" rel="noopener">pthreads 的基本用法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你使用线程时，毫无疑问，你已经准备在刀刃上跳舞。线程的复杂度，以及不易调试等特性让绝大部分程序员望而却步。然而对于中大型应用程序来说，它又必不可少。线程是一项让人又爱又恨的技术，熟练运行线程解决复杂的并发问题，已经成为优秀程序员的基本素养之一。
    
    </summary>
    
    
      <category term="Linux" scheme="https://linxiao.pro/categories/Linux/"/>
    
    
      <category term="C" scheme="https://linxiao.pro/tags/C/"/>
    
      <category term="系统编程" scheme="https://linxiao.pro/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://linxiao.pro/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>linux系统编程-信号</title>
    <link href="https://linxiao.pro/2019/12/10/linux-programming-signal/"/>
    <id>https://linxiao.pro/2019/12/10/linux-programming-signal/</id>
    <published>2019-12-10T11:53:15.000Z</published>
    <updated>2019-12-10T03:53:15.714Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们习惯于在Linux系统中使用<code>Ctrl+c</code>结束一个当前正在运行的进程，而这一操作实质上是对进程发送了一个终止信号。什么是信号呢？它是一种简单的异步通信机制，用于向进程发送通知。<a id="more"></a></p><h3 id="信号基本概念"><a href="#信号基本概念" class="headerlink" title="信号基本概念"></a>信号基本概念</h3><p>信号的来源有很多，比如：</p><ul><li>终端    一个用户可以通过按下<code>Ctrl+c</code>等特定组合键，或是通过<code>kill</code>命令向某个进程发送信号</li><li>硬件    对于硬件的插拔变更以及故障往往会被操作系统检测到，此时也会产生信号</li><li>系统    系统在运行时会遇到各种错误和异常，这些问题往往也会通过信号发送给进程</li><li>进程    一个进程可以通过系统调用向自身或是其他进程发送信号</li></ul><h4 id="处理信号的三种方式"><a href="#处理信号的三种方式" class="headerlink" title="处理信号的三种方式"></a>处理信号的三种方式</h4><p>进程处理信号的方式一般有3种：</p><ul><li>忽略    不采取任何操作。但是有两种信号不能忽略：<code>SIGKILL</code>和<code>SIGSTOP</code>。这是因为如果忽略这两种信号，当系统管理员想要杀死或停止进程时，便会失败</li><li>捕获    内核会暂停当前进程正在执行的代码，并跳转到注册的信号处理函数中执行。而后会回到之前进程处理的任务，继续执行</li><li>默认操作    若即不忽略也不捕获，那么进程会执行每个信号的默认操作</li></ul><h4 id="信号标识符"><a href="#信号标识符" class="headerlink" title="信号标识符"></a>信号标识符</h4><p>信号通常被定义为正整数，比方说我们经常使用的<code>kill -9 pid</code>实际上对应的是发送<code>SIGKILL</code>信号。当用户按下<code>Ctrl+c</code>时，发送的信号是<code>SIGINT</code>，即正整数2。每个信号都是以<code>SIG</code>为前缀的宏，一般而言，我们倾向于使用这些宏，而不是直接使用数字。下面列举了Linux中常用的信号：</p><table><thead><tr><th>信号</th><th>说明</th><th>默认操作</th></tr></thead><tbody><tr><td>SIGABRT</td><td>由abort()发送</td><td>终止且进行内存转储</td></tr><tr><td>SIGALRM</td><td>由alarm()发送</td><td>终止</td></tr><tr><td>SIGBUS</td><td>硬件或对齐错误</td><td>终止且进行内存转储</td></tr><tr><td>SIGCHLD</td><td>子进程终止</td><td>忽略</td></tr><tr><td>SIGCONT</td><td>进程停止后继续运行</td><td>忽略</td></tr><tr><td>SIGFPE</td><td>算数异常</td><td>终止且进行内存转储</td></tr><tr><td>SIGHUP</td><td>进程的控制终端关闭（最常见的是用户登出）</td><td>终止</td></tr><tr><td>SIGILL</td><td>进程试图执行非法指令</td><td>终止且进行内存转储</td></tr><tr><td>SIGINT</td><td>用户产生中断符(Ctrl+c)</td><td>终止</td></tr><tr><td>SIGIO</td><td>异步IO事件</td><td>终止</td></tr><tr><td>SIGKILL</td><td>不能被捕获的进程终止信号</td><td>终止</td></tr><tr><td>SIGPIPE</td><td>向无读取进程的管道写入</td><td>终止</td></tr><tr><td>SIGPROF</td><td>梗概时间超时</td><td>终止</td></tr><tr><td>SIGPWR</td><td>断电</td><td>终止</td></tr><tr><td>SIGQUIT</td><td>用户产生退出符(Ctrl+\)</td><td>终止且进行内存转储</td></tr><tr><td>SIGSEGV</td><td>无效内存访问</td><td>终止且进行内存转储</td></tr><tr><td>SIGSTKFLT</td><td>协处理器栈错误</td><td>终止</td></tr><tr><td>SIGSTOP</td><td>挂起进程</td><td>停止</td></tr><tr><td>SIGSYS</td><td>进程试图执行无效系统调用</td><td>终止且进行内存转储</td></tr><tr><td>SIGTERM</td><td>可以捕获的进程终止信号</td><td>终止</td></tr><tr><td>SIGTRAP</td><td>进入断点</td><td>终止且进行内存转储</td></tr><tr><td>SIGSTP</td><td>用户生成的挂起操作符(Ctrl+z)</td><td>停止</td></tr><tr><td>SIGTTIN</td><td>后台进程向控制终端读</td><td>停止</td></tr><tr><td>SIGTTOU</td><td>后台进程向控制终端写</td><td>停止</td></tr><tr><td>SIGURG</td><td>紧急I/O未处理</td><td>忽略</td></tr><tr><td>SIGUSR1</td><td>用户自定义的信号</td><td>终止</td></tr><tr><td>SIGUSR2</td><td>用户自定义的信号</td><td>终止</td></tr><tr><td>SIGVTALRM</td><td>虚拟时间闹钟</td><td>终止</td></tr><tr><td>SIGWINCH</td><td>控制终端窗口大小改变</td><td>忽略</td></tr><tr><td>SIGXCPU</td><td>进程资源超过限制</td><td>终止且进行内存转储</td></tr><tr><td>SIGXFSZ</td><td>文件资源超过限制</td><td>终止且进行内存转储</td></tr></tbody></table><h3 id="信号管理"><a href="#信号管理" class="headerlink" title="信号管理"></a>信号管理</h3><p>在进程中管理信号最简单的方法是通过<code>signal</code>函数，由于它的功能过于简单，现在更倾向于使用<code>sigaction</code>函数进行信号管理。这里先从<code>signal</code>入手，后续再讲解信号管理的高级方法，先来看<code>signal</code>的文档：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191209/20191209150622.png" alt=""></p><p>参数<code>signum</code>代表需要处理的信号，<code>handler</code>代表捕获到该信号后，需要执行的函数。<code>handler</code>的类型是<code>sighandler_t</code>，表示带有一个<code>int</code>型参数并返回<code>void</code>类型的函数指针，该<code>int</code>参数可以用于区分多个不同信号。当调用成功时，会返回上一次的信号处理函数指针。失败时，返回<code>SIG_ERR</code>，并设置相应的errno值。需要注意的是，<code>SIGKILL</code>和<code>SIGSTOP</code>这两种信号既不能被忽略也不能被捕获，之前已经说明过原因。下面用代码来演示，如何捕获<code>Ctrl+C</code>，即<code>SIGINT</code>信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"退出进程前执行一些清理操作...\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">__sighandler_t</span> t;</span><br><span class="line">    t = signal(SIGINT, fun);</span><br><span class="line">    <span class="keyword">if</span> (t != SIG_ERR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"注册成功\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"睡一会儿...\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注册成功</span><br><span class="line">睡一会儿...</span><br><span class="line">睡一会儿...</span><br><span class="line">睡一会儿...</span><br><span class="line">睡一会儿...</span><br><span class="line">^C退出进程前执行一些清理操作...</span><br></pre></td></tr></table></figure><p>上面的程序有两点需要注意：</p><ul><li>在我的操作系统上参数<code>handler</code>的类型是<code>__sighandler_t</code>，其原型为:<code>typedef void (*__sighandler_t) (int);</code>。事实上，不同UNIX系统可能定义的名称各不相同，但指向的函数类型都是一致</li><li>在信号处理函数，即<code>fun</code>中，我们使用<code>exit</code>退出了当前进程，这符合信号<code>SIGINT</code>的默认操作。如果没有加这一句，那么函数返回后会回到<code>while</code>中继续循环，这时候我们无法使用<code>Ctrl+c</code>终止进程，而需要使用<code>kill -KILL pid</code></li></ul><p>此外，如果已经进程中针对某信号注册了处理函数，我们也可以恢复该信号的默认操作，或是忽略信号。这需要用到函数指针<code>SIG_DEL</code>和<code>SIG_IGN</code>，演示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先注册处理函数，此时发送Ctrl+c会执行fun中代码</span></span><br><span class="line">signal(SIGINT, fun);</span><br><span class="line"><span class="comment">// 若添加此行，则将信号处理操作恢复默认，此时发送Ctrl+c会终止进程</span></span><br><span class="line">signal(SIGINT, SIG_DFL);</span><br><span class="line"><span class="comment">// 若添加此行，则忽略信号，此时发送Ctrl+c没有任何反应</span></span><br><span class="line">signal(SIGINT, SIG_IGN);</span><br></pre></td></tr></table></figure><h3 id="唤醒休眠函数"><a href="#唤醒休眠函数" class="headerlink" title="唤醒休眠函数"></a>唤醒休眠函数</h3><p>信号除了可以发通知给进程外，还可唤醒进程的休眠状态。通常我们使用<code>sleep</code>和<code>pause</code>让进程休眠，直到有信号将其唤醒。先看看这两个函数的定义：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191209/20191209165924.png" alt=""></p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191209/20191209165952.png" alt=""></p><p>它们的主要区别在于<code>sleep</code>可以指定休眠时间，自动唤醒，而<code>pause</code>只能被信号唤醒。下面通过一个例子来演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, fun) != SIG_ERR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"注册成功\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始休眠\n"</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="comment">//sleep(1000);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"结束休眠\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注册成功</span><br><span class="line">开始休眠</span><br><span class="line">^C结束休眠</span><br></pre></td></tr></table></figure><p>上面的^C则是我使用键盘发送<code>Ctrl+c</code>的时机。需要注意的是，我们这里注册的信号处理函数并没有函数体，这并不影响唤醒操作。当进程被唤醒后，会继续<code>pause</code>之后的语句执行。</p><h3 id="信号的继承"><a href="#信号的继承" class="headerlink" title="信号的继承"></a>信号的继承</h3><p>当父进程<code>fork</code>出子进程时，子进程会继承父进程的很多属性，其中便包括信号处理。如下表所示：</p><table><thead><tr><th>信号行为</th><th>通过fork创建</th><th>通过exec创建</th></tr></thead><tbody><tr><td>忽略</td><td>继承</td><td>继承</td></tr><tr><td>默认</td><td>继承</td><td>继承</td></tr><tr><td>捕获</td><td>继承</td><td>不继承</td></tr></tbody></table><p>只有在<code>fork</code>之前父进程所设置的信号处理方式，才会被子进程所继承。下面通过代码来演示设置父进程忽略<code>SIGINT</code>，并让子进程继承这一属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, SIG_IGN) != SIG_ERR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"注册成功\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        _exit(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"睡一会儿\n"</span>);</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>fork</code>成功后，父进程和子进程会同时循环休眠10秒并打印睡一会儿。此时我们另起一个终端向这两个进程发送<code>SIGINT</code>信号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ kill -SIGINT 30522</span><br><span class="line">➜  ~ kill -SIGINT 30523</span><br><span class="line"></span><br><span class="line">➜  ~ kill -KILL 30522  </span><br><span class="line">➜  ~ kill -KILL 30523</span><br></pre></td></tr></table></figure><p>由于设置了对<code>SIGINT</code>信号忽略，上面两条命令执行后，进程并没有被终止。直到使用<code>kill -KILL</code>之后才能正常终止父子进程。之前我们说过<code>SIGKILL</code>不允许设置忽略和捕获，就是为了能正确终止进程。</p><p>之所以子进程对于信号的处理方式与父进程保持一致，是因为子进程复制了父进程的代码和数据，其中也包括捕获时的处理函数。然而有一种例外是，在使用<code>exec</code>加载新的程序执行时，若此时父进程对信号的处理方式是捕获，则子进程并不会继承此方式，而是恢复为默认。原因在于新程序的代码覆盖了父进程的原有代码，其中也包括信号处理函数，既然处理函数已经不存在，那么捕获也就没有意义了。如果想让子进程捕获某个信号，那么正确的操作方式是，在新程序的代码中重新编写捕获行为。</p><h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><p>信号的发送方式有多种，以下主要从代码的层面来讲解如何发送信号</p><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p><code>kill</code>系统调用是我们经常使用的Linux命令<code>kill</code>的核心实现，它用于发送信号给一个进程：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191209/20191209182014.png" alt=""></p><p>参数<code>pid</code>表示接收信号的进程ID，<code>sig</code>表示需要发送的信号。需要注意的是<code>pid</code>的用法，如果<code>pid</code>值大于0，通常是给<code>pid</code>代表的进程发送信号；如果<code>pid</code>是0，会给调用进程的进程组中的每个进程发送信号；如果<code>pid</code>是-1，会给每个调用进程有权限发送信号的进程发送，除了调用进程自身和<code>init</code>除外；如果<code>pid</code>小于-1，会给进程组<code>-pid</code>发送信号。</p><p>当调用成功时（至少有一个信号被发出），返回0。失败时，返回-1，并设置相应的errno值。下面通过代码演示向进程30889发送<code>SIGINT</code>信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = kill(<span class="number">30889</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"kill"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h4><p><code>raise</code>函数可用于向自己发送信号：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191209/20191209202545.png" alt=""></p><p>调用成功时，返回0。失败时，返回非0值。当向自己发送信号时，以下代码是等价的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kill(getpid(), SIGINT);</span><br><span class="line">    raise(SIGINT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h4><p><code>alarm</code>用于设置一个定时，当设置时间到达后，会向调用<code>alarm</code>的进程发送一个<code>SIGALRM</code>信号</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191209/20191209203843.png" alt=""></p><p>调用成功，<code>alarm</code>会返回上次调用的剩余时间。如果上次没有调用，或是没有剩余时间，则会返回0。如果多次调用<code>alarm</code>，会自动取消之前未完成的时间。以下是代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGALRM) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"调用alarm\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGALRM, fun) != SIG_ERR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"注册成功\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> left;</span><br><span class="line">    left = alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"剩余%d秒\n"</span>, left);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    left = alarm(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"剩余%d秒\n"</span>, left);</span><br><span class="line">    sleep(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注册成功</span><br><span class="line">剩余0秒</span><br><span class="line">剩余2秒</span><br><span class="line">调用alarm</span><br></pre></td></tr></table></figure><h4 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h4><p><code>abort</code>函数可以导致当前进程异常终止<br><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191209/20191209210313.png" alt=""></p><p>调用成功时，它会向调用此函数的进程发送<code>SIGABRT</code>信号，该函数没有返回。示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGABRT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"异常中断\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGABRT, fun) == SIG_ERR) &#123;</span><br><span class="line">        perror(<span class="string">"signal"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">异常中断</span><br><span class="line">[1]    32094 abort (core dumped)  ./a.out</span><br></pre></td></tr></table></figure><h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><p>Linux中的信号多达数十种，要想批量阻塞（或解除阻塞）这些信号，以免受某些信号影响，就需要用到信号集。它用一种表示多个信号掩码的数据类型：<code>sigset_t</code>，并且与之对应有一系列操作此集合的函数：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191209/20191210080100.png" alt=""></p><ul><li>sigemptyset    将set给定的信号集初始化为空，并将所有信号排除在集合外</li><li>sigfillset    将信号集设置为full，这会包括所有信号</li><li>sigaddset    从集合中添加信号<code>signum</code></li><li>sigdelset    从集合中删除信号<code>signum</code></li><li>sigismember    查询<code>signum</code>是否为信号集的成员</li></ul><p>其中<code>sigemptyset</code>、<code>sigfillset</code>、<code>sigaddset</code>、<code>sigdelset</code>在调用成功时返回0，出错时返回-1；而<code>sigismember</code>查询到<code>signum</code>是<code>set</code>成员时返回1，否则返回0，出错时返回-1。这些函数在调用错误时，同时会设置errno为相应值。下面我们通过代码来演示操作当前进程的信号集：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="comment">// 清空所有信号</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>) ;</span><br><span class="line">    <span class="comment">// 添加SIGINT信号</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="comment">// 查询SIGINT信号是否为信号集成员</span></span><br><span class="line">    <span class="keyword">int</span> ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SIGINT is member:%d\n"</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功后，输出以下语句，并且程序会陷入死循环休眠中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SIGINT is member:0</span><br></pre></td></tr></table></figure><p>此时我们通过<code>kill -SIGINT</code>命令终止此进程时依然会成功，因为虽然我们添加了<code>SIGINT</code>的信号掩码，也就是希望暂时阻塞此信号，但是我们却并没有将信号集和当前进程关联起来，完成这一操作需要用到<code>sigprocmask</code></p><h4 id="sigprocmask"><a href="#sigprocmask" class="headerlink" title="sigprocmask"></a>sigprocmask</h4><p><code>sigprocmask</code>用于修改当前进程需要阻塞的信号掩码</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191209/20191210083827.png" alt=""></p><p><code>sigprocmask</code>的行为取决于参数<code>how</code>的值，它可以是以下标识之一：</p><p>SIG_BLOCK    <code>set</code>中的信号被加入到调用进程的信号掩码中，也就是说当前进程信号掩码和<code>set</code>取并集</p><p>SIG_UNBLOCK    <code>set</code>中的信号集将从当前调用进程的信号掩码中移出</p><p>SIG_SETMASK    将调用进程的信号掩码设置为<code>set</code></p><p>如果<code>oldset</code>是非空的，该函数将<code>oldset</code>设置为先前的信号集。如果<code>set</code>是空的，该函数会忽略参数<code>how</code>，并且不会改变信号掩码，但是仍然会设置<code>oldset</code>的信号掩码。成功时，该调用会返回0。失败时，返回-1，并设置相应的errno值。以下为代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="comment">// 清空所有信号</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>) ;</span><br><span class="line">    <span class="comment">// 添加SIGINT信号</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="comment">// 查询SIGINT信号是否为信号集成员</span></span><br><span class="line">    <span class="keyword">int</span> ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SIGINT is member:%d\n"</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sigprocmask"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们已经加入了<code>SIGINT</code>信号的屏蔽掩码，再次通过<code>kill -SIGINT pid</code>命令则无法终止进程，因为<code>SIGINT</code>信号已经被阻塞。需要注意的是，不允许阻塞<code>SIGKILL</code>和<code>SIGSTOP</code>信号。<code>sigprocmask</code>会忽略任何将这两个信号加入信号掩码的操作，而不会提示任何信息。</p><h3 id="高级信号管理"><a href="#高级信号管理" class="headerlink" title="高级信号管理"></a>高级信号管理</h3><h4 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h4><p>在之前信号管理小节中讲到过<code>signal</code>函数，它是C标准库的一部分，由于标准库需要对操作系统做兼容，因此也就限制了它的能力。作为另外一种选择，我们可以使用<code>sigaction</code>系统调用，它提供了更强大的功能。</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191209/20191210100423.png" alt=""></p><p>调用<code>sigaction</code>会改变由<code>signum</code>表示的信号的行为，<code>signum</code>可以是除了<code>SIGKILL</code>和<code>SIGSTOP</code>外的任何值。如果<code>act</code>是非空的，该系统调用将该信号当前行为替换成由参数<code>act</code>指定的行为。如果<code>oldact</code>是非空的，该调用会存储先前指定的信号行为。结构体<code>sigaction</code>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;</span><br><span class="line">    <span class="keyword">int</span>        sa_flags;</span><br><span class="line">    <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sa_handler</code>表示接收到信号时所采取的处理方式，可以看到它与<code>signal</code>函数中的信号处理函数原型一致，当然它也可以使用<code>SIG_DFL</code>或<code>SIG_IGN</code>来设置默认操作及忽略信号。</p><p>如果<code>sa_flags</code>被设置成<code>SA_SIGINFO</code>，那么将由参数<code>sa_sigaction</code>，而不是<code>sa_handler</code>来表示如何执行信号处理函数。其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *ucontext)</span></span></span><br></pre></td></tr></table></figure><p><code>sig</code>表示引发当前处理函数的信号；<code>info</code>是一个结构体指针，描述了当前信号的详细信息；<code>ucontext</code>是<code>ucontext_t</code>的结构体指针，被强转为<code>void *</code>型，它描述了当前信号的上下文信息。</p><p><code>sa_mask</code>提供了在执行信号处理函数时，被阻塞的信号集。</p><h4 id="结构体siginfo-t"><a href="#结构体siginfo-t" class="headerlink" title="结构体siginfo_t"></a>结构体siginfo_t</h4><p>当使用<code>sa_sigaction</code>来进行信号处理的时候，结构体<code>siginfo_t</code>为我们提供了大量有用信息，以下是对其结构常用字段的描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">siginfo_t</span> &#123;</span><br><span class="line">    <span class="keyword">int</span>      si_signo;     <span class="comment">/* Signal number */</span></span><br><span class="line">    <span class="keyword">int</span>      si_errno;     <span class="comment">/* An errno value */</span></span><br><span class="line">    <span class="keyword">int</span>      si_code;      <span class="comment">/* Signal code */</span></span><br><span class="line">    <span class="keyword">int</span>      si_trapno;    <span class="comment">/* Trap number that caused</span></span><br><span class="line"><span class="comment">                              hardware-generated signal</span></span><br><span class="line"><span class="comment">                              (unused on most architectures) */</span></span><br><span class="line">    <span class="keyword">pid_t</span>    si_pid;       <span class="comment">/* Sending process ID */</span></span><br><span class="line">    <span class="keyword">uid_t</span>    si_uid;       <span class="comment">/* Real user ID of sending process */</span></span><br><span class="line">    <span class="keyword">int</span>      si_status;    <span class="comment">/* Exit value or signal */</span></span><br><span class="line">    <span class="keyword">clock_t</span>  si_utime;     <span class="comment">/* User time consumed */</span></span><br><span class="line">    <span class="keyword">clock_t</span>  si_stime;     <span class="comment">/* System time consumed */</span></span><br><span class="line">    <span class="keyword">sigval_t</span> si_value;     <span class="comment">/* Signal value */</span></span><br><span class="line">    <span class="keyword">int</span>      si_int;       <span class="comment">/* POSIX.1b signal */</span></span><br><span class="line">    <span class="keyword">void</span>    *si_ptr;       <span class="comment">/* POSIX.1b signal */</span></span><br><span class="line">    <span class="keyword">int</span>      si_overrun;   <span class="comment">/* Timer overrun count;</span></span><br><span class="line"><span class="comment">                              POSIX.1b timers */</span></span><br><span class="line">    <span class="keyword">int</span>      si_timerid;   <span class="comment">/* Timer ID; POSIX.1b timers */</span></span><br><span class="line">    <span class="keyword">void</span>    *si_addr;      <span class="comment">/* Memory location which caused fault */</span></span><br><span class="line">    <span class="keyword">long</span>     si_band;      <span class="comment">/* Band event (was int in</span></span><br><span class="line"><span class="comment">                              glibc 2.3.2 and earlier) */</span></span><br><span class="line">    <span class="keyword">int</span>      si_fd;        <span class="comment">/* File descriptor */</span></span><br><span class="line">    <span class="keyword">short</span>    si_addr_lsb;  <span class="comment">/* Least significant bit of address</span></span><br><span class="line"><span class="comment">                              (since Linux 2.6.32) */</span></span><br><span class="line">    <span class="keyword">void</span>    *si_lower;     <span class="comment">/* Lower bound when address violation</span></span><br><span class="line"><span class="comment">                              occurred (since Linux 3.19) */</span></span><br><span class="line">    <span class="keyword">void</span>    *si_upper;     <span class="comment">/* Upper bound when address violation</span></span><br><span class="line"><span class="comment">                              occurred (since Linux 3.19) */</span></span><br><span class="line">    <span class="keyword">int</span>      si_pkey;      <span class="comment">/* Protection key on PTE that caused</span></span><br><span class="line"><span class="comment">                              fault (since Linux 4.6) */</span></span><br><span class="line">    <span class="keyword">void</span>    *si_call_addr; <span class="comment">/* Address of system call instruction</span></span><br><span class="line"><span class="comment">                              (since Linux 3.5) */</span></span><br><span class="line">    <span class="keyword">int</span>      si_syscall;   <span class="comment">/* Number of attempted system call</span></span><br><span class="line"><span class="comment">                              (since Linux 3.5) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> si_arch;  <span class="comment">/* Architecture of attempted system call</span></span><br><span class="line"><span class="comment">                              (since Linux 3.5) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用sa-handler处理信号"><a href="#使用sa-handler处理信号" class="headerlink" title="使用sa_handler处理信号"></a>使用sa_handler处理信号</h4><p>当使用<code>sa_handler</code>时，行为与<code>signal</code>函数类似，以下代码演示如何捕获<code>SIGINT</code>信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/sigaction.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"收到信号SIGINT\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span>;</span></span><br><span class="line">    sig.sa_handler = fun;</span><br><span class="line"></span><br><span class="line">    sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用sa-sigaction处理信号"><a href="#使用sa-sigaction处理信号" class="headerlink" title="使用sa_sigaction处理信号"></a>使用sa_sigaction处理信号</h4><p>当使用<code>sa_sigaction</code>时，我们可以获取到更多可用信息，以下代码演示如何捕获<code>SIGINT</code>信号，并获取额外信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/sigaction.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *ucontext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"收到信号SIGINT\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"信号编号:%d\n"</span>, info-&gt;si_signo);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"信号附加信息：%s\n"</span>, info-&gt;si_value);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span>  *<span class="title">context</span> = (<span class="title">struct</span> <span class="title">ucontext_t</span>*)<span class="title">ucontext</span>;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"信号处理方式:%d\n"</span>, context-&gt;uc_flags);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span>;</span></span><br><span class="line">    sig.sa_flags = SA_SIGINFO;</span><br><span class="line">    sig.sa_sigaction = fun;</span><br><span class="line"></span><br><span class="line">    sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">收到信号SIGINT</span><br><span class="line">信号编号:2</span><br><span class="line">信号附加信息：(null)</span><br><span class="line">信号处理方式:7</span><br></pre></td></tr></table></figure><h4 id="发送带附加信息的信号"><a href="#发送带附加信息的信号" class="headerlink" title="发送带附加信息的信号"></a>发送带附加信息的信号</h4><p>在上面使用<code>sa_sigaction</code>处理信号的例子中，我们尝试打印<code>siginfo_t</code>中的<code>si_value</code>来获取附加信息，然而打印结果为<code>null</code>，这是因为必须使用<code>sigqueque</code>函数才允许进程发送带附加信息的信号，先来看相关函数定义：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191209/20191210112459.png" alt=""></p><p><code>sigqueue</code>的运行方式和<code>kill</code>很类似。成功时，由<code>sig</code>表示的信号会被添加到由<code>pid</code>指定的进程或进程组的队列中，并返回0。失败时，返回-1，并设置相应的errno值。而信号的附加信息<code>value</code>是一个联合体，其结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> sigval &#123;</span><br><span class="line">    <span class="keyword">int</span>   sival_int;</span><br><span class="line">    <span class="keyword">void</span> *sival_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面我们通过代码来演示如何在发送信号时添加附加信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> sigval value;</span><br><span class="line">    value.sival_ptr = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigqueue(getpid(), SIGINT, value) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sigqueue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先我们在本文开头了解了信号的基本概念以及发送源，事实上信号的发送源非常多，可以翻阅源码来找到其定义的各种宏。接着我们了解了信号处理的基本方式，在进程的继承过程中，信号处理需要注意的点，以及通过代码是如何发送信号的。再来就是，对于进程中信号的阻塞操作，我们引入了信号集，它是一种表示多个进程的掩码。最后我们了解了高级信号管理的方式，其中涉及到多个结构体及其说明，由于篇幅有限没有列举完，此处需要多翻阅文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常我们习惯于在Linux系统中使用&lt;code&gt;Ctrl+c&lt;/code&gt;结束一个当前正在运行的进程，而这一操作实质上是对进程发送了一个终止信号。什么是信号呢？它是一种简单的异步通信机制，用于向进程发送通知。
    
    </summary>
    
    
      <category term="Linux" scheme="https://linxiao.pro/categories/Linux/"/>
    
    
      <category term="C" scheme="https://linxiao.pro/tags/C/"/>
    
      <category term="系统编程" scheme="https://linxiao.pro/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux系统编程-进程管理</title>
    <link href="https://linxiao.pro/2019/12/07/linux-programming-process-basic/"/>
    <id>https://linxiao.pro/2019/12/07/linux-programming-process-basic/</id>
    <published>2019-12-07T12:33:05.000Z</published>
    <updated>2019-12-07T04:33:05.036Z</updated>
    
    <content type="html"><![CDATA[<p>我们写完代码，经过编译生成的可执行二进制文件称作程序。程序保存在磁盘上，它是一个静态概念。而当程序被加载到内存中开始执行时，此时它又是动态的，被称作进程。一个进程涉及到很多方面，如：正在执行的二进制文件、虚拟内存、进程体系、进程状态、进程资源以及调度等等。下面的内容主要来谈谈进程的基本概念和管理。<a id="more"></a></p><h3 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a>进程ID</h3><p>我们先通过一个例子来引入进程ID这个概念，写一段代码，里面是一个死循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>gcc main.c -o loop</code>命令编译后，我们开始运行这个程序。然后在终端通过<code>ps -a</code>命令查看正在运行的进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ps -a</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  1936 tty2     00:35:12 java</span><br><span class="line">  1986 tty2     00:00:04 fsnotifier64</span><br><span class="line">  2303 tty2     00:00:04 gnome-software</span><br><span class="line"> 25474 pts/1    00:00:00 ps</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>可以看到刚运行的<code>loop</code>，其PID为25463，这里的PID也就是进程ID。每个进程的ID是唯一的，也就是说，同一时刻在操作系统内运行的程序，不可能产生两个或多个一样的PID。当进程被回收后，PID是可复用的，但这个概率比较小。因为默认情况下，内核将进程ID的最大值设置为32758，也就是int类型的最大值。只有当创建的进程数超过最大值以后，内核才会复用以前分配过的PID。</p><h4 id="获取进程ID和父进程ID"><a href="#获取进程ID和父进程ID" class="headerlink" title="获取进程ID和父进程ID"></a>获取进程ID和父进程ID</h4><p>从代码角度而言，进程ID都是由<code>pid_t</code>来表示，通常为int类型。下面两个系统调用可以获取进程ID：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205135830.png" alt=""></p><p><code>getpid</code>用来获取当前进程ID，<code>getppid</code>用于获取父进程ID。没错，每一个子进程都是由父进程派生出来的，所以还有父进程ID这么个概念。你可以通过命令行<code>pstree -p</code>查看进程树和相应的进程ID。由于以上两个函数总是会调用成功，因此不需要进行错误判断，下面用代码来演示打印当前进程ID和父进程ID：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"process id:       %10d\n"</span>, pid);</span><br><span class="line"></span><br><span class="line">    pid = getppid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent process id:%10d\n"</span>, pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>再回到我们刚刚跑起来的<code>loop</code>进程，你应该很自然的会想到在终端中用Ctrl+c去终止它。虽然有些暴力，但也的确可以这么做。于是也就引出了我们平常终止进程的两种方式，一是正常终止，二是异常终止。正常终止包括从main返回，调用exit、<code>_exit</code>或<code>_Exit</code>函数。而异常终止包括调用<code>abort</code>，接收终止信号等。在终端中执行Ctrl+c实际上就是给当前执行的进程发送终止信号，其等同于命令<code>kill -9 PID</code>，当<code>loop</code>进程接收到信号后就会终止自身。</p><h4 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h4><p>通常情况下，我们在main函数中通过return返回，于是也就退出了进程。但这样的退出方式只在main函数好使，因为程序在实际运行中往往需要调用一系列函数，每次调用相当于将函数进行一次压栈操作，而每次return又相当于从当前函数返回到调用处，也就是出栈。而从main函数return，则相当于将进程中的函数调用栈清空，也就达到了退出进程的目的。这样退出的前提是，所有的函数调用最终都能返回到main中。但事实往往不是，先看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun3\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun2\n"</span>);</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun1\n"</span>);</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如当前进程执行到fun2函数遇到异常，无法向调用处返回，而是希望直接终止进程怎么办？那么最快的方式就是使用退出函数：<code>exit</code>、<code>_exit</code>或<code>_Exit</code>。 先来看三个函数的定义：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205162819.png" alt=""></p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205162858.png" alt=""></p><p>3个函数都用于正常终止一个进程，且都带一个<code>status</code>参数，称为终止状态。大多数UNIX系统shell都提供检查进程终止状态的方法，如通过命令行<code>echo $?</code>。其中<code>_exit</code>和<code>_Exit</code>是系统调用，执行后会立即进入内核。当进程退出时，内核会清理进程所创建的、不再使用的所有资源。这包括但不局限于：分配内存、打开文件和System V的信号量。清理完成后，内核会摧毁进程，并告知父进程其子进程已经终止。</p><p>进程可以直接调用<code>_exit</code>退出，但通常并不合适，绝大多数进程在完全退出之前，还需要做一些额外的清理工作。这时需要使用<code>exit</code>，它是一个C库函数。<code>exit</code>最终还是会调用系统调用<code>_exit</code>，但在此之前它会清理所有已打开的标准I/O流，并且会调用任何由<code>atexit</code>注册的函数。</p><h4 id="atexit"><a href="#atexit" class="headerlink" title="atexit"></a>atexit</h4><p>系统调用<code>atexit</code>用来注册一些在进程结束时要调用的函数</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205171538.png" alt=""></p><p><code>atexit</code>调用成功时，会注册指定的函数作为终止函数，在程序正常结束时（即进程通过调用<code>exit</code>或从<code>main</code>函数返回）运行。指定函数必须是无参的，且没有返回值。函数形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>函数调用的顺序和函数注册的顺序相反。也就是说，这些函数是存储在栈中，以后进先出的方式调用（LIFO）。注册的函数不能调用<code>exit</code>，否则会导致递归调用死循环。调用成功<code>atexit</code>返回0。错误时，返回-1。下面通过代码来演示，如何注册：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun3\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"进程正在运行\n"</span>);</span><br><span class="line">    </span><br><span class="line">    atexit(fun1);</span><br><span class="line">    atexit(fun2);</span><br><span class="line">    atexit(fun3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"进程准备退出\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行新进程"><a href="#运行新进程" class="headerlink" title="运行新进程"></a>运行新进程</h3><p>在UNIX中，把程序载入内存执行和创建新的进程是相互独立的操作。通过<code>exec</code>系列系统调用，可以把二进制程序加载到内存中，替换地址空间原来的内容，并开始执行新程序。而通过<code>fork</code>系统调用，可以创建一个新的进程，它基本上相当于复制其父进程。通常情况下，新的进程会立即执行新的程序。</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p><code>exec</code>并非一个单独的函数，而是由<code>exec</code>开头的一系列系统调用。它们都用于加载指定的二进制程序，并替换当前的进程来运行。先来看文档：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205184100.png" alt=""></p><p>由于函数比较多，我们先拿第一个来举例。<code>execl</code>用于加载参数<code>path</code>指定的二进制文件到内存中，并替换当前进程，<code>arg</code>是该程序的参数列表，有一个或多个，参数列表必须以NULL结尾。通常情况下，<code>execl</code>不会返回。调用成功时，会跳转到新的程序入口点，而刚刚运行的代码是不再存在于进程的地址空间中。错误时，<code>execl</code>会返回-1，并设置相应的errno值。下面来举个例子，我们用<code>ls</code>命令来替换当前的进程运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始执行\n"</span>);</span><br><span class="line">    ret = execl(<span class="string">"/bin/ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"execl"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"执行结束\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开始执行</span><br><span class="line">总用量 72</span><br><span class="line">-rw---S--T 1 noir noir   530 12月  2 01:53 backup.c</span><br><span class="line">-rw-rw-r-- 1 noir noir 22760 11月 28 15:59 CMakeCache.txt</span><br><span class="line">drwxrwxr-x 5 noir noir  4096 12月  5 02:44 CMakeFiles</span><br><span class="line">-rw-rw-r-- 1 noir noir  1533 11月 28 15:59 cmake_install.cmake</span><br><span class="line">-rw-rw-r-- 1 noir noir  4991 12月  2 01:44 Makefile</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>有几点需要注意：</p><ul><li>上面的输出打印了<code>开始执行</code>，却没有打印<code>执行结束</code>。这是因为当载入新程序执行后，原有进程会被替代，即便还有后续可执行的代码，也会被忽略</li><li>虽然当前进程被新程序所替代，但进程大部分属性依然保持不变，如：pid、ppid、进程优先级、所属用户和所属组等</li><li>按照惯例，<code>arg</code>的第一个参数应该是程序的名称，当执行新进程时，该名称将被放入新进程的第一个参数<code>argv[0]</code>中，程序解析<code>argv[0]</code>后，就可知道二进制程序的名字了</li></ul><p>关于上面第三点，我们可以写两段代码来验证<code>exec</code>系列函数的参数传递。首先来写一段代码用来输出从<code>argv</code>中获取的参数列表，我们通过<code>gcc parse.c -o parse</code>将其编译为<code>parse</code>二进制文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们通过<code>execl</code>来调用<code>parse</code>，传入参数后，让其输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始执行\n"</span>);</span><br><span class="line">    ret = execl(<span class="string">"../parse"</span>, <span class="string">"parse"</span>, <span class="string">"-arg1"</span>, <span class="string">"-arg2"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"execl"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"执行结束\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始执行</span><br><span class="line">parse</span><br><span class="line">-arg1</span><br><span class="line">-arg2</span><br></pre></td></tr></table></figure><p>可见，<code>arg</code>参数被原封不动地传递到了<code>parse</code>程序的<code>argv</code>参数列表中。</p><h4 id="其他exec函数"><a href="#其他exec函数" class="headerlink" title="其他exec函数"></a>其他exec函数</h4><p>除了<code>execl</code>外，<code>exec</code>系还有其他5个函数，分别是：<code>execlp</code>、<code>execle</code>、<code>execv</code>、<code>execvp</code>、<code>execve</code>。这些函数很容易记住。<code>l</code>和<code>v</code>分别表示参数是以列表方式还是数组方式提供的。<code>p</code>表示会在用户的环境变量<code>path</code>下查找可执行文件。使用了<code>p</code>的函数可以只指定文件名，该文件必须在用户环境变量下。最后，<code>e</code>表示会为新进程提供新的环境变量。奇怪的是，<code>exec</code>函数中没有一个同时可以搜索路径和使用新环境变量的函数，虽然从技术角度看完全可以实现它。这可能是因为带<code>p</code>的<code>exec</code>函数主要是用于shell的，因为shell执行的进程通常会从shell本身继承环境变量。</p><p>和之前演示的例子一样，以下代码使用<code>execvp</code>来执行<code>ls</code>，它要求<code>ls</code>必须在<code>path</code>路径下，并且参数采用数组来提供：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *arg[] = &#123;<span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"-a"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    ret = execvp(<span class="string">"ls"</span>, arg);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"execvp"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出与之前<code>execl</code>演示的结果一致。</p><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p><code>fork</code>调用可以创建一个子进程，先来看看函数定义：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205215359.png" alt=""></p><p>当<code>fork</code>调用成功时，它会创建一个几乎与父进程完全相同的子进程。父子进程会以<code>fork</code>的调用点为起点，分别继续运行。在父进程中，<code>fork</code>会返回子进程的<code>pid</code>，而在子进程中，<code>fork</code>会返回0。出错时，不会创建子进程，<code>fork</code>返回-1，并设置相应errno值。来看一段代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process pid:%d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process ppid:%d\n"</span>, getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处休眠1秒，防止父进程过快终止</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent process pid:%d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent process ppid:%d\n"</span>, getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">child process pid:31033</span><br><span class="line">child process ppid:31032</span><br><span class="line">after</span><br><span class="line">parent process pid:31032</span><br><span class="line">parent process ppid:1936</span><br><span class="line">after</span><br></pre></td></tr></table></figure><p>上面的代码和输出有几处需要额外注意：</p><ul><li>子进程的ppid其实也就是父进程的pid</li><li>before只打印了一次是因为它处于<code>fork</code>之前，而after打印了两次是因为<code>fork</code>之后子进程和父进程都有一份打印代码</li><li>在父进程中我们休眠了一秒，是为了防止父进程在<code>fork</code>后过早结束本身运行状态，而子进程还未执行完</li></ul><p>通常情况下，会使用<code>fork</code>创建一个新的进程，然后再通过<code>exec</code>载入二进制文件，以替换<code>fork</code>出的新进程运行。将创建进程与执行二进制文件分离是一个非常好的设计。这样你就无需在<code>fork</code>出的子进程代码段中编写大量代码，而是可以编写独立的程序。这就好比我们在shell中执行命令，无需知道每个具体命令的实现，shell只需要为该命令创建一个新进程，然后把命令和相关参数丢进去执行即可。下面我们来写一段代码，演示如何在<code>fork</code>出的新进程中通过<code>exec</code>来执行<code>ls</code>命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        ret = execlp(<span class="string">"ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"-a"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"execlp"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处休眠1秒，防止父进程过快终止</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">总用量 80</span><br><span class="line">drwxrwxr-x 3 noir noir  4096 12月  5 17:10 .</span><br><span class="line">drwxrwxr-x 5 noir noir  4096 12月  5 17:10 ..</span><br><span class="line">-rw---S--T 1 noir noir   530 12月  2 01:53 backup.c</span><br><span class="line">-rw-rw-r-- 1 noir noir 22760 11月 28 15:59 CMakeCache.txt</span><br><span class="line">drwxrwxr-x 5 noir noir  4096 12月  5 17:10 CMakeFiles</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h4><p>上面的例子中需要让父进程休眠1秒，以便留给子进程足够的时间执行完。假设现在子进程进行的任务非常繁重且耗时，那么父进程应该休眠几秒？答案是不确定，我们应该让父进程等待子进程执行完。通过<code>vfork</code>可以做到这点，但是<code>vfork</code>是一个不推荐使用的函数。我们先看<code>vfork</code>的用法，然后再说明为何不推荐使用。</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206093458.png" alt=""></p><p><code>vfork</code>的调用和返回与<code>fork</code>相同，但使用<code>vfork</code>能保证子进程先运行，在它调用<code>exec</code>或<code>_exit</code>之后父进程才会继续运行。我们用这样一个特性来改写上面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        ret = execlp(<span class="string">"ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"-a"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"execlp"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程不做任何操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果与之前一样，但是父进程不需要再休眠。除了上面所说的运行特点，<code>fork</code>和<code>vfork</code>还有一个差别：同样是创建子进程，<code>fork</code>会把父进程的内存数据拷贝到子进程中；而<code>vfork</code>则是和父进程共享内存数据。我们之前有说过<code>fork</code>会创建一个与当前进程一样的子进程。所谓一样就是指内存数据一样。而实际应用中，大部分场景是<code>fork</code>一个新的子进程，然后直接通过<code>exec</code>载入二进制文件执行，根本不需要进行内存数据拷贝，因此共享父进程的就可以了。</p><p>于此同时，<code>vfork</code>这些特点也带来了些弊端：</p><ul><li>如果<code>exec</code>调用失败，那么父进程就会被一致挂起</li><li>在子进程中不能使用<code>return</code>或<code>exit</code>进行终止。由于是共享父进程内存数据，当使用<code>return</code>时，会从<code>main</code>函数返回，导致函数栈空间被清空，所以回到父进程继续运行时，栈空间会错乱。如果使用<code>exit</code>，那么它会清理父进程的标准I/O。子进程正确的退出方式是使用<code>_exit</code></li></ul><p>由于<code>vfork</code>所带来的这些隐患，所以它不推荐被使用。</p><h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p><code>vfork</code>由于没有直接的内存数据拷贝操作，所以性能非常好，但同时也带来很多危险。为了弥补<code>fork</code>拷贝内存数据所带来的性能开销，现代UNIX系统采用了写时复制(copy-on-write)的方式，而不是对父进程内存数据进行整体复制。</p><p>写时复制是一种基于惰性算法的优化策略，为了避免复制时的开销。其前提假设很简单：如果有多个进程要读取它们自己那部分资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有一个进程修改自己的副本，每个进程就好像独占那个资源，从而避免了复制带来的开销。如果某个进程想要修改自己的那份资源副本，就会开始复制该资源，并把副本提供给这个进程。这个进程后面就可以反复修改其持有的副本，而其他进程还是共享原来那份没有修改过的资源。这就是写时复制这个名称的由来：只有在写入时才执行复制。</p><h3 id="等待进程终止"><a href="#等待进程终止" class="headerlink" title="等待进程终止"></a>等待进程终止</h3><p>通过<code>vfork</code>可以使父进程挂起，等待子进程执行完再继续运行。但是<code>vfork</code>毕竟会带来一些危险性，并且其无法获取子进程执行完后的状态信息。这个时候我们需要使用<code>wait</code>系列系统调用，它们用于等待进程状态改变：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206112528.png" alt=""></p><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>先来看<code>wait</code>，调用<code>wait</code>成功时，会返回已终止子进程的pid；出错时，返回-1。如果没有子进程终止，调用会阻塞，直到有一个子进程终止。如果子进程已经终止了，调用会立即返回。如果<code>wstatus</code>指针不是NULL，那它包含了关于子进程的一些其他信息。这些信息可以根据以下宏来解释：</p><table><thead><tr><th>宏</th><th>说明</th></tr></thead><tbody><tr><td>WIFEXITED(status)</td><td>若子进程正常终止，返回真。此时可通过WEXITSTATUS(status)获取子进程传送给exit或_exit参数的低8位</td></tr><tr><td>WIFSIGNALED(status)</td><td>若子进程被信号终止，返回真。此时可通过WTERMSIG(status)获取信号编号。若进程收到信号时产生终止进程的core文件，则WCOREDUMP(status)返回真</td></tr><tr><td>WIFSTOPPED(status)</td><td>若当前子进程停止运行，返回真。此时可通过WSTIOPSIG(status)获取使进程终止的信号编号</td></tr><tr><td>WIFCONTINUED(status)</td><td>若当前子进程继续运行，返回真。</td></tr></tbody></table><p>下面我们写一个例子来演示，创建一个新的子进程，休眠60秒。然后在父进程中等待其终止状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">60</span>);</span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"正常终止，终止状态码：%d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"被信号终止，信号编码：%d\n"</span>, WTERMSIG(status));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"是否生成coredump文件：%d\n"</span>, WCOREDUMP(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"被信号暂停，信号编码:%d\n"</span>, WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFCONTINUED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"继续运行\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序正常终止会输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正常终止，终止状态码：1</span><br></pre></td></tr></table></figure><p>通过<code>kill -15 41782</code>命令尝试为该进程发送终止信号，则输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">被信号终止，信号编码：15</span><br><span class="line">是否生成coredump文件：0</span><br></pre></td></tr></table></figure><h4 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h4><p>通常情况下，一个进程会有多个子进程，如果父进程想等待其中一个子进程，一个方法是多次调用<code>wait</code>，然后每次根据返回值来判断是否为需要等待的子进程。但这种方法并不太灵活，通过<code>waitpid</code>可以指定等待的子进程，并且它额外的参数可以支持更细粒度的调整。<code>waitpid</code>函数定义上图已经列出。</p><p>参数<code>pid</code>指定要等待的一个或多个进程的<code>pid</code>，它的值必须是下面四种情况之一：</p><ul><li><code>&lt;-1</code> 等待一个指定进程组中的任何子进程退出，该进程组的ID等于<code>pid</code>的绝对值。比如，传递参数值-500，表示等待在进程组500中的任何子进程</li><li><code>-1</code> 等待任何一个子进程退出，行为和<code>wait</code>一致</li><li><code>0</code> 等待同一个进程组中的任何子进程</li><li><code>&gt;0</code> 等待进程<code>pid</code>等于<code>pid</code>的子进程。比如，传递参数值500，表示等待<code>pid</code>为500的子进程</li></ul><p>参数<code>wstatus</code>的作用和<code>wait</code>函数中的是一样的，并且也可以只用之前讨论过的宏。</p><p>参数<code>options</code>是0个或多个以下选项按二进制或运算的结果：</p><ul><li>WNOHANG 不要阻塞，如果要等待的子进程还没有结束、停止或继续运行，会立即返回</li><li>WUNTRACED 如果设置该位，即使调用进程没有跟踪子进程，也会设置返回调用参数中的WIFSTOPPED位</li><li>WCONTINUED 如果设置该位，即使是调用进程没有跟踪子进程，也会设置返回调用参数中的WIFCONTINUED位</li></ul><p>调用成功时，<code>waitpid</code>返回状态发生改变的那个进程的<code>pid</code>。如果设置了WNOHANG参数，并且要等待的一个或多个子进程的状态还没有发生改变，<code>waitpid</code>返回0。出错时，调用返回-1，并设置相应的errno值。下面通过代码来演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">60</span>);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        waitpid(pid, &amp;status, WUNTRACED|WCONTINUED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"正常终止，终止状态码:%d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"被信号暂停，信号编码:%d\n"</span>, WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFCONTINUED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"继续运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行后，我们尝试通过<code>kill -STOP 3888</code>给新创建的子进程发送信号，让其停止运行，输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被信号暂停，信号编码:19</span><br></pre></td></tr></table></figure><h3 id="创建并等待新进程"><a href="#创建并等待新进程" class="headerlink" title="创建并等待新进程"></a>创建并等待新进程</h3><p>如果一个进程创建了新进程并且立即开始等待它的结束，那么除了<code>vfork</code>和<code>wait</code>，还有另一种实现方式，即使用<code>system</code>函数</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206161937.png" alt=""></p><p><code>system</code>函数会使用<code>fork</code>创建一个子进程，然后在其内部通过<code>execl</code>系统调用去执行<code>command</code>所指定的命令，调用如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, command, (<span class="keyword">char</span> *) <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>成功时，返回值是执行<code>command</code>命令得到的返回状态，该状态和执行<code>waitpid</code>所获取的状态一致。因此，可以通过WEXITSTATUS获取执行<code>command</code>命令的返回值。如果调用<code>/bin/sh</code>本身失败了，那么从WEXITSTATUS返回的值和调用exit(127)的返回值是一样的。因为也可能是调用的命令返回了127，但没有办法来检测是shell本身发生了错误还是调用<code>command</code>命令执行失败而返回127。失败时，<code>system</code>调用会返回-1。如果参数<code>command</code>是NULL且<code>/bin/sh</code>是可用的，<code>system</code>会返回一个非0值，否则返回0。我们通过一段代码来演示，如何使用<code>system</code>来调用<code>ls</code>并获取返回值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    status = system(<span class="string">"ls -l -a"</span>);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"system"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"正常终止，终止状态码:%d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">总用量 80</span><br><span class="line">drwxrwxr-x 3 noir noir  4096 12月  6 00:38 .</span><br><span class="line">drwxrwxr-x 5 noir noir  4096 12月  6 00:38 ..</span><br><span class="line">-rw---S--T 1 noir noir   530 12月  2 01:53 backup.c</span><br><span class="line">-rw-rw-r-- 1 noir noir 22760 11月 28 15:59 CMakeCache.txt</span><br><span class="line">...</span><br><span class="line">正常终止，终止状态码:0</span><br></pre></td></tr></table></figure><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>当子进程结束后，它的父进程还未获取其状态，那么这个进程就叫做僵尸进程。僵尸进程会消耗少量资源用于保存进程之前的一些状态信息。一旦父进程通过<code>waitpid</code>等方式得到此信息，那么内核就会将子进程销毁。下面用一段代码演示子进程到僵尸进程的转化过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子进程结束\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span> (pid == wait(<span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"子进程已被回收\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"父进程结束\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行后，我们可以通过<code>ps -ao pid,ppid,stat,cmd | grep zombie</code>（zombie是我们编译出的二进制程序）查看进程状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 程序开始执行，此时两个进程都在休眠状态</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep zombie</span><br><span class="line">  7354   3411 S+   ./zombie</span><br><span class="line">  7355   7354 S+   ./zombie</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序运行到第10秒，此时子进程结束，变成僵尸进程</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep zombie</span><br><span class="line">  7354   3411 S+   ./zombie</span><br><span class="line">  7355   7354 Z+   [zombie] &lt;defunct&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序运行到第20秒，此时子进程已被回收，只剩下父进程</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep zombie</span><br><span class="line">  7354   3411 S+   ./zombie</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序又运行10秒，此时父进程已经退出</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep zombie</span><br></pre></td></tr></table></figure><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>与僵尸进程对应的是孤儿进程，它是指父进程在等待子进程结束之前就已经结束自身。无论何时，只要有进程结束了，内核就会遍历它的所有子进程，并且把它们的父进程重新设置为init进程（即pid为1的那个进程）。这保证了系统中不存在没有父进程的进程，从而使得每个子进程最终都能正常退出。下面我们通过代码来演示子进程到孤儿进程的转化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子进程结束\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"父进程结束\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行后，同样我们通过<code>ps -ao pid,ppid,stat,cmd | grep orphan</code>查看进程状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 程序开始执行，此时两个进程都在休眠</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep orphan</span><br><span class="line">  7989   5753 S+   ./orphan</span><br><span class="line">  7990   7989 S+   ./orphan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序运行到第10秒，此时父进程结束，子进程变成孤儿进程，内核将其ppid重设为1</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep orphan</span><br><span class="line">  7990      1 S    ./orphan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序运行到第20秒，子进程也结束</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep orphan</span><br></pre></td></tr></table></figure><h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><p>在Linux系统中，每个进程都有用户ID和组ID，它们限定了该进程可以执行哪些操作。可以通过下面4个系统调用可以查看用户ID和组ID：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206220925.png" alt=""></p><p><img src="C:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191206220814857.png" alt="image-20191206220814857"></p><p>这四个系统调用总会成功执行，因此无需进行错误判断，下面通过代码来演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uid_t</span> uid, euid;</span><br><span class="line">    <span class="keyword">gid_t</span> gid, egid;</span><br><span class="line"></span><br><span class="line">    uid = getuid();</span><br><span class="line">    euid = geteuid();</span><br><span class="line"></span><br><span class="line">    gid = getgid();</span><br><span class="line">    egid = getegid();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uid:%d\n"</span>, uid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"euid:%d\n"</span>, euid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"gid:%d\n"</span>, gid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"egid:%d\n"</span>, egid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uid:1000</span><br><span class="line">euid:1000</span><br><span class="line">gid:1000</span><br><span class="line">egid:1000</span><br></pre></td></tr></table></figure><p>上面的用户ID和组ID对应数值的名称可以在<code>/etc/passwd</code>和<code>/etc/group</code>文件中找到。为何用户ID和组ID都分别有两个？因为其含义不同，以上四个ID分别表示：实际用户ID、有效用户ID、实际用户组、有效用户组。</p><p>实际用户ID是指运行当前进程的用户uid，这个uid往往通过继承父进程而来。有效用户ID是当前进程所使用的用户ID，一般用于权限验证。事实上，远不止这两个id，其他id可以通过命令<code>ps -ao pid,uid,euid,gid,egid,ruid,suid,cmd</code>来查看，这里不再一一解释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PID   UID  EUID   GID  EGID  RUID  SUID CMD</span><br><span class="line">1708  1000  1000  1000  1000  1000  1000 /usr/lib/xorg/Xorg vt2 </span><br><span class="line">1717  1000  1000  1000  1000  1000  1000 /usr/lib/gnome-session/gnome-session-binary </span><br><span class="line">1859  1000  1000  1000  1000  1000  1000 /usr/bin/gnome-shell</span><br><span class="line">1918  1000  1000  1000  1000  1000  1000 ibus-daemon --xim --panel disable</span><br><span class="line">1922  1000  1000  1000  1000  1000  1000 /usr/lib/ibus/ibus-dconf</span><br><span class="line">1923  1000  1000  1000  1000  1000  1000 /usr/lib/ibus/ibus-extension-gtk3</span><br><span class="line">1925  1000  1000  1000  1000  1000  1000 /usr/lib/ibus/ibus-x11 --kill-daemon</span><br></pre></td></tr></table></figure><p>为何需要这么多ID呢？实际上是因为进程在运行时对于权限的需求是变化的，有可能在进程初期需要较大权限，如将用户id和组id改为root；而后，当不需要这么大权限时，本着最小权限原则，应该再将用户id和组id的权限进行降级操作。不同的id实际上是对应了进程运行的各个不同周期。一般而言，root用户可以将用户ID和组ID改为任一需要的权限，而普通用户只能在已继承的不同周期的用户权限间进行修改。</p><p>通过以下四个系统调用我们可以用于更改实际用户ID、实际用户组ID、有效用户ID和有效组ID：</p><p><img src="C:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191206224901577.png" alt="image-20191206224901577"></p><p><img src="C:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191206224932557.png" alt="image-20191206224932557"></p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206225016.png" alt=""></p><p>执行成功时，四个调用都返回0，失败时返回-1，并设置相应的errno值。下面通过代码来演示如何修改有效用户ID，其余几个函数用法类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = seteuid(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ret"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"修改成功，当前有效用户ID为:%d\n"</span>, geteuid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果我们想把当前进程的有效用户ID设置为root，那么运行此进程的时候必须是root用户，或者有root权限。</p><h3 id="会话和进程组"><a href="#会话和进程组" class="headerlink" title="会话和进程组"></a>会话和进程组</h3><p>正如同你是你家庭的一份子，每个进程都属于一个进程组。而进程组内首进程的<code>pid</code>，也就是进程组的ID。进程组的一大好处是，当你给进程组发送信号的时候，会发送给进程组内的所有进程。比如在进行作业控制的时候，你可以通过一个操作，让组内所有进程终止、暂停或是继续运行。</p><p>而多个进程组在一起则组合成了会话。通常情况下，当有新用户登录计算机，那么登录进程就会为该用户创建一个新的会话，这个新的会话包含一个单进程，即用户的登录shell。登录shell会作为会话的首进程，会话首进程的pid也就是会话ID。会话囊括了登录用户的所有活动，并分配给用户一个控制终端来处理用户的I/O行为。事实上，我们如今的控制终端与所使用的shell已经近似于一个概念。</p><p>系统中往往存在多个会话，每个用户的登录都是一个会话，但还有一些是与用户登录会话无关的进程（例如守护进程）。守护进程往往会创建自己的会话，从而避免与其他存在的会话产生关系。每个会话都包含一个或多个进程组，而且每个进程组至少包含一个进程。包含多个进程的进程组通常是为了完成一系列任务而存在。</p><p>在登录时，shell会创建新的会话，通过<code>setsid</code>系统调用完成：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191207104401.png" alt=""></p><p>假如调用进程不是某个进程组首进程，调用<code>setsid</code>会创建新的会话，并在该会话内创建新的进程组，调用进程就是新会话和新进程组内的唯一进程，会话ID和进程组ID都被设置为调用进程的pid，此会话没有控制终端。这个特性对于守护进程而言非常有用，因为它不想是任何已存在会话的成员，也不想拥有控制终端。对于shell来说，它也很有用，因为shell希望为每一个登录的用户创建新的会话。</p><p>成功时，<code>setsid</code>会返回新会话的会话ID。出错时，返回-1，并设置相应的errno值。下面通过代码来演示如何在子进程中开启一个新的会话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前父进程会话ID：%d\n"</span>, getsid(<span class="number">0</span>));</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前子进程会话ID：%d\n"</span>, getsid(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (setsid() == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"setsid"</span>);</span><br><span class="line">            _exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"创建新会话成功,当前会话ID:%d\n"</span>, getsid(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前父进程会话ID：1706</span><br><span class="line">当前子进程会话ID：1706</span><br><span class="line">创建新会话成功,当前回话ID:21891</span><br></pre></td></tr></table></figure><p>上面用到了一个系统调用<code>getsid</code>用于获取当前进程的会话ID：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191207112659.png" alt=""></p><p>当参数<code>pid</code>为0，就返回调用进程的会话ID。出错时，返回-1，并设置相应的errno值。通常情况下，这一系统调用并不常用，它主要用于诊断问题。</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程运行在后台，不与任何控制终端相关联。守护进程通常在系统启动时就运行，它们以root用户或者其他特殊的用户（例如nginx或ssh)运行，并处理一些系统级的任务。习惯上守护进程的名字通常以d结尾(如crond和sshd)，但这不是必需的，甚至不是通用的。对于守护进程，有两个基本要求：一是必须作为init进程的子进程运行，一是不与任何控制终端交互。</p><p>一般而言，进程可以通过以下步骤成为守护进程：</p><ol><li>调用fork，创建新的子进程</li><li>在父进程中调用exit</li><li>调用<code>setsid</code>，创建新的会话和进程组，并把当前子进程作为会话的首进程</li><li>调用<code>chdir</code>，将当前工作目录改为根目录。以防止当前继承而来的工作目录所在的文件系统无法被正常卸载</li><li>关闭所有文件描述符</li><li>打开文件描述符0、1、2，并把他们重定向到/dev/null</li></ol><p>以下是一个编写守护进程的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建新进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 退出父进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新会话和新进程组</span></span><br><span class="line">    <span class="keyword">if</span> (setsid() == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsid"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置工作目录为根</span></span><br><span class="line">    <span class="keyword">if</span> (chdir(<span class="string">"/"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"chdir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭所有文件描述符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">close</span>(i) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定向文件描述符0 1 2 到/dev/null</span></span><br><span class="line">    <span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">    dup(<span class="number">0</span>);</span><br><span class="line">    dup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下为守护进程自己的任务</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，很多UNIX系统在C库中提供了<code>daemon</code>函数来自动完成这些工作：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191207122136.png" alt=""></p><p>如果参数<code>nochdir</code>为非0值，就不会将工作目录改为根目录。如果参数<code>noclose</code>为非0值，就不会关闭所有打开的文件描述符。成功时，返回0。失败时，返回-1，并设置相应的errno值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们写完代码，经过编译生成的可执行二进制文件称作程序。程序保存在磁盘上，它是一个静态概念。而当程序被加载到内存中开始执行时，此时它又是动态的，被称作进程。一个进程涉及到很多方面，如：正在执行的二进制文件、虚拟内存、进程体系、进程状态、进程资源以及调度等等。下面的内容主要来谈谈进程的基本概念和管理。
    
    </summary>
    
    
      <category term="Linux" scheme="https://linxiao.pro/categories/Linux/"/>
    
    
      <category term="C" scheme="https://linxiao.pro/tags/C/"/>
    
      <category term="系统编程" scheme="https://linxiao.pro/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://linxiao.pro/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>linux系统编程-系统属性</title>
    <link href="https://linxiao.pro/2019/12/04/linux-programming-sys-info/"/>
    <id>https://linxiao.pro/2019/12/04/linux-programming-sys-info/</id>
    <published>2019-12-04T10:24:26.000Z</published>
    <updated>2019-12-04T02:24:26.231Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统在运行时依赖大量的属性及配置文件，相信不少人深有体会。举个例子，比方说在执行<code>ls</code>命令或登录时，其实就会查看<code>/etc/passwd</code>和<code>/etc/group</code>文件，来确认当前进程是否有足够权限来执行操作。由于历史原因，系统中很多属性和配置都是以文本文件来存储，通过I/O的方式来直接操作这些数据并不高效，但有时又不得不用。更多时候，则倾向于使用系统调用或C库函数来操作系统属性。<a id="more"></a></p><h3 id="密码文件"><a href="#密码文件" class="headerlink" title="密码文件"></a>密码文件</h3><p>UNIX系统密码文件通常存储了用户基本信息，通过<code>cat /etc/passwd</code>命令可查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">gdm:x:123:128:Gnome Display Manager:/var/lib/gdm3:/bin/false</span><br><span class="line">noir:x:1000:1000:Darling,,,:/home/noir:/usr/bin/zsh</span><br><span class="line">sshd:x:124:65534::/run/sshd:/usr/sbin/nologin</span><br><span class="line">alan:x:1001:1001:Alan,,,:/home/alan:/bin/bash</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>字段之间用冒号分隔，含义依次如下：用户名:密码:用户ID:组ID:注释:主目录:登录shell。关于这些字段，以下几点需要额外注意：</p><ul><li>用户ID为0的是root用户；1~999是系统用户，它们不可登录，通常代表某一系统服务；1000及以上是普通用户</li><li>密码字段标记<code>x</code>时，表明该用户有密码，否则无。早期UNIX系统直接使用该字段存放密码，但由于<code>passwd</code>文件对所有用户开放可读权限，为了安全起见，现在将密码保存在<code>shadow</code>文件中</li><li>注释用于保存用户全名、地址、电话等信息，每个部分用逗号分隔，可以为空</li><li>登录shell是一个可执行程序，代表用户登录时所使用的shell环境，如果为空会取系统默认值，通常是<code>/bin/sh</code>。如果要阻止一个用户登录，那么可以使用<code>/bin/false</code>或<code>nologin</code>命令</li></ul><h4 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h4><p>以下两个库函数，可查看密码文件中的特定用户信息：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191203/20191203164731.png" alt=""></p><p>调用成功时，这两个函数都会返回一个指向结构体<code>passwd</code>的指针。区别在于<code>getpwnam</code>函数通过用户名<code>name</code>查询，而<code>getpwuid</code>通过用户<code>uid</code>查询。若没有相关用户信息或调用失败，则返回NULL，并设置相应的errno值。返回的结构体<code>passwd</code>是函数内部的静态变量，只要调用任一相关函数，其内容就会被重写，使用完后不需要通过<code>free</code>函数释放。再来看看结构体<code>passwd</code>中字段，其实是和<code>passwd</code>文件一一对应的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_name;       <span class="comment">/* username */</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_passwd;     <span class="comment">/* user password */</span></span><br><span class="line">    <span class="keyword">uid_t</span>   pw_uid;        <span class="comment">/* user ID */</span></span><br><span class="line">    <span class="keyword">gid_t</span>   pw_gid;        <span class="comment">/* group ID */</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_gecos;      <span class="comment">/* user information */</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_dir;        <span class="comment">/* home directory */</span></span><br><span class="line">    <span class="keyword">char</span>   *pw_shell;      <span class="comment">/* shell program */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面用一个例子来演示如何通过用户名来查看用户基本信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">ptr</span>;</span></span><br><span class="line">    ptr = getpwnam(<span class="string">"alan"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"username:%20s\n"</span>, ptr-&gt;pw_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"password:%20s\n"</span>, ptr-&gt;pw_passwd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"userId:  %20u\n"</span>, ptr-&gt;pw_uid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"groupId: %20u\n"</span>, ptr-&gt;pw_gid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"home:    %20s\n"</span>, ptr-&gt;pw_dir);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shell:   %20s\n"</span>, ptr-&gt;pw_shell);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">username:                alan</span><br><span class="line">password:                   x</span><br><span class="line">userId:                  1001</span><br><span class="line">groupId:                 1001</span><br><span class="line">home:              /home/alan</span><br><span class="line">shell:              /bin/bash</span><br></pre></td></tr></table></figure><p>此外，如果知道用户ID（比如通过<code>stat</code>系统调用获取到的文件所有者ID），那么也可以反查得到用户信息，只需要将<code>getpwnam</code>替换成<code>getpwuid</code>，并且传入参数<code>uid</code>即可，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = getpwuid(<span class="number">1001</span>);</span><br></pre></td></tr></table></figure><p>两个函数返回的结构体数据完全一样。</p><h4 id="遍历用户信息"><a href="#遍历用户信息" class="headerlink" title="遍历用户信息"></a>遍历用户信息</h4><p>有时候需要查询所有用户信息，那么需要使用到以下三个函数：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191203/20191203214534.png" alt=""></p><p>与上面两个函数一样，<code>getpwent</code>返回一个结构体<code>passwd</code>的指针，第一次调用时，它会返回第一个账户信息，多次调用它会依次返回后续账户信息。当没有更多数据或调用失败时，返回NULL，并设置相应的errno值。<code>setpwent</code>函数用于回转到数据项开头，<code>endpwent</code>函数用于关闭数据表。下面通过代码来演示遍历所有用户名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    setpwent();</span><br><span class="line">    <span class="keyword">while</span> ((ptr = getpwent()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>, ptr-&gt;pw_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"getpwent"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    endpwent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root daemon bin sys sync games ...</span><br></pre></td></tr></table></figure><h3 id="阴影文件"><a href="#阴影文件" class="headerlink" title="阴影文件"></a>阴影文件</h3><p>阴影文件用于保存用户密码，此密码是被加密过的。加密算法通常是单向加密，所以无法从现有密码推导出到原始密码。常见的加密算法有MD5或SHA-1等。早期UNIX用户密码存放在<code>passwd</code>文件中，虽然无法反向得到明文密码，但仍然可以根据一些信息（如宠物名、生日、地址）生成密码，然后与密码文件中的密码进行试探匹配。由于<code>passwd</code>文件可被所有用户读取，其安全性并不高。为了弥补这一漏洞，Linux将用户密码放到<code>shadow</code>文件保存。可以尝试通过<code>cat /etc/shadow</code>命令查看此文件内容，即发现权限不够。因此，需要通过<code>sudo</code>提升权限，或以<code>root</code>身份执行此命令。现在来看看其中内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root:$6$pTBylslXVge8c58P$FdsFUJTLQRjHHjnAFntbioy6NcqdaWx4PaY4Y6qlQWn5Jg3VDhusx..ZuyHjv.r5szUcvHt1NH.AYFj4OvsPr1:18179:0:99999:7:::</span><br><span class="line">daemon:*:18002:0:99999:7:::</span><br><span class="line">bin:*:18002:0:99999:7:::</span><br><span class="line">sys:*:18002:0:99999:7:::</span><br><span class="line">gdm:*:18002:0:99999:7:::</span><br><span class="line">noir:$1$UyI9Ho1i$0KUjbgs9EuPeqNCjGj2mX1:18111:0:99999:7:::</span><br><span class="line">systemd-coredump:!!:18111::::::</span><br><span class="line">sshd:*:18111:0:99999:7:::</span><br><span class="line">alan:$6$NQqf17Ugjh./.9Ej$wH9EnSvyCGWj4CWF1Hea63OzRyO2kIpg12dGL0WRGvZGNo4H58VB5BkNRnxJpoBdDugVvSwaMhO58mCmslQ7d.:18232:0:99999:7:::</span><br></pre></td></tr></table></figure><p>本文件中的字段也是通过冒号来进行分隔，其含义依次是：用户名:加密密码:上次更改密码的时间:最小更改密码间隔:密码有效期限:密码过期提示时间:密码锁定期:账户有效期:保留字段。</p><h4 id="查看用户密码信息"><a href="#查看用户密码信息" class="headerlink" title="查看用户密码信息"></a>查看用户密码信息</h4><p>操作<code>/etc/shadow</code>文件同样有一组函数可用，这里只讲解其中最常用的几个，我们先来看如何通过<code>getspnam</code>来获取指定用户的密码信息：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191203/20191203222941.png" alt=""></p><p>参数<code>name</code>为需要查看的用户名，当调用成功时，返回指向结构体<code>spwd</code>的指针；调用失败或没有数据时，返回NULL，并设置相应的errno值。结构体<code>spwd</code>中的字段，其与<code>/etc/shadow</code>文件中的字段保持一致：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spwd</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *sp_namp;     <span class="comment">/* Login name */</span></span><br><span class="line">    <span class="keyword">char</span> *sp_pwdp;     <span class="comment">/* Encrypted password */</span></span><br><span class="line">    <span class="keyword">long</span>  sp_lstchg;   <span class="comment">/* Date of last change</span></span><br><span class="line"><span class="comment">                                     (measured in days since</span></span><br><span class="line"><span class="comment">                                     1970-01-01 00:00:00 +0000 (UTC)) */</span></span><br><span class="line">    <span class="keyword">long</span>  sp_min;      <span class="comment">/* Min # of days between changes */</span></span><br><span class="line">    <span class="keyword">long</span>  sp_max;      <span class="comment">/* Max # of days between changes */</span></span><br><span class="line">    <span class="keyword">long</span>  sp_warn;     <span class="comment">/* # of days before password expires</span></span><br><span class="line"><span class="comment">                                     to warn user to change it */</span></span><br><span class="line">    <span class="keyword">long</span>  sp_inact;    <span class="comment">/* # of days after password expires</span></span><br><span class="line"><span class="comment">                                     until account is disabled */</span></span><br><span class="line">    <span class="keyword">long</span>  sp_expire;   <span class="comment">/* Date when account expires</span></span><br><span class="line"><span class="comment">                                     (measured in days since</span></span><br><span class="line"><span class="comment">                                     1970-01-01 00:00:00 +0000 (UTC)) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sp_flag;  <span class="comment">/* Reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面用一个例子来演示获取用户<code>alan</code>的加密密码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shadow.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spwd</span> *<span class="title">ptr</span>;</span></span><br><span class="line">    ptr = getspnam(<span class="string">"alan"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"getspnam"</span>) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Encrypted passwd:%s\n"</span>, ptr-&gt;sp_pwdp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Encrypted passwd:$6$NQqf17Ugjh./.9Ej$wH9EnSvyCGWj4CWF1Hea63OzRyO2kIpg12dGL0WRGvZGNo4H58VB5BkNRnxJpoBdDugVvSwaMhO58mCmslQ7d.</span><br></pre></td></tr></table></figure><p>需要注意的是，编译成功后，执行此程序需要通过<code>sudo</code>提升权限，或以<code>root</code>身份执行。</p><h4 id="遍历用户密码信息"><a href="#遍历用户密码信息" class="headerlink" title="遍历用户密码信息"></a>遍历用户密码信息</h4><p>遍历时需要使用的函数上图已经给出，分别是<code>getspent</code>、<code>setspent</code>和<code>endspent</code>。<code>getspent</code>函数返回指向下一个用户密码信息数据项的指针，<code>setspent</code>函数用于回转数据项到初始位置，当数据读取完毕后，还需要通过<code>endspent</code>函数关闭数据流以释放资源。下面通过代码演示如何遍历用户密码信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shadow.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spwd</span> *<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    setspent();</span><br><span class="line">    <span class="keyword">while</span> ((ptr = getspent()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"username:%20s      last change:%10ld\n"</span>, ptr-&gt;sp_namp, ptr-&gt;sp_lstchg);</span><br><span class="line">    &#125;</span><br><span class="line">    endspent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  sudo ./a.out </span><br><span class="line">username:                root      last change:     18179</span><br><span class="line">username:              daemon      last change:     18002</span><br><span class="line">username:                 bin      last change:     18002</span><br><span class="line">username:                 sys      last change:     18002</span><br><span class="line">username:                sync      last change:     18002</span><br><span class="line">username:               games      last change:     18002</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="组文件"><a href="#组文件" class="headerlink" title="组文件"></a>组文件</h3><p>组文件用于保存组信息，可以通过<code>cat /etc/group</code>命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:</span><br><span class="line">bin:x:2:</span><br><span class="line">sys:x:3:</span><br><span class="line">adm:x:4:syslog,noir</span><br><span class="line">sudo:x:27:noir</span><br><span class="line">ssh:x:117:</span><br><span class="line">gdm:x:128:</span><br><span class="line">noir:x:1000:</span><br><span class="line">sambashare:x:129:noir</span><br><span class="line">systemd-coredump:x:999:</span><br><span class="line">alan:x:1001:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>依旧使用冒号分隔，从左到右每个字段的分别代表：组名:组密码:组ID:组成员。</p><h4 id="查看组信息"><a href="#查看组信息" class="headerlink" title="查看组信息"></a>查看组信息</h4><p>可以使用下面两个函数来查看组相关信息：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191203/20191203191429.png" alt=""></p><p><code>getgrnam</code>用于查看指定组名<code>name</code>的相关信息，若已经有组ID，则可使用<code>getgrgid</code>来获取组信息。两者调用成功时，都返回结构体<code>group</code>；若没有相关数据或调用失败则返回NULL，并设置相应的errno值。</p><p>下面来看结构体<code>group</code>数据，与<code>/etc/group</code>中字段是保持一致的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>   *gr_name;        <span class="comment">/* group name */</span></span><br><span class="line">    <span class="keyword">char</span>   *gr_passwd;      <span class="comment">/* group password */</span></span><br><span class="line">    <span class="keyword">gid_t</span>   gr_gid;         <span class="comment">/* group ID */</span></span><br><span class="line">    <span class="keyword">char</span>  **gr_mem;         <span class="comment">/* NULL-terminated array of pointers to names of group members */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字段<code>gr_mem</code>是一个指针数组，其中每个指针指向一个属于该组的成员。该数组以NULL指针结尾。如同对密码文件进行操作的函数一样，这两个函数通常也返回指向一个静态变量的指针，在每次调用时都重写该静态变量。</p><p>下面通过代码来演示，读取组<code>adm</code>的相关信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shadow.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">ptr</span>;</span></span><br><span class="line">    ptr = getgrnam(<span class="string">"adm"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"getgrnam"</span>) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"group name:       %s\n"</span>, ptr-&gt;gr_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"group password:   %s\n"</span>, ptr-&gt;gr_passwd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"group ID:         %d\n"</span>, ptr-&gt;gr_gid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> **name = ptr-&gt;gr_mem;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"group member:     "</span>);</span><br><span class="line">    <span class="keyword">while</span> (*name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>, *name);</span><br><span class="line">        name++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">group name:       adm</span><br><span class="line">group password:   x</span><br><span class="line">group ID:         4</span><br><span class="line">group member:     syslog noir</span><br></pre></td></tr></table></figure><h4 id="遍历组信息"><a href="#遍历组信息" class="headerlink" title="遍历组信息"></a>遍历组信息</h4><p>估计你也猜到了，遍历组信息同样需要使用三个函数：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191203/20191203232028.png" alt=""></p><p><code>getgrent</code>函数从组文件中读取下一个记录，如若该文件尚未打开，则先打开它。<code>setgrent</code>函数打开组文件（如若它尚未被打开)，并回转到初始位置。<code>endgrent</code>函数关闭组文件。下面来看代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    setgrent();</span><br><span class="line">    <span class="keyword">while</span> ((ptr = getgrent()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"group name:%20s    group ID:%5d\n"</span>, ptr-&gt;gr_name, ptr-&gt;gr_gid);</span><br><span class="line">    &#125;</span><br><span class="line">    endgrent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">group name:                root    group ID:    0</span><br><span class="line">group name:              daemon    group ID:    1</span><br><span class="line">group name:                 bin    group ID:    2</span><br><span class="line">group name:                 sys    group ID:    3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="其他属性文件"><a href="#其他属性文件" class="headerlink" title="其他属性文件"></a>其他属性文件</h3><p>上面讨论了三个系统属性文件：密码文件、阴影文件和组文件。而实际应用中，Linux还使用了很多其他属性文件。幸运的是，这些属性文件的接口都与上述我们所演示的接口相似。一般情况下，对于每个系统属性文件的操作至少有3个函数接口：</p><ul><li>get函数：读取下一条记录，如果文件没打开，则会先打开文件。此类函数通常返回指向一个结构体的指针，需要依次遍历，当已达到文件尾端时返回空指针。大多数get函数返回指向一个静态存储类结构的指针，如果要保存其内容，则需复制它。</li><li>set函数：打开相应属性文件（若尚未打开），并回转到文件起始位置。如果希望在相应文件起始处开始处理，则调用此函数。</li><li>end函数：关闭相应属性文件。如之前所述，在结束对属性文件的读、写操作后，总应调用此函数关闭所有相关文件。</li></ul><p>另外，如果属性文件支持某种形式的键搜索，则也会提供通过键返回指定信息的函数接口。例如密码文件，提供了两个函数<code>getpwnam</code>和<code>getpwuid</code>，分别用于从用户名和用户ID查询并返回相关记录。</p><p>下面列举了一些常用的属性文件及其数据访问接口，以供参考：</p><table><thead><tr><th>说明</th><th>属性文件</th><th>头文件</th><th>结构体</th><th>键搜索函数</th></tr></thead><tbody><tr><td>密码</td><td>/etc/passwd</td><td>&lt;pwd.h&gt;</td><td>passwd</td><td>getpwnam、getpwuid</td></tr><tr><td>组</td><td>/etc/group</td><td>&lt;grp.h&gt;</td><td>group</td><td>getgrnam、getgrgid</td></tr><tr><td>阴影</td><td>/etc/shadow</td><td>&lt;shadow.h&gt;</td><td>spwd</td><td>getspnam</td></tr><tr><td>主机</td><td>/etc/hosts</td><td>&lt;netdb.h&gt;</td><td>hostent</td><td>getnameinfo、getaddrinfo</td></tr><tr><td>网络</td><td>/etc/networks</td><td>&lt;netdb.h&gt;</td><td>netent</td><td>getnetbyname、getnetbyaddr</td></tr><tr><td>协议</td><td>/etc/protocols</td><td>&lt;netdb.h&gt;</td><td>protoent</td><td>getprotobyname、getprotobynumber</td></tr><tr><td>服务</td><td>/etc/services</td><td>&lt;netdb.h&gt;</td><td>servent</td><td>getservbyname、getservbyport</td></tr></tbody></table><h3 id="系统标识"><a href="#系统标识" class="headerlink" title="系统标识"></a>系统标识</h3><p>通过命令<code>uname -a</code>可以查看主机和操作系统的相关信息，在代码中，则是使用<code>uname</code>系统调用做到：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191203/20191204100457.png" alt=""></p><p>参数<code>buf</code>是需要传入的结构体<code>utsname</code>的指针，当调用成功时，会自动填充此结构体，并返回0。失败时，返回-1，并设置相应的errno值。下面是<code>utsname</code>的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> sysname[];    <span class="comment">/* Operating system name (e.g., "Linux") */</span></span><br><span class="line">    <span class="keyword">char</span> nodename[];   <span class="comment">/* Name within "some implementation-defined network" */</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">release</span>[];    <span class="comment">/* Operating system release (e.g., "2.6.28") */</span></span><br><span class="line">    <span class="keyword">char</span> version[];    <span class="comment">/* Operating system version */</span></span><br><span class="line">    <span class="keyword">char</span> machine[];    <span class="comment">/* Hardware identifier */</span></span><br><span class="line">    <span class="keyword">char</span> domainname[]; <span class="comment">/* NIS or YP domain name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过代码来演示打印系统标识信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = uname(&amp;ptr);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"uname"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sysname:  %s\n"</span>, ptr.sysname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nodename: %s\n"</span>, ptr.nodename);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"release:  %s\n"</span>, ptr.<span class="built_in">release</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"version:  %s\n"</span>, ptr.version);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"machine:  %s\n"</span>, ptr.machine);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要讲解了如何通过系统调用和函数来访问系统属性文件，并列举了三个例子：密码文件、阴影文件和组文件。其实系统属性文件的操作方式都是类似，通常情况下会提供一组遍历接口和一组键查询接口。当然，还有些存在于<code>/etc</code>下的属性和配置文件并没有访问接口，此时需要我们通过传统的I/O方式进行操作。除了<code>/etc</code>下的文件，虚拟文件系统<code>/proc</code>则提供了诸多系统运行时所需要的信息，其中的各类文件也是以I/O的操作方式居多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux系统在运行时依赖大量的属性及配置文件，相信不少人深有体会。举个例子，比方说在执行&lt;code&gt;ls&lt;/code&gt;命令或登录时，其实就会查看&lt;code&gt;/etc/passwd&lt;/code&gt;和&lt;code&gt;/etc/group&lt;/code&gt;文件，来确认当前进程是否有足够权限来执行操作。由于历史原因，系统中很多属性和配置都是以文本文件来存储，通过I/O的方式来直接操作这些数据并不高效，但有时又不得不用。更多时候，则倾向于使用系统调用或C库函数来操作系统属性。
    
    </summary>
    
    
      <category term="Linux" scheme="https://linxiao.pro/categories/Linux/"/>
    
    
      <category term="C" scheme="https://linxiao.pro/tags/C/"/>
    
      <category term="系统编程" scheme="https://linxiao.pro/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux系统编程-文件与目录管理</title>
    <link href="https://linxiao.pro/2019/12/03/linux-programming-file-and-directory/"/>
    <id>https://linxiao.pro/2019/12/03/linux-programming-file-and-directory/</id>
    <published>2019-12-03T11:03:01.000Z</published>
    <updated>2019-12-03T03:03:01.309Z</updated>
    
    <content type="html"><![CDATA[<p>之前讨论过大量关于文件I/O的系统调用，现在我们的视角从文件内部回到文件本身。在Linux中一切皆为文件，而文件包含大量的元数据。诸如：类型、权限、硬链接、软连接、所属用户、所属组、最后访问时间、最后修改时间、最后状态改变时间等。本篇主要讲解文件这些属性的获取与管理。<a id="more"></a></p><h3 id="从ls说起"><a href="#从ls说起" class="headerlink" title="从ls说起"></a>从ls说起</h3><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191130/20191130090457.png" alt=""></p><p>当需要查看文件属性的时候，通常使用最多的命令是<code>ls -l</code>，上图说明了各列所代表的含义，这里挑出以下两列进行补充说明：</p><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p><code>ls -l</code>命令所列文件属性的中第一列第一个字母代表文件类型，Linux文件一共分为7大类，用字母和符号<code>-</code>表示，其含义分别是：</p><ul><li><code>-</code> 普通文件</li><li><code>d</code> 目录文件，用于管理目录项，保存文件名和文件节点</li><li><code>c</code> 字符设备文件，如：/dev/input 下的键盘、鼠标</li><li><code>b</code> 块设备文件，如：/dev/下的磁盘。与字符设备的区别在于：块设备文件是以块（如4096字节）为单位来操作数据，而前者是以字节为单位来操作数据</li><li><code>p</code> FIFO管道文件，用于实现不同进程之间的通信</li><li><code>s</code> socket文件，用于网络通信</li><li><code>l</code> 符号链接文件，类似于Windows中的快捷方式，实则是指向另外一个文件的路径</li></ul><h4 id="硬链接数"><a href="#硬链接数" class="headerlink" title="硬链接数"></a>硬链接数</h4><p>每个文件在文件系统中是用一个<code>inode(索引节点)</code>来表示，同时<code>inode编号</code>也是文件系统中表示此文件的唯一数值。通常一个<code>inode节点</code>至少有一个硬链接，由此我们便可通过硬链接对该文件节点进行索引。如果一个文件有多个硬链接，那么每个硬链接所指向的<code>inode</code>节点是一样的，换句话说，他们只是这个文件节点的不同名字而已。如果一个<code>inode节点</code>的所有硬链接都被删除，那么它也就没有存在的价值，相当于是文件节点被删除。通过<code>ls -li</code>命令可以查看一个文件的<code>inode编号</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  touch a.txt                                # 创建文件</span><br><span class="line">➜  ln a.txt b.txt                             # 创建该文件的硬链接</span><br><span class="line">➜  ls -l                                      # 查看文件硬链接数</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r-- 2 noir noir 0 11月 29 18:08 a.txt</span><br><span class="line">-rw-r--r-- 2 noir noir 0 11月 29 18:08 b.txt</span><br><span class="line">➜  ls -li                                     # 查看硬链接所指向的文件inode节点编号</span><br><span class="line">总用量 0</span><br><span class="line">1441898 -rw-r--r-- 2 noir noir 0 11月 29 18:08 a.txt</span><br><span class="line">1441898 -rw-r--r-- 2 noir noir 0 11月 29 18:08 b.txt</span><br></pre></td></tr></table></figure><h3 id="stat系统调用"><a href="#stat系统调用" class="headerlink" title="stat系统调用"></a>stat系统调用</h3><p>要想实现类似于<code>ls -l</code>这样的功能，我们先要了解<code>stat</code>相关的系统调用</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191130/20191130105045.png" alt=""></p><p><code>stat</code>是一组函数，用于获取文件的元数据。上面三个函数的区别在于：<code>stat</code>函数会返回由参数<code>pathname</code>所指定的文件信息，而<code>fstat</code>返回由文件描述符<code>fd</code>所指向的文件信息。<code>lstat</code>与<code>stat</code>类似，唯一的区别是对于符号链接，<code>lstat</code>返回的是链接本身而非目标文件。以上三个函数调用出错时会返回-1，并设置相应的errno值，而调用成功，则将元数据存储在<code>stat</code>结构体中，即<code>statbuf</code>参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_dev;         <span class="comment">/* 文件所位于的设备节点ID，若文件不在本地，如在网络文件系统上，则该值为0 */</span></span><br><span class="line">    <span class="keyword">ino_t</span>     st_ino;         <span class="comment">/* 文件属性信息所在inode节点的编号 */</span></span><br><span class="line">    <span class="keyword">mode_t</span>    st_mode;        <span class="comment">/* 文件类型和访问权限 */</span></span><br><span class="line">    <span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">/* 文件节点的所有硬链接数 */</span></span><br><span class="line">    <span class="keyword">uid_t</span>     st_uid;         <span class="comment">/* 文件所有者的ID */</span></span><br><span class="line">    <span class="keyword">gid_t</span>     st_gid;         <span class="comment">/* 文件所属组的ID */</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_rdev;        <span class="comment">/* 如果文件是设备节点，则该字段描述设备节点ID */</span></span><br><span class="line">    <span class="keyword">off_t</span>     st_size;        <span class="comment">/* 文件大小字节数 */</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize;     <span class="comment">/* 文件系统进行I/O操作时的块大小，该值（或倍数）为用户缓冲I/O的最佳块大小 */</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* 分配给文件的块数目 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* 最近一次文件被访问的时间（读） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* 最近一次文件被修改的的时间（写） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* 最近一次文件状态改变的时间（所有者、所属组或权限变更） */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面可以看到关于块设备、时间的数据，这是通过<code>ls -l</code>无法获取的，此时可以使用<code>stat</code>命令。没错，<code>stat</code>既是系统调用，同时也是一个Linux命令，用于查看文件属性详细信息。需要注意的是Linux并不保存文件创建时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  stat cmake-3.15.1.tar.gz</span><br><span class="line">  File: cmake-3.15.1.tar.gz</span><br><span class="line">  Size: 9268592   Blocks: 18104      IO Block: 4096   regular file</span><br><span class="line">Device: 801h/2049dInode: 1966105     Links: 1</span><br><span class="line">Access: (0664/-rw-rw-r--)  Uid: ( 1000/    noir)   Gid: ( 1000/    noir)</span><br><span class="line">Access: 2019-08-05 02:54:52.985260332 -0700</span><br><span class="line">Modify: 2019-08-05 02:54:26.640913268 -0700</span><br><span class="line">Change: 2019-08-05 02:54:30.236958359 -0700</span><br></pre></td></tr></table></figure><p>下面我们来写一个例子<code>main.c</code>，用来读取自身的基本信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">"main.c"</span>, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"文件类型及权限：%o\t"</span>, buf.st_mode);        <span class="comment">// 输出文件类型和权限</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"硬链接数：%ld\t"</span>, buf.st_nlink);           <span class="comment">// 输出文件硬链接数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者：%d\t"</span>, buf.st_uid);                <span class="comment">// 输出文件所有者</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组：%d\t"</span>, buf.st_gid);                <span class="comment">// 输出文件所属组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"大小：%ld字节\t"</span>, buf.st_size);            <span class="comment">// 输出文件大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最后访问时间：%ld\t"</span>, buf.st_atim.tv_sec); <span class="comment">// 输出文件最后访问时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件类型及权限：100664硬链接数：1所有者：1000所属组：1000大小：79字节最后访问时间：1574991522</span><br></pre></td></tr></table></figure><p>可见，除了硬链接数和文件大小能很清晰的知道其含义，其余几个字段并不像<code>ls -l</code>输出那般直观。但仔细想想，所有者和所属组用数字表示，应该是指代ID，从<code>/etc/passwd</code>和<code>/etc/group</code>文件中可以很容易找到其对应的名称。而最后访问时间，看这长度也能联想到，它指代Unix时间戳。如何从用户ID及组ID反向得到名称，以及解析时间属于系统信息相关内容，暂时先放到后续篇章吧。本文主要讲述文件属性，所以我们先把注意力放到文件类型解析和权限上面。</p><h4 id="文件类型解析"><a href="#文件类型解析" class="headerlink" title="文件类型解析"></a>文件类型解析</h4><p>通过代码来演示如何解析文件类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">"main.c"</span>, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File type:"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (buf.st_mode &amp; S_IFMT) &#123;</span><br><span class="line">        <span class="keyword">case</span> S_IFBLK:  <span class="built_in">printf</span>(<span class="string">"block device\n"</span>);            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR:  <span class="built_in">printf</span>(<span class="string">"character device\n"</span>);        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR:  <span class="built_in">printf</span>(<span class="string">"directory\n"</span>);               <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO:  <span class="built_in">printf</span>(<span class="string">"FIFO/pipe\n"</span>);               <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK:  <span class="built_in">printf</span>(<span class="string">"symlink\n"</span>);                 <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG:  <span class="built_in">printf</span>(<span class="string">"regular file\n"</span>);            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFSOCK: <span class="built_in">printf</span>(<span class="string">"socket\n"</span>);                  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:       <span class="built_in">printf</span>(<span class="string">"unknown?\n"</span>);                <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File type:regular file</span><br></pre></td></tr></table></figure><p>可以看到上述代码的关键步骤，其实是把<code>st_mode</code>&amp;<code>S_IFMT</code>，然后通过匹配一系列宏来得到具体文件类型。为什么可以这样做，首先我们从<code>st_mode</code>说起。上面打印出的<code>st_mode</code>是八进制的100664，我们将其转换成二进制来看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OCT    100 664</span><br><span class="line">BIN    1000 000 110 110 100</span><br></pre></td></tr></table></figure><p>上面的二进制位中，第0-8位代表访问权限，13-15位代表文件类型。先记住这个规律，然后再来看<code>S_IFMT</code>宏，我们可以先在<code>sys/stat.h</code>中找到其定义，然后在<code>bits/stat.h</code>中找到最终定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span>   S_IFMT__S_IFMT</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span>   __S_IFMT    0170000 <span class="comment">/* These bits determine file type.  *</span></span></span><br></pre></td></tr></table></figure><p>可以看到<code>S_IFMT</code>实际上是一串八进制码，现在将其转换成二进制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OCT    0170000</span><br><span class="line">BIN    1111 000 000 000 000</span><br></pre></td></tr></table></figure><p>所以，一旦<code>st_mode</code>&amp;<code>S_IFMT</code>，实际上也就是说，0-12位被屏蔽了，剩下的13-15位代表真正的文件类型，我们拿着它和文件类型的宏定义进行匹配就行了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st_mode    1000 000 110 110 100   </span><br><span class="line">&amp;</span><br><span class="line">S_IFMT     1111 000 000 000 000</span><br><span class="line">-------------------------------</span><br><span class="line">           1000 000 000 000 000</span><br></pre></td></tr></table></figure><p>再来看文件类型宏定义，同样先在<code>sys/stat.h</code>中找到其定义，然后在<code>bits/stat.h</code>中找到最终定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> S_IFDIR__S_IFDIR</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> S_IFCHR__S_IFCHR</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> S_IFBLK__S_IFBLK</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> S_IFREG__S_IFREG</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> S_IFIFO__S_IFIFO</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> S_IFLNK__S_IFLNK</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> S_IFSOCK__S_IFSOCK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* File types.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFDIR0040000<span class="comment">/* Directory. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFCHR0020000<span class="comment">/* Character device.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFBLK0060000<span class="comment">/* Block device.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFREG0100000<span class="comment">/* Regular file.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFIFO0010000<span class="comment">/* FIFO.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFLNK0120000<span class="comment">/* Symbolic link.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IFSOCK0140000<span class="comment">/* Socket.  */</span></span></span><br></pre></td></tr></table></figure><p>上面的代码并不太直观，我们进行一个整理，列出下表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">文件类型    八进制码    二进制码  </span><br><span class="line">S_IFDIR   0040000    0100 000 000 000 000</span><br><span class="line">S_IFCHR   0020000    0010 000 000 000 000</span><br><span class="line">S_IFBLK   0060000    0110 000 000 000 000</span><br><span class="line">S_IFREG   0100000    1000 000 000 000 000</span><br><span class="line">S_IFIFO   0010000    0001 000 000 000 000</span><br><span class="line">S_IFLNK   0120000    1010 000 000 000 000</span><br><span class="line">S_IFSOCK   0140000    1100 000 000 000 000</span><br></pre></td></tr></table></figure><p>可见，上面由<code>st_mode</code>&amp;<code>S_IFMT</code>得到的文件类型二进制码刚好与<code>S_IFREG</code>相匹配，说明此文件是普通文件。实际上在<code>sys/stat.h</code>中提供了一系列带参宏，以方便我们进行快速文件判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Test macros for file types.*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_ISTYPE(mode, mask)(((mode) &amp; __S_IFMT) == (mask))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_ISDIR(mode) __S_ISTYPE((mode), __S_IFDIR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_ISCHR(mode) __S_ISTYPE((mode), __S_IFCHR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_ISBLK(mode) __S_ISTYPE((mode), __S_IFBLK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_ISREG(mode) __S_ISTYPE((mode), __S_IFREG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISFIFO(mode) __S_ISTYPE((mode), __S_IFIFO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISLNK(mode) __S_ISTYPE((mode), __S_IFLNK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISSOCK(mode)   __S_ISTYPE((mode), __S_IFSOCK)</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">"../main.c"</span>, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Is regular file: %d\n"</span>, S_ISREG(buf.st_mode));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Is directory:    %d\n"</span>, S_ISDIR(buf.st_mode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Is regular file: 1</span><br><span class="line">Is directory:    0</span><br></pre></td></tr></table></figure><p>到这里，文件类型解析部分已讲完，下面来看看文件权限解析。</p><h4 id="文件权限解析"><a href="#文件权限解析" class="headerlink" title="文件权限解析"></a>文件权限解析</h4><p>其实文件权限解析与文件类型解析的方式如出一辙，我们先来看代码，再进行讲解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">"../main.c"</span>, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者可读取：       %o\n"</span>, S_IRUSR&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者可写入：       %o\n"</span>, S_IWUSR&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者可执行：       %o\n"</span>, S_IXUSR&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者可读写执行：    %o\n"</span>, S_IRWXU&amp;buf.st_mode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组可读取：       %o\n"</span>, S_IRGRP&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组可写入：       %o\n"</span>, S_IWGRP&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组可执行：       %o\n"</span>, S_IXGRP&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组可读写执行：    %o\n"</span>, S_IRWXG&amp;buf.st_mode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他人可读取：       %o\n"</span>, S_IROTH&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他人可写入：       %o\n"</span>, S_IWOTH&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他人可执行：       %o\n"</span>, S_IXOTH&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他人可读写执行：    %o\n"</span>, S_IRWXO&amp;buf.st_mode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"文件权限：           %o\n"</span>, (S_IRWXU&amp;buf.st_mode)|(S_IRWXG&amp;buf.st_mode)|(S_IRWXO&amp;buf.st_mode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">所有者可读取：       400</span><br><span class="line">所有者可写入：       200</span><br><span class="line">所有者可执行：       0</span><br><span class="line">所有者可读写执行：    600</span><br><span class="line">所属组可读取：       40</span><br><span class="line">所属组可写入：       20</span><br><span class="line">所属组可执行：       0</span><br><span class="line">所属组可读写执行：    60</span><br><span class="line">其他人可读取：       4</span><br><span class="line">其他人可写入：       0</span><br><span class="line">其他人可执行：       0</span><br><span class="line">其他人可读写执行：    4</span><br><span class="line">文件权限：           664</span><br></pre></td></tr></table></figure><p>通过代码可以很直观的获取每个具体权限，并得到文件的整体权限是664，换句话说，该文件权限为<code>rw-rw-r--</code>。在<code>st_mode</code>中，0~8共9位二进制码分三组来表示所有者、所属组和其他人的读、写、执行权限。如下所示，1表示该位有权限，0表示没有。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OCT    664</span><br><span class="line">       所有者  所属组  其他人</span><br><span class="line">       rwx     rwx    rwx</span><br><span class="line">BIN    110     110    100</span><br></pre></td></tr></table></figure><p>而<code>S_IRUSR S_IWUSR S_IXUSR...</code>这类宏则是用于测试二进制位是否持有对应的权限，可以在<code>sys/stat.h</code>和<code>bits/stat.h</code>中找到他们的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IRUSR__S_IREAD<span class="comment">/* Read by owner.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IWUSR__S_IWRITE<span class="comment">/* Write by owner.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IXUSR__S_IEXEC<span class="comment">/* Execute by owner.  */</span></span></span><br><span class="line"><span class="comment">/* Read, write, and execute by owner.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IRWXU(__S_IREAD|__S_IWRITE|__S_IEXEC)  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IREAD0400<span class="comment">/* Read by owner.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IWRITE0200<span class="comment">/* Write by owner.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>__S_IEXEC0100<span class="comment">/* Execute by owner.  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IRGRP(S_IRUSR &gt;&gt; 3)<span class="comment">/* Read by group.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IWGRP(S_IWUSR &gt;&gt; 3)<span class="comment">/* Write by group.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IXGRP(S_IXUSR &gt;&gt; 3)<span class="comment">/* Execute by group.  */</span></span></span><br><span class="line"><span class="comment">/* Read, write, and execute by group.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IRWXG(S_IRWXU &gt;&gt; 3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IROTH(S_IRGRP &gt;&gt; 3)<span class="comment">/* Read by others.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IWOTH(S_IWGRP &gt;&gt; 3)<span class="comment">/* Write by others.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IXOTH(S_IXGRP &gt;&gt; 3)<span class="comment">/* Execute by others.  */</span></span></span><br><span class="line"><span class="comment">/* Read, write, and execute by others.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_IRWXO(S_IRWXG &gt;&gt; 3)</span></span><br></pre></td></tr></table></figure><p>需要注意的是组相关权限二进制码是对所有者相关权限进行右移3位，而其他人相关权限又是对组用户相关权限进行右移3位操作。现在来举个例子，假如我们要判断所有者是否可读，那么需要通过<code>st_mode &amp; S_IRUSR</code>，换成二进制代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OCT    664</span><br><span class="line">BIN    110 110 100    </span><br><span class="line">&amp; S_IRUSR</span><br><span class="line">OCT    400</span><br><span class="line">BIN    100 000 000</span><br><span class="line">------------------</span><br><span class="line">       100 000 000</span><br></pre></td></tr></table></figure><p>可见，通过按位与操作后，屏蔽了0~7位，在第8位上标记了所有者可读的权限。其余的判断也是以此类推。至此，我们学完了文件权限解析。</p><h3 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h3><p>通过<code>stat</code>系统调用可以获取到文件权限属性，但仅获取是不够的，我们还需要学会设置权限。通常情况下，在Linux系统中设置访问权限和所有权最常用的命令是<code>chmod</code>及<code>chown</code>。而在系统编程这一层级，这两个命令内部的核心实现又是系统调用<code>chmod</code>和系统调用<code>chown</code>，我们可以通过<code>man 2 chmod</code>和<code>man 2 chown</code>来查看。</p><h4 id="访问权限设置"><a href="#访问权限设置" class="headerlink" title="访问权限设置"></a>访问权限设置</h4><p>先来看看<code>chmod</code>的定义：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202110139.png" alt=""></p><p><code>chmod</code>和<code>fchmod</code>都可以把文件权限设置为参数<code>mode</code>指定的值。对于<code>chmod</code>函数，参数<code>pathname</code>表示需要修改的文件的相对或绝对路径名。对于<code>fchmod</code>函数，文件是由文件描述符<code>fd</code>给定。类型<code>mode_t</code>(整形)表示的是参数<code>mode</code>的合法值，和结构体<code>stat</code>中字段<code>st_mode</code>返回的值一样。上面我们学到过一系列描述权限位的宏，在此我们可以通过或运算来组合这些权限位，生成合法的<code>mode</code>值。例如（S_IRUSR|S_IRGRP）会同时把文件所有者和所属组的权限都设置为可读。</p><p>需要注意的是，为了改变文件权限，调用<code>chmod</code>和<code>fchmod</code>的进程有效ID必须匹配文件所有者。换句话说，如果文件file的所有者是alan，那么必须alan这一用户执行系统调用，才能改变file的权限。当然，如果是root用户，就不会有这一限制。</p><p>调用成功时，<code>chmod</code>和<code>fchmod</code>都返回0，失败时，都返回-1，并设置相应的errno值。下面来举个例子，现有文件<code>test.txt</code>，权限为777，通过代码将其变成660：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ls -l test.txt </span><br><span class="line">-rwxrwxrwx 1 noir noir 0 12月  1 19:21 test.txt</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = chmod(<span class="string">"../test.txt"</span>, <span class="number">0660</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"chmod"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ls -l test.txt</span><br><span class="line">-rw-rw---- 1 noir noir 0 12月  1 19:21 test.txt</span><br></pre></td></tr></table></figure><p>之前说到过<code>mode</code>参数需要通过权限位宏进行组合来生成需要的值，这里我们直接使用了<code>0666</code>这样的八进制值也是可以的。并且如果你对Linux应用足够熟悉的话，这么做反而更加直观。</p><h4 id="所有权设置"><a href="#所有权设置" class="headerlink" title="所有权设置"></a>所有权设置</h4><p>在结构体<code>stat</code>中，我们看到过<code>st_uid</code>和<code>st_gid</code>，它们分别表示文件的所有者和所属组。通过以下三个系统调用可以改变这两个值，即改变文件的所有者和所属组：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202122005.png" alt=""></p><p><code>chown</code>和<code>lchown</code>设置路径<code>pathname</code>指定的文件的所有权。它们的作用是相同的，除非文件是个符号链接：前者会获取符号链接所指向的目标文件，并改变链接目标而不是链接本身的所有权，而<code>lchown</code>并不会获取符号链接所指向的目标文件，只是改变符号链接本身的所有权。<code>fchown</code>则设置文件描述符<code>fd</code>所指向的文件的所有权。</p><p>成功时，三个调用都会把文件所有者设置为<code>owner</code>，文件所属组设置为<code>group</code>，并返回0。如果参数<code>owner</code>或<code>group</code>的值为-1，说明值没有设定。失败时，均返回-1，并设置相应的errno值。需要注意的是，通常情况下只有root用户才有权限对文件所有权进行变更。一般用户，即无法改变自己文件的所有者和所属组，亦无法改变别人的文件。</p><p>下面进行演示，如何先使用<code>adduser</code>命令创建一个新用户<code>alan</code>和与之相应的用户组，然后再通过代码将所有权和所属组为<code>noir</code>的文件<code>test.txt</code>变更到<code>alan</code>下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  sudo adduser alan                               # 创建用户和用户组alan</span><br><span class="line">➜  cat /etc/passwd | tail -n1                </span><br><span class="line">alan:x:1001:1001:Alan,,,:/home/alan:/bin/bash       # 查看到alan的用户id为1001</span><br><span class="line">➜  cat /etc/group | tail -n1                 </span><br><span class="line">alan:x:1001:                                        # 查看到alan的用户组id也为1001</span><br><span class="line">➜  ls -l test.txt                                  </span><br><span class="line">-rw-rw---- 1 noir noir 0 12月  1 19:21 test.txt     # 查看到test.txt的所有者和所属组均为noir</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = chown(<span class="string">"test.txt"</span>, <span class="number">1001</span>, <span class="number">1001</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"chown"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件所有权修改成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成功后，需要使用<code>sudo</code>提升权限，或用<code>root</code>用户登录执行程序。执行成功查看<code>text.txt</code>文件所有权，已经成功变更：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ls -l test.txt </span><br><span class="line">-rw-rw---- 1 alan alan 0 12月  1 19:21 test.txt</span><br></pre></td></tr></table></figure><p>代码比较简单，只是在<code>chown</code>中把参数写死，而不是通过查询得到<code>uid</code>和<code>gid</code>，这种操作并不好。但由于本篇主要讲解的还是文件相关，所以如何通过用户名反查得到id，暂时先搁置，等到了解系统属性和用户相关的系统调用的时候再说。此外，不少人刚开始接触Linux的时候，对多用户和组的概念并不十分清晰，主要是因为我们现在用的都是个人计算机。而在以前，计算机可是庞然大物，一个学校和一个机构可能仅有一台计算机，大家都是通过终端来连接这台机器进行工作。为了划分权限，提高安全性以及分组管理，于是也就出现了文件所有者和所属组以及其他用户这些概念。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>前面讲到过，文件其实是用<code>inode节点来表示</code>，通过硬链接可以索引到相应的<code>inode节点</code>，也就是说链接相当于节点的名字。奇怪的是，我们使用<code>stat</code>系统调用查看文件属性的时候并没有看到描述文件名称的字段，只有硬链接数。这是因为，文件名并不保存在<code>inode节点</code>，而是保存在目录中。目录中的每个名字其实也就是一个硬链接。这样一来，也就维系了目录与文件<code>inode节点</code>的组织关系。需要注意的是，不同文件系统的<code>inode编号</code>并不一致，所以硬链接并不能跨磁盘。</p><p>文件的链接数可以是0、1或多个。大多数文件的链接数是1，也就是说只有一个目录项指向该文件，但有些文件可能有两个或甚至多个链接。链接数为0的文件在文件系统上没有对应的目录项。当文件链接计数达到0时，文件被标记为空闲，其占用的磁盘块就可被重用。当进程打开了这样一个文件时，文件仍在文件系统中保留。如果没有进程打开该文件，文件就会被删除。</p><p>Linux内核通过<code>链接计数</code>和<code>使用计数</code>来进行管理。使用计数是指文件被打开的实例数。只有当某个文件的链接计数和使用计数都为0时，该文件才会从文件系统中删除。</p><p>另一种链接是符号链接，它不是文件系统中文件名和<code>inode节点</code>的映射，而是更高层次的指针，在运行时解释。因此符号链接可跨域文件系统。</p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>通过<code>link</code>系统调用可以为已有的文件创建新的硬链接(或称作别名）：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202143001.png" alt=""></p><p>成功调用<code>link</code>会为<code>oldpath</code>所指向的文件，在路径<code>newpath</code>下创建新的硬链接，也可以说是别名。因为调用成功后，<code>oldpath</code>和<code>newpath</code>都会指向到同一个文件上，事实上并没有办法区分哪个是初始链接。调用失败，则返回-1，并设置相应的errno值。下面来看代码演示，我们为当前目录下的<code>test.txt</code>创建一个新的目录项（硬链接）<code>test2.txt</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = link(<span class="string">"./test.txt"</span>, <span class="string">"./test2.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"link"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建成功后我们删除<code>test.txt</code>，发现通过<code>test2.txt</code>依然可以访问原文件。只有把<code>test2.txt</code>删除，并且此时没有任何进程打开此文件的时候，那么该文件才算是彻底被删除。</p><p>需要注意的是，硬链接不能指向目录，因为硬链接映射的是文件<code>inode节点</code>，而目录不是<code>inode节点</code>。虽然硬链接无法指向目录，但是下面要讲的符号链接可以。</p><h4 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h4><p>符号链接，也称为<code>symlinks</code>或<code>软链接</code>。它和硬链接的相同之处在于二者均指向文件系统中的文件，不同点在于符号链接不会增加额外的目录项，而是一种特殊的文件类型。该文件包含了它所指向的目标文件的路径名。运行时，内核用该路径名代替符号链接的路径名(若使用以<code>l</code>开头的系统调用，例如<code>lstat</code>，它操作的则是链接本身而非目标文件)。一个硬链接与指向同一文件的另一个硬链接很难区分，但很容易区分符号链接以及其目标文件。软链接和硬链接相比，另一个很重要的区别点在于：由于它是对路径的映射而非<code>inode</code>节点的映射，所以可以跨越不同的文件系统。当然，符号链接也可以指向一个不存在的文件，但通常这没有任何意义。创建符号链接的系统调用和创建硬链接的系统调用非常类似：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202154031.png" alt=""></p><p><code>symlink</code>调用成功时，会创建符号链接<code>linkpath</code>，指向由<code>target</code>所表示的目标文件，并返回0，出错时返回-1，并设置相应的errno值。下面来看代码演示，与上例类似，我们为当前目录下的<code>test.txt</code>创建一个新的软链接<code>test2.txt</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = symlink(<span class="string">"./test.txt"</span>, <span class="string">"./test2.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"symlink"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读取符号链接路径"><a href="#读取符号链接路径" class="headerlink" title="读取符号链接路径"></a>读取符号链接路径</h5><p>通过<code>symlink</code>可以为指定的文件创建符号链接，也可通过<code>readlink</code>系统调用来反向读取符号链接所指向的目标文件路径：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202155931.png" alt=""></p><p><code>pathname</code>为需要反向读取的符号链接路径，<code>buf</code>用于存放目标文件路径，<code>bufsiz</code>用来指定读取多少个字节到<code>buf</code>中。当调用成功时，<code>readlink</code>返回读取的字节数，若返回的数值与<code>bufsiz</code>参数相等，则说明目标文件路径发生了截短。出错时，返回-1，并设置相应的errno值。上面我们已经有了符号链接<code>test2.txt</code>，下面通过代码来演示读取其目标路径：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    ret = readlink(<span class="string">"test2.txt"</span>, buf, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"readlink"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为路径字符串设置尾标记以方便读取</span></span><br><span class="line">    buf[ret] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.txt          # 此为符号链接所指向的目标文件路径</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>readlink</code>系统调用仅针对符号链接有效，而无法反向获取硬链接所指向的目标文件。前面已经讲过，多个硬链接指向同一个<code>inode节点</code>的时候，并没有主次之分。</p><h4 id="解除链接"><a href="#解除链接" class="headerlink" title="解除链接"></a>解除链接</h4><p> 建立链接的反向操作是解除链接，即从文件系统中删除路径名。只需要调用<code>unlink</code>，就可以完成任务：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202163535.png" alt=""></p><p><code>unlink</code>调用成功时，会从文件系统中删除<code>pathname</code>，并返回0。如果<code>pathname</code>是指向文件的最后一个硬链接，则会从文件系统中彻底删除该文件。如果进程已经打开文件，在进程关闭文件前，内核不会从文件系统中删除文件。若没有进程打开该文件，文件会被删除。如果<code>pathname</code>指向符号链接，则只会删除该链接，而不会删除目标文件。出错时，<code>unlink</code>返回-1，并设置相应的errno值。下面通过代码来演示删除软链接文件<code>test2.txt</code>和硬链接文件<code>test.txt</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 noir noir    8 12月  2 00:09 test2.txt -&gt; test.txt</span><br><span class="line">-rw-rw-r-- 1 noir noir    0 12月  1 23:52 test.txt</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret1 = unlink(<span class="string">"./test2.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"删除软连接失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret2 = unlink(<span class="string">"./test.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"删除硬连接失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一个<code>unlink</code>被调用时，删除的只是软链接文件，对目标文件<code>test.txt</code>并不会造成影响。而当第二个<code>unlink</code>调用时，由于此时<code>test.txt</code>硬链接总数只有1，因此该文件会被删除。</p><p>需要注意的是，<code>unlink</code>无法删除目录。</p><h5 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h5><p>通过<code>链接计数</code>和<code>使用计数</code>这两个特性，我们可以利用<code>unlink</code>来创建临时文件，即进程运行时，可正常访问，进程退出后，文件消失。下面通过代码来演示如何创建临时文件<code>data.tmp</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">// 创建新文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"./data.tmp"</span>, O_WRONLY|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件创建成功后，硬链接数为1，此时通过unlink解除链接</span></span><br><span class="line">    unlink(<span class="string">"./data.tmp"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处执行进程运行中的读写操作</span></span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"hello world"</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程退出前关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结下来，一共分四步：</p><ul><li>通过<code>open</code>或<code>creat</code>系统调用创建文件</li><li>文件创建成功后，马上通过<code>unlink</code>系统调用解除该文件的链接</li><li>正常使用此文件进行读写操作，此时目录无法索引此文件，但文件依然可用</li><li>进程退出前关闭文件描述符，进程退出后，文件便会自动被删除</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>前面通过使用<code>unlink</code>的方式删除文件，为了简化对各类型文件的删除，C语言提供了<code>remove</code>函数。由于此函数并非系统调用，我们需要通过<code>man 3 remove</code>来查看相应文档：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202171448.png" alt=""></p><p>成功调用<code>remove</code>时，会从文件系统删除<code>pathname</code>，并返回0。如果<code>pathname</code>是一个文件，<code>remove</code>会调用<code>unlink</code>；如果<code>pathname</code>是个目录，<code>remove</code>会调用<code>rmdir</code>完成目录删除。关于<code>rmdir</code>放到后面目录主题来讲解。出错时，<code>remove</code>返回-1，并设置相应errno值。下面通过代码来演示删除一个普通文件<code>test.txt</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = <span class="built_in">remove</span>(<span class="string">"test.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p><code>cp</code>拷贝应该是Linux系统中最常使用的命令之一，然而令人沮丧的是，它并没有直接对应的系统调用可供使用，而是通过一系列的文件I/O操作。举个例子，要拷贝文件<code>src</code>至文件<code>dst</code>，需要执行以下步骤：</p><ol><li>打开src</li><li>打开dst，如果dst不存在则创建，如果已存在则把其长度截断为零</li><li>把src数据块读取到内存</li><li>把该数据块写入dst</li><li>继续操作直到src全部读取完并已经都写入到dst中</li><li>关闭dst</li><li>关闭src</li></ol><p>下面我们根据这些步骤来写一段代码，以演示如何将当前源码文件<code>main.c</code>备份到<code>backup.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd_src, fd_dst;</span><br><span class="line">    fd_src = <span class="built_in">open</span>(<span class="string">"main.c"</span>, O_RDONLY);</span><br><span class="line">    fd_dst = <span class="built_in">open</span>(<span class="string">"backup.c"</span>, O_WRONLY | O_CREAT | O_TRUNC);</span><br><span class="line">    <span class="keyword">if</span> (fd_src == <span class="number">-1</span> || fd_dst == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 循环从fd_src中读取数据，并写入到fd_dst中</span></span><br><span class="line">    <span class="keyword">while</span> ((len = <span class="built_in">read</span>(fd_src, buf, <span class="number">100</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(fd_dst, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd_dst);</span><br><span class="line">    <span class="built_in">close</span>(fd_src);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，实际上Linux系统中的<code>cp</code>命令要复杂得多，需要考虑的情况也很多，这里只是做一个基本演示，详细可以查看<code>cp</code>命令源码：<a href="https://github.com/coreutils/coreutils/blob/master/src/cp.c" target="_blank" rel="noopener">点此查看</a></p><h3 id="移动、重命名"><a href="#移动、重命名" class="headerlink" title="移动、重命名"></a>移动、重命名</h3><p>与拷贝文件不同，UNIX提供了<code>rename</code>系统调用来进行移动和重命名操作：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202181701.png" alt=""></p><p>成功调用<code>rename</code>时会返回0，原来由<code>oldpath</code>指向的文件现在变成由<code>newpath</code>指向。失败时，调用返回-1，但不影响<code>oldpath</code>或<code>newpath</code>，并设置相应的errno值。下面通过代码来演示如何将文件<code>a.txt</code>重命名为<code>b.txt</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = rename(<span class="string">"./a.txt"</span>, <span class="string">"./b.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"rename"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得说明的是，在相同目录层级下，<code>rename</code>系统调用为重命名操作。而不同目录层级，则为移动。事实上并没有移动这么一说，文件<code>inode节点</code>没有发生任何变化，只是指向它的链接（路径）变了而已。这也就要求，在进行<code>rename</code>系统调用的时候必须在相同文件系统内，否则会发生未知错误。</p><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>在UNIX中，目录是个简单的概念：它包含一个文件名列表，每个文件名对应一个<code>inode编号</code>。每个文件名称为目录项，每个目录项到<code>inode节点</code>的映射称为链接。目录内容（就是用户执行ls命令所看到的结果）就是该目录下所有文件名列表。当用户打开指定目录下的文件时，内核会在该目录列表中查找文件名所对应的<code>inode编号</code>，并将该<code>inode编号</code>传递给文件系统，文件系统使用它来寻找文件在设备上的物理位置。</p><h4 id="获取当前工作目录"><a href="#获取当前工作目录" class="headerlink" title="获取当前工作目录"></a>获取当前工作目录</h4><p>每个进程都有一个当前工作目录，一般是在创建时从父进程继承的。当未指定绝对路径时，当前进程进行的任何文件操作，都是以此目录为相对路径进行。获取当前工作目录的方法是通过系统调用<code>getcwd</code>:</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202192634.png" alt=""></p><p>成功调用<code>getcwd</code>会把当前工作目录以绝对路径名形式拷贝到<code>buf</code>指向的长度为<code>size</code>字节的缓冲区中，并返回一个指向<code>buf</code>的指针。失败时，调用返回<code>NULL</code>，并设置相应的errno值，下面是使用<code>getcwd</code>的一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span> (!getcwd(buf, <span class="number">100</span>)) &#123;</span><br><span class="line">        perror(<span class="string">"getcwd"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前工作目录的绝对路径名大小要大于<code>size</code>个字节，那么会返回NULL；如果<code>buf</code>为NULL，则<code>getcwd</code>的行为是未定义的。在这种情况下，Linux的C库将分配一个长度为<code>size</code>的缓冲区，并在那存储当前工作目录。如果<code>size</code>为0，C库将分配足够大小的缓冲区存储当前工作目录。调用结束后，则由应用程序负责使用<code>free</code>函数来释放缓冲区。如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    path = getcwd(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"getcwd"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, path);</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux的C库也提供<code>get_current_dir_name</code>函数，当使用<code>getcwd</code>并且传递的<code>buf</code>为NULL，<code>size</code>为0时，其行为与前者一致：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    path = get_current_dir_name();</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"get_current_dir_name"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, path);</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>较早的BSD系统喜欢调用<code>getwd</code>，Linux对其提供向后兼容，调用<code>getwd</code>会把当前工作目录拷贝到<code>buf</code>中，<code>buf</code>的字节长度至少为<code>PATH_MAX</code>。成功时，调用会返回<code>buf</code>指针，而失败时，返回NULL。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[PATH_MAX];</span><br><span class="line">    <span class="keyword">if</span> (!getwd(path)) &#123;</span><br><span class="line">        perror(<span class="string">"getwd"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, path);</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的系统Ubuntu中，编译时会报警告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">警告： the `getwd' function is dangerous and should not be used.</span><br></pre></td></tr></table></figure><p>出于移植性与安全性双重原因，应用程序不应该使用<code>getwd</code>，推荐使用<code>getcwd</code>。</p><h4 id="改变当前工作目录"><a href="#改变当前工作目录" class="headerlink" title="改变当前工作目录"></a>改变当前工作目录</h4><p>Linux系统提供了两个系统调用来更改当前工作目录，一个接受目录路径名，而另一个接受指向已打开的目录的文件描述符：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202202837.png" alt=""></p><p><code>chdir</code>会把当前工作目录更改为<code>path</code>指定的路径名，该路径名可以是绝对路径，也可以是相对路径。同样，<code>fchdir</code>会把当前工作目录更改为文件描述符<code>fd</code>指向的路径名，而<code>fd</code>必须是打开的目录。成功时，两个调用都返回0；失败时，都返回-1，并设置相应的errno值。如下代码演示切换路径到根目录<code>/</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = chdir(<span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"chdir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    path = getcwd(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"getcwd"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, path);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>在Linux系统中创建目录使用<code>mkdir</code>命令，同样这也是一个系统调用：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202204218.png" alt=""></p><p>成功调用<code>mkdir</code>会创建参数<code>pathname</code>所指定的目录（可以是绝对也可以是相对），其权限位为mode（可以通过umask修改），并返回0。调用失败时，<code>mkdir</code>返回-1，并设置相应errno值。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = <span class="built_in">mkdir</span>(<span class="string">"./a"</span>, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"mkdir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在当前工作目录下创建文件夹<code>a</code>，权限为<code>0777</code>，由于我的umask为<code>002</code>，所以最终创建出的文件夹权限为<code>775</code>。需要注意的是，必须为文件夹设置可执行权限，才能进入文件夹内进行读写操作。</p><h4 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h4><p>与<code>mkdir</code>对应，<code>rmdir</code>系统调用会将目录从文件系统中删除</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202205756.png" alt=""></p><p>调用成功时，<code>rmdir</code>会从文件系统中删除<code>pathname</code>，并返回0。前提是<code>pathname</code>指向的目录必须为空，除了<code>.</code>和<code>..</code>目录以外。没有支持类似<code>rm -r</code>一样递归删除功能的系统调用。要实现<code>rm -r</code>功能，首先要执行文件系统的深度优先搜索，从叶节点开始删除所有文件与目录，并返回至<code>pathname</code>所指向的文件夹。当目录内的全部文件被删除时，则可以使用<code>rmdir</code>来删除该目录。下面是一个简单例子，我们将之前创建的<code>a</code>文件夹删除：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = <span class="built_in">rmdir</span>(<span class="string">"./a"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"rmdir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h4><p>读取目录并非由一个函数完成，而是多个函数配合使用。开始读取目录前，首先需要通过<code>opendir</code>打开目录，通过<code>man 3 opendir</code>命令查看此函数文档：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191203090001.png" alt=""></p><p><code>opendir</code>函数通过路径打开目录，<code>name</code>参数为要打开的目录路径，可以是绝对路径，也可以是相对路径。<code>fdopendir</code>函数则是通过文件描述符打开目录。调用成功后，两个函数都将创建指向目录的目录流对象（directory stream object）并返回，该对象的具体结构对用户不可见，我们也不需要过多了解。失败时，返回NULL，并设置相应的errno值。</p><p>通过<code>opendir</code>创建一个目录流后，就可以使用<code>readdir</code>从目录流，也就是<code>DIR</code>对象中依次返回目录项：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191203093612.png" alt=""></p><p>成功调用<code>readdir</code>，会返回<code>dirp</code>指向的下一个目录项。结构体<code>dirent</code>指向目录项，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="keyword">ino_t</span>          d_ino;       <span class="comment">/* Inode number */</span></span><br><span class="line">    <span class="keyword">off_t</span>          d_off;       <span class="comment">/* Not an offset; see below */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;    <span class="comment">/* Length of this record */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  d_type;      <span class="comment">/* Type of file; not supported by all filesystem types */</span></span><br><span class="line">    <span class="keyword">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>连续调用<code>readdir</code>，可获取目录中的每个文件，当整个目录读完时，返回NULL。</p><p>此外，当读取完目录不再使用时，应当通过<code>closedir</code>关闭由<code>opendir</code>打开的目录流：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191203094534.png" alt=""></p><p>调用成功时，会关闭<code>dirp</code>参数指向的目录流对象，包括目录的文件描述符，并返回0。失败时，返回-1，并设置相应的errno值。</p><p>下面通过代码来演示如何读取<code>/</code>下的目录项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    dir = opendir(<span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"opendir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"inode:%10ld    name:%20s\n"</span>, entry-&gt;d_ino, entry-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inode:        13    name:                 bin</span><br><span class="line">inode:        15    name:               lib32</span><br><span class="line">inode:   1966081    name:                 tmp</span><br><span class="line">inode:        22    name:         vmlinuz.old</span><br><span class="line">inode:        23    name:             vmlinuz</span><br><span class="line">inode:   1572865    name:               media</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>由此，目录操作就讲到这里。实际应用中会出现更多复杂情况，但核心系统调用及库函数的使用基本如上，不会有太多出入。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇主要讲解两大内容，一是文件，二是目录。文件其实是用<code>inode节点</code>来描述，通过链接进行索引。而目录则保存了目录项，也就是文件的链接。此外通过文件还引出了权限的查看与设置操作，以及文件的删除、拷贝、移动、重命名等。最后又讲解了一系列日常开发中很常用的目录操作函数，文中演示的代码很简单，详细需要用户考虑到自身应用场景，编写代码加以练习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前讨论过大量关于文件I/O的系统调用，现在我们的视角从文件内部回到文件本身。在Linux中一切皆为文件，而文件包含大量的元数据。诸如：类型、权限、硬链接、软连接、所属用户、所属组、最后访问时间、最后修改时间、最后状态改变时间等。本篇主要讲解文件这些属性的获取与管理。
    
    </summary>
    
    
      <category term="Linux" scheme="https://linxiao.pro/categories/Linux/"/>
    
    
      <category term="C" scheme="https://linxiao.pro/tags/C/"/>
    
      <category term="系统编程" scheme="https://linxiao.pro/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux系统编程-文件I/O基础</title>
    <link href="https://linxiao.pro/2019/11/29/linux-programming-basic-io/"/>
    <id>https://linxiao.pro/2019/11/29/linux-programming-basic-io/</id>
    <published>2019-11-28T18:29:39.000Z</published>
    <updated>2019-11-28T10:29:39.952Z</updated>
    
    <content type="html"><![CDATA[<p>当C语言标准库已经提供了标准IO操作相关的一系列函数，为什么我们还需要学习系统IO呢？相信不少刚开始学习Linux系统编程的同学一定有这样的疑问。我们不妨站在一个较高的层次来看这个问题，比方说操作系统用户和编程语言使用者的角度。<a id="more"></a>显而易见，除了C语言，类似C++、Java、Python这样的高级语言都有IO操作，那么他们的IO操作是通过什么来实现呢？显然，需要更底层源于操作系统内核的支持。这也就是为什么我们需要学习系统IO。因为它处于内核，位于更低的层面来提供基础IO支持，当你学会系统IO后，对于很多用户空间上的IO操作，或是行业领域内更复杂的应用场景都将得心应手。</p><h3 id="基本读写"><a href="#基本读写" class="headerlink" title="基本读写"></a>基本读写</h3><p>来看一个基本读写的例子，我们往文件<code>demo.txt</code>中写入字符串hello world！然后再将此字符串从文件中读出，打印到终端上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"demo.txt"</span>, O_RDWR|O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"hello world!"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> read_count = <span class="built_in">read</span>(fd, buf, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (read_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buf[read_count] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码以及注释可以看出文件读写的基本流程，大概分为4步：打开、写入、读取、关闭。看不懂不要紧，只需要有个基本印象即可。在接下来的几个小节当中，我将对每个步骤进行深入讲解，并且围绕讲解过程中提及的知识点进行一些进阶扩展。</p><h3 id="open打开文件"><a href="#open打开文件" class="headerlink" title="open打开文件"></a>open打开文件</h3><p>首先来看看打开操作，因为open是一个系统调用，所以在查看man手册时需要使用<code>man 2 open</code>命令。</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191127142436.png" alt=""></p><p>引入文档所述三个头文件后我们便可在代码中使用open打开<code>pathname</code>路径下的文件，并且设置一些<code>flags</code>参数进行操作。而<code>mode</code>则表示该文件的权限设置，通常只在创建文件时用得到。在open系统调用下方还有一个creat系统调用，用于创建文件。没错，你即可以用open来创建文件，也可以用creat来创建文件。打开或创建文件成功后，会返回一个指向该文件的文件描述符。</p><h4 id="flags-访问模式"><a href="#flags-访问模式" class="headerlink" title="flags 访问模式"></a>flags 访问模式</h4><p><code>pathname</code>十分容易理解，即需要打开的文件路径字符串指针。而flags你可以先简单的理解成文件的打开方式，不同的打开方式会导致不同的结果发生，若选择了错误的打开方式，轻则无法访问，重则覆盖掉文件内容。大家一定要小心！flags参数通过一个或多个标志位的按位或组合而成，它支持三种访问模式：<code>O_RDONLY</code> <code>O_WRONLY</code> <code>O_RDWR</code> ，分别表示只读、只写、可读可写。来举几个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd1 = <span class="built_in">open</span>(<span class="string">"a.txt"</span>, O_RDONLY);          <span class="comment">// 只读</span></span><br><span class="line"><span class="keyword">int</span> fd2 = <span class="built_in">open</span>(<span class="string">"b.txt"</span>, O_WRONLY);          <span class="comment">// 只写</span></span><br><span class="line"><span class="keyword">int</span> fd3 = <span class="built_in">open</span>(<span class="string">"d.txt"</span>, O_RDWR);            <span class="comment">// 可读可写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记得每次打开后需要判断文件描述符是否等于-1</span></span><br><span class="line"><span class="comment">// 如果等于-1,则说明打开失败,此处仅判断一个以演示</span></span><br><span class="line"><span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"open"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能对以只读模式打开的文件执行写操作，反之亦然。进程必须有足够的权限才能调用系统调用来打开文件。举个例子，假设用户对某个文件只有只读权限，该用户的进程只能以<code>O_RDONLY</code>模式打开文件，而不能以<code>O_WRONLY</code>或<code>O_RDWR</code>模式打开。 此外，flags还可以和其他值进行按位或运算，修改打开文件的行为。诸如：<code>O_APPEND</code> <code>O_ASYNC</code> <code>O_CLOEXEC</code> <code>O_CREAT</code> <code>O_DIRECT</code> <code>O_DIRECTORY</code> <code>O_DSYNC</code> <code>O_EXCL</code> <code>O_LARGEFILE</code> <code>O_NOATIME</code> <code>O_NOCTTY</code> <code>O_NOFOLLOW</code> <code>O_NONBLOCK</code> <code>O_NDELAY</code> <code>O_PATH</code> <code>O_SYNC</code> <code>O_TEMPFILE</code> <code>O_TRUNC</code>。详细信息，可以翻阅man手册。因为篇幅有限，无法一次性将这些flags讲解完，后续根据使用场景边用边讲。</p><h4 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h4><p>open系统调用除了能打开文件，也可根据指定的路径来新建文件。先来看看新建文件相关的两个flags：</p><ul><li>O_CREAT    当参数<code>pathname</code>指定的文件不存在时，内核自动创建。如果文件已存在，除非指定了标志位<code>O_EXCL</code>，否则该标志位无效。</li><li>O_EXCL     当和标志位<code>O_CREAT</code>一起使用时，如果参数<code>pathname</code>指定的文件已经存在，会导致open()调用失败。用于防止创建文件时出现竞争。如果没有和标志位<code>O_CREAT</code>一起使用，该标志位就没有任何含义。</li></ul><p>来写一个例子进行演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1, fd2;</span><br><span class="line">    <span class="comment">// 用新建模式打开不存在的文件test.txt</span></span><br><span class="line">    fd1 = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件创建成功！\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若上面的代码创建test.txt成功，那么此时便会打开一个已存在的文件</span></span><br><span class="line">    fd2 = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT|O_EXCL);</span><br><span class="line">    <span class="keyword">if</span> (fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件创建成功!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="built_in">close</span>(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件创建成功！</span><br><span class="line">文件创建失败: File exists</span><br></pre></td></tr></table></figure><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p>除非新建文件，否则open系统调用会忽略mode参数。上面的示例使用了<code>O_CREAT</code>参数，却没有给出<code>mode</code>参数。 这通常会导致未定义的结果，并且很糟糕，如：创建的文件没有权限正常读写！我们来重新编写新建文件的代码，并加上<code>mode</code>参数。在重写之前，先要来了解一下<code>mode</code>参数的编写规则。实际上<code>mode</code>是常见的UNIX权限位集合，比如八进制数0644（文件所有者可以读写，其他人只能读）。通过翻阅<code>open</code>系统调用的手册，我们可以找到一组宏，每个宏通过按位或的方式来组合出权限集合，提供给<code>mode</code>参数。</p><table><thead><tr><th>S_IRWXU</th><th>00700</th><th>文件所有者有读、写和执行的权限</th></tr></thead><tbody><tr><td>S_IRUSR</td><td>00400</td><td>文件所有者有读权限</td></tr><tr><td>S_IWUSR</td><td>00200</td><td>文件所有者有写权限</td></tr><tr><td>S_IXUSR</td><td>00100</td><td>文件所有者有执行权限</td></tr><tr><td>S_IRWXG</td><td>00070</td><td>组用户有读、写和执行权限</td></tr><tr><td>S_IRGRP</td><td>00040</td><td>组用户有读权限</td></tr><tr><td>S_IWGRP</td><td>00020</td><td>组用户有写权限</td></tr><tr><td>S_IXGRP</td><td>00010</td><td>组用户有执行权限</td></tr><tr><td>S_IRWXO</td><td>00007</td><td>任何人都有读、写和执行的权限</td></tr><tr><td>S_IROTH</td><td>00004</td><td>任何人都有读权限</td></tr><tr><td>S_IWOTH</td><td>00002</td><td>任何人都有写权限</td></tr><tr><td>S_IXOTH</td><td>00001</td><td>任何人都有执行权限</td></tr></tbody></table><p>好，既然知道了<code>mode</code>参数的编写规则，那么来重写下新建文件的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT, S_IWUSR|S_IRUSR|S_IWGRP|S_IRGRP|S_IWOTH|S_IROTH);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件创建成功\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    oclose(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ ./a.out </span><br><span class="line">文件创建成功</span><br><span class="line">➜ ls -l test.txt </span><br><span class="line">-rw-r--r-- 1 noir noir 0 11月 27 01:11 test.txt</span><br></pre></td></tr></table></figure><p>实际运用中，用一组宏按位与组合成权限集合还是有点繁琐。因此<code>mode</code>参数可直接使用八进制数来表示，<code>S_IWUSR|S_IRUSR|S_IWGRP|S_IRGRP|S_IWOTH|S_IROTH</code> 这一组合等同于八进制数0666，千万别忘了写0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br></pre></td></tr></table></figure><p>虽然上面的代码成功创建了文件，也增加了权限<code>mode</code>参数，那为什么实际文件权限却是<code>-rw-r--r--</code>，也就是644呢？因为最终写入磁盘的权限位是由<code>mode</code>参数和用户的文件创建掩码（umask）执行按位与操作而得到的。在系统调用open()中，umask位要和参数<code>mode</code>取反。因此umask 022和mode参数0666取反后，结果是0644。通过Linux命令<code>umask 002</code>可以变更掩码位，也可在代码中调用<code>umask</code>系统调用来执行此操作。先看看文档：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191127175029.png" alt=""></p><p>然后我们尝试在创建文件前修改umask值，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umask(<span class="number">002</span>);</span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br></pre></td></tr></table></figure><p>程序执行完后，创建的新文件<code>test.txt</code>权限应该是0664。</p><h4 id="creat函数"><a href="#creat函数" class="headerlink" title="creat函数"></a>creat函数</h4><p>实际上，创建文件的操作十分常见，除了<code>open</code>，系统还为我们提供了<code>creat</code>函数专门用于文件创建。示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = creat(<span class="string">"test.txt"</span>, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码等同于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处引入了一个新的flags<code>O_TRUNC</code>：</p><ul><li>O_TRUNC    如果文件存在，并且有写权限，该标志位会把文件长度截断为0</li></ul><p>所以结合起来看，上面这段代码的含义是：创建新的文件<code>test.txt</code>，如果文件已存在，则清空内容。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>当<code>open</code>系统调用成功打开文件，会返回一个非负的整数数值，这个数值便称作文件描述符。 我们来打印一下该数值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1, fd2, fd3;</span><br><span class="line">    fd1 = <span class="built_in">open</span>(<span class="string">"test1.txt"</span>, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    fd2 = <span class="built_in">open</span>(<span class="string">"test2.txt"</span>, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    fd3 = <span class="built_in">open</span>(<span class="string">"test3.txt"</span>, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span> || fd2 == <span class="number">-1</span> || fd3 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"文件创建失败"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fd1:%d fd2:%d fd3:%d\n"</span>, fd1, fd2, fd3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="built_in">close</span>(fd2);</span><br><span class="line">    <span class="built_in">close</span>(fd3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd1:3 fd2:4 fd3:5</span><br></pre></td></tr></table></figure><p>明明我们写的代码之前没有打开过任何文件，而文件描述符却是从3开始计数。这是因为当系统开启一个新进程的时候，内核会为每一个进程维护一张文件表，而这张表中会保存我们的文件描述符、文件<code>inode</code>节点以及读取位置指针等信息。并且，当进程创建的时候还将自动开启三个文件描述符：0、1和2。文件描述符0表示标准输入（stdin），1表示标准输出（stdout），2表示标准错误（stderr）。这就是为何我们在自己的代码中没有打开任何输入输出相关的文件，却能用<code>scanf</code>接收键盘输入，用<code>printf</code>打印到终端，用<code>perror</code>打印错误。现在，我们试着关闭这3个文件描述符，看看上述的三个函数是否还能正确执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">open</span>(<span class="string">"file_not_exist.txt"</span>, O_WRONLY|O_TRUNC);</span><br><span class="line">    perror(<span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，没有结果，上面三个函数均无法正常执行。</p><p>此外，Linux C标准库提供了三个宏来表示这3个整数，分别为<code>STDIN_FILENO</code> <code>STDOUT_FILENO</code> <code>STDERR_FILENO</code>，导入头文件<code>unistd.h</code>后即可使用。当<code>open</code>系统调用返回了正确的文件描述符，后面的读写等一系列函数就可使用此文件描述符作为参数，以进行更多文件操作。</p><h3 id="write写入文件"><a href="#write写入文件" class="headerlink" title="write写入文件"></a>write写入文件</h3><p>写文件使用<code>write</code>系统调用，先来看看其原型：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191127205248.png" alt=""></p><p><code>write</code>调用会从文件描述符<code>fd</code>指向的文件的当前位置开始，将<code>buf</code>中至多<code>count</code>个字节写入到文件中。<code>write</code>执行成功时，会返回写入的字节数，并更新文件位置。出错时，返回-1，并设置<code>errno</code>值。通常意义上，我们有文本文件写入和二进制文件写入。但这只是从用户的角度出发，对于操作系统来说，其实保存的都是二进制数据。只不过我们常用的文本编辑器帮我们将文本的二进制数据解析了出来，以便于阅读。而二进制文件格式各不相同，需要不同的程序来解析。诸如音乐播放器和电影播放器，就是很典型的例子。</p><h4 id="文本写入"><a href="#文本写入" class="headerlink" title="文本写入"></a>文本写入</h4><p>我们先来测试一下文本写入，将<code>hello world!</code>这条字符串写入到<code>str.txt</code>文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"str.txt"</span>, O_WRONLY|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="string">"hello world!"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功后，打开<code>str.txt</code>文件，发现字符串<code>hello world!</code>已经成功写入。</p><h4 id="二进制数据写入"><a href="#二进制数据写入" class="headerlink" title="二进制数据写入"></a>二进制数据写入</h4><p>再来看看二进制文件写入，将自定义的<code>struct Stu</code>结构体写入到<code>data</code>文件中。其实和上面的调用方式并无二致，仅仅是写入的数据变了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"data"</span>, O_RDWR|O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s.name, <span class="string">"Alan"</span>);</span><br><span class="line">    s.age = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, &amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功后，用文本编辑器打开<code>data</code>文件，发现乱码一串，什么鬼。因为我们没有合适的程序去读取其内容，所以你需要自己编写代码去读取。这也就是Java等高级语言中所谓的对象序列化技术。通过<code>od</code>命令来查看此文件，其实还是能看出点端倪的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  od -c data</span><br><span class="line">0000000   A   l   a   n  \0  \0  \0  \0 325 222   R 034   t   U  \0  \0</span><br><span class="line">0000020     213   U   %  \f  \0  \0  \0</span><br><span class="line">0000030</span><br></pre></td></tr></table></figure><h4 id="append-追加"><a href="#append-追加" class="headerlink" title="append 追加"></a>append 追加</h4><p>通常情况下除了创建新文件从头写入，在现有内容上进行追加的需求也不少见。我们需要在<code>open</code>系统调用的<code>flag</code>参数中加入一个新的标志位：<code>O_APPEND</code>，用来改变文件的访问模式为追加，先来看看定义</p><ul><li>O_APPEND    文件将以追加模式打开。也就是说，在每次写入操作之前，将会更新文件位置指针，指向文件末尾。即使有另一个进程也在向该文件写数据，以追加模式打开的进程在最后一次写操作时，还是会更新文件位置指针，指向文件末尾</li></ul><p>写个简单例子，我们先手动创建一个文件<code>append.txt</code>，并往其中写入文本<code>abc</code>，接着再通过代码向其追加文本<code>xyz</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "abc" &gt; append.txt</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"append.txt"</span>, O_WRONLY|O_APPEND);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"xyz"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功后，打开文件<code>append.txt</code>，发现其中有两行文本，分别是<code>abc</code>和<code>xyz</code>，为什么不是一行呢？因为前面用到的<code>echo</code>命令会自动换行。</p><h5 id="共享文件操作"><a href="#共享文件操作" class="headerlink" title="共享文件操作"></a>共享文件操作</h5><p>这里针对<code>O_APPEND</code>标志位进行一下扩展。假设在多个进程中需要对同一个文件进行写入操作，那么两个进程写入的顺序是怎样的？举个例子，现有文件<code>share.txt</code>，一个进程只对其写入<code>aaa</code>，另一个进程只对其写入<code>bbb</code>，那么执行数次后，文本所展示的内容是什么样子？两个进程都有自己的文件描述符，却又指向同一个文件，因此我们可以猜想出两种结果：</p><ul><li>交替写，结果为<code>aaabbbaaabbb</code>，即一个进程写完后更新文件节点位置指针到末尾，然后另一个进程从末尾开始写</li><li>覆盖写，结果为<code>bbbbbbbbbbbb</code>，即一个进程写完后不更新文件节点位置指针，然后另一个进程从自己的原始位置开始写，并覆盖上一个进程所写入的数据，比如A进程先写了<code>aaa</code>，然而B进程此时的文件位置指针还在<code>aaa</code>开头，而非结尾，所以写入<code>bbb</code>后，会将<code>aaa</code>覆盖</li></ul><p>那么实际写入效果如何，我们可以用代码来验证一下。由于尚未了解多进程相关知识，我们两次打开同一文件来模拟此行为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1,fd2;</span><br><span class="line">    fd1 = <span class="built_in">open</span>(<span class="string">"share.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    fd2 = <span class="built_in">open</span>(<span class="string">"share.txt"</span>, O_WRONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span> || fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count++ &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(fd1, <span class="string">"aaa"</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">write</span>(fd2, <span class="string">"bbb"</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line"><span class="built_in">close</span>(fd2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完成，打开<code>share.txt</code>文件，可以看到文本内容<code>bbbbbbbbbbbb</code>，也就是说共享文件写入时是覆盖写。如果想让它变成交替写，则需要在<code>open</code>系统调用中加上<code>O_APPEND</code>标志位。其余代码不变，我们将打开文件的两行代码进行修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd1 = <span class="built_in">open</span>(<span class="string">"share.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC|O_APPEND, <span class="number">0666</span>);</span><br><span class="line">fd2 = <span class="built_in">open</span>(<span class="string">"share.txt"</span>, O_WRONLY|O_APPEND);</span><br></pre></td></tr></table></figure><p>重新编译执行，再次打开<code>share.txt</code>文件，内容已变成<code>aaabbbaaabbbaaabbbaaabbb</code>。</p><h3 id="read读取文件"><a href="#read读取文件" class="headerlink" title="read读取文件"></a>read读取文件</h3><p>前面讨论了打开和写入文件操作，接下来谈谈文件读取。先看看原型：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128103049.png" alt=""></p><p>每次调用<code>read</code>，会从<code>fd</code>指向的文件的当前偏移开始读取<code>count</code>字节到<code>buf</code>所指向的内存中。执行成功时，返回写入<code>buf</code>中的字节数。出错时，返回-1，并设置<code>errno</code>值。<code>fd</code>的文件位置指针会向前移动，移动的长度由读取到的字节数决定。</p><p>前面我们在文本写入和二进制数据写入两小节中分别产生了两个文件<code>str.txt</code>和<code>data</code>，现在我们尝试用<code>read</code>把其中的内容读出来，并打印到终端上。</p><h4 id="文本读取"><a href="#文本读取" class="headerlink" title="文本读取"></a>文本读取</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"str.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// 读之前先清空buf数据</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">read</span>(fd, buf, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功，会输出<code>hello world!</code>，可以看到文本读取非常简单。</p><h4 id="二进制数据读取"><a href="#二进制数据读取" class="headerlink" title="二进制数据读取"></a>二进制数据读取</h4><p>现在来看看二进制文件读取，我们使用上述写入的<code>data</code>文件来进行测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"data"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="built_in">read</span>(fd, &amp;s, <span class="keyword">sizeof</span>(s));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s:%d\n"</span>, s.name, s.age);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功，会输出获取的结构体数据<code>Alan:12</code>。</p><h4 id="read返回值"><a href="#read返回值" class="headerlink" title="read返回值"></a>read返回值</h4><p>前面两段读取代码有个特点，即都是以知道<code>buf</code>缓冲区大小为前提来进行读取。比如第一段文本读取代码中，很明显我们知道要读取的字符串大小要小于100字节，所以创建了100字节的缓冲区。而第二段二进制数据读取代码中，可以很轻易通过<code>sizeof</code>运算符来得到<code>struct Stu</code>的大小。那如果并不知道要读取的文件大小是多少，缓冲区应该如何创建？通常情况下缓冲区不宜设置太小，因为读取的块太小，就会导致读取次数增加，造成效率低下。当然，也不能过大，这样会造成内存空间浪费或内存溢出。当设定好合适的缓冲区大小后，可以使用循环来读取内容。使用循环读取前，要先了解<code>read</code>系统调用的返回值，事实上调用<code>read</code>有很多种可能的返回结果，我们列出常见的几种，其余需要的时候再讲解：</p><ul><li>调用返回值等于<code>count</code>。读取到的所有<code>count</code>个字节都被存储在<code>buf</code>中。结果和预期一致。</li><li>调用返回值小于<code>count</code>，大于0。读取到的字节被存储到<code>buf</code>中。这种情况有很多原因，比如在读取过程中信号中断或在读取中出错，可读的数据大于0字节小于<code>count</code>字节，在读取<code>count</code>字节之前到达EOF。</li><li>调用返回0，表示EOF，没有更多可读的数据。</li></ul><p>了解完<code>read</code>的返回值后，我们摘录一段小王子的文本保存到文件<code>prince.txt</code>中，然后尝试循环读取到<code>buf</code>缓冲区中，并将其输出到终端，文本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.And now here is my secret, a very simple secret. It is only with the heart that one can see rightly; what is essential is invisible to the eyes.</span><br><span class="line"></span><br><span class="line">2.If you come at four o&apos;clock in the afternoon, then at three o&apos;clock I shall begin to be happy. I shall feel happier and happier as the hour advances. At four o&apos;clock, I shall already be worrying and jumping about. I shall show you how happy I am! But if you come at just any time, I shall never know at what hour my heart is to be ready to greet you…</span><br><span class="line"></span><br><span class="line">3.If someone loves a flower, of which just one single blossom grows in all the millions and millions of stars, it is enough to make him happy just to look at the stars.He can say to himself, &quot;Somewhere, my flower is there…&quot; But if the sheep eats the flower, in one moment all his stars will be darkened… And you think that is not important!</span><br><span class="line"></span><br><span class="line">4.If we do not go through the world, we do not know what is our spiritual and emotional sustenance, but once we go through the world, we find that we can no longer go back to that wonderful place to go. When we begin to seek, we have lost, and we are not seeking, we cannot know what is so precious to us.</span><br><span class="line"></span><br><span class="line">5.Only the children know what they are looking for. They waste their time over a rag doll and it becomes very important to them; and if anybody takes it away from them, they cry…</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"prince.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = <span class="built_in">read</span>(fd, buf, <span class="number">99</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们每次读取99字节，并且将最后1字节设置为<code>\0</code>，以表示这是一条字符串，方便<code>printf</code>函数打印。当读取到文件末尾，<code>len</code>会等于0，并结束循环。如无意外，执行成功后会输出上文文本。</p><h3 id="lseek查找"><a href="#lseek查找" class="headerlink" title="lseek查找"></a>lseek查找</h3><p>有些同学可能在执行完<code>write</code>操作后立马使用<code>read</code>来读数据，然而此时无法正确读取，这是因为文件描述符的位置指针已经移动到了数据末尾，如果是从头写入的数据，那么我们可以用如下代码将位置指针回移，然后再进行读操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *buf = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">lseek(fd, (<span class="keyword">off_t</span>)<span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">read</span>(fd, buf, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>当然<code>lseek</code>的用法并不仅限如此，我们先看看文档，再讲述其详细用法：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128123908.png" alt=""></p><p><code>lseek</code>系统调用能够将文件描述符的位置指针修改成指定值，它的行为依赖于<code>whence</code>参数，该参数可以是以下任意值之一</p><ul><li>SEEK_CUR    将文件位置设置成当前值再加上<code>offset</code>个偏移值，<code>offset</code>可以是负值、0或正值。如果<code>offset</code>值为0，返回当前文件位置值。</li><li>SEEK_END    将文件位置设置成文件长度再加上<code>offset</code>个偏移值，<code>offset</code>可以是负值、0或正值。如果<code>offset</code>值为0，就设置成文件末尾</li><li>SEEK_SET    将文件位置设置成<code>offset</code>值。如果<code>offset</code>值为0，就设置成文件开始。</li></ul><p>调用成功时返回新的文件位置，错误时返回-1，并设置相应<code>errno</code>值。</p><p>举个例子，以下代码把<code>fd</code>的文件位置指针设置为200：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> ret;</span><br><span class="line">ret = lseek(fd, (<span class="keyword">off_t</span>)<span class="number">200</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"lseek"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是把<code>fd</code>的文件位置设置成文件末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> ret;</span><br><span class="line">ret = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"lseek"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>lseek</code>返回更新后的文件位置，可以通过<code>SEEK_CUR</code>，把偏移<code>offset</code>设置成0，确定当前文件位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line">pos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"lseek"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稀疏文件"><a href="#稀疏文件" class="headerlink" title="稀疏文件"></a>稀疏文件</h3><p><code>lseek</code>也可将文件位置指针移动到文件末尾之后，比如以下代码会定位到<code>fd</code>指向文件末尾之后的1024*1024字节(1M) ，然后紧接着写入文本<code>end</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = lseek(fd, <span class="number">1024</span>*<span class="number">1024</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"lseek"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"end"</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>end</code>之前这段区间会用0来填充，称之为<code>空洞（hole）</code>。在UNIX系文件系统上，空洞不占用任何物理磁盘空间。包含空洞的文件称为<code>稀疏文件</code>。上面代码执行成功后，通过<code>ls -lh</code>命令查看，显示文件大小约为1M。而通过<code>du -h</code>命令查看物理空间大小，则显示为4k。这里的4k是因为最后写入的<code>end</code>，虽然<code>end</code>只占3字节，但由于Linux系统最小写入的块就是4k，所以文件物理大小为4k。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ls -l test.txt                 </span><br><span class="line">-rw-rw-r-- 1 noir noir 1003 11月 29 00:15 test.txt</span><br><span class="line">➜  du -h test.txt </span><br><span class="line">4.0k      test.txt</span><br></pre></td></tr></table></figure><p>为何需要空洞，打个比方，假如我们现在需要进行多线程下载，那么每条线程就必须通过<code>lseek</code>移动到不同位置创造出空洞，然后再通过<code>write</code>向空洞部分写入数据。最后所有部分的空洞都被填充，则完成整体文件下载。制造空洞不会产生任何物理I/O，对文件空洞部分的读请求则会返回相应的二进制0。</p><h3 id="截短文件"><a href="#截短文件" class="headerlink" title="截短文件"></a>截短文件</h3><p>通过使用<code>lseek</code>可以制造空洞，但这并非唯一做法，还有另一种方式就是使用<code>truncate</code>系统调用。先看看文档：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191129165547.png" alt=""></p><p><code>truncate</code>系统调用可以截短一个文件，<code>path</code>参数用于指定需截短的文件路径，<code>length</code>参数用于指定需截短的目标长度。而<code>ftruncate</code>与<code>truncate</code>不同的地方仅在于前者使用参数<code>fd</code>来指定需截短的文件，而非路径。当需要截短的长度实际大于文件本身长度时，便会造成空洞。我们使用<code>ftruncate</code>来改写上面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_RDWR|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = ftruncate(fd, <span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"truncate"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功后，便创建了一个有1M大小空洞的稀疏文件。</p><p>上面的例子是截短的长度比文件原长度还要大，然而常规用法更多的是要截短的目标长度小于文件的原有长度。举个例子，我们现在有一个文本文件<code>test.txt</code>，里面包含一串字符串：<code>hello world</code>，现在我们使用<code>truncate</code>系统调用来截短6个字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = truncate(<span class="string">"test.txt"</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"truncate"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完成，再次打开<code>test.txt</code>文件，其中内容已经截短为<code>hello</code>。</p><h3 id="close关闭文件"><a href="#close关闭文件" class="headerlink" title="close关闭文件"></a>close关闭文件</h3><p>接下来说说<code>close</code>系统调用。其实上面的代码中一直有用到，只是没有详细说明，先看看函数原型：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128134727.png" alt=""></p><p>当程序完成对某个文件的操作后，系统调用<code>close</code>会取消当前进程的文件描述符<code>fd</code>与其关联的文件之间的映射。调用后，先前给定的文件描述符<code>fd</code>不再有效，内核可以随时重用它，当后续有<code>open</code>调用或<code>creat</code>调用时，重新把它作为返回值。举个例子，假如我们我们关闭了文件描述符0，那么接下来的<code>open</code>调用便会打开一个新文件，并且此文件的文件描述符为0。</p><h3 id="dup复制文件描述符"><a href="#dup复制文件描述符" class="headerlink" title="dup复制文件描述符"></a>dup复制文件描述符</h3><p><code>dup</code>系统调用用于复制文件描述符，先来看文档：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128141513.png" alt=""></p><p><code>oldfd</code>表示原始文件描述符，<code>dup</code>系统调用会根据原始文件描述符复制一个新的文件描述符并返回，而这个新的文件描述符是从系统可用的最小文件描述符开始计数。如：当前已打开3，则下一个文件描述符应为4。而<code>dup2</code>系统调用除了复制文件描述符外，还可通过<code>newfd</code>来指定新文件描述符的数值。倘若<code>newfd</code>已经被使用，则<code>dup2</code>会将其关闭再给自己使用。上述两个系统调用执行成功会返回新的文件描述符，而一旦失败，则返回-1，并设置相应的<code>errno</code>。</p><p>下面我们复制一个文件描述符，并同时使用两个文件描述符向同一文件写入文本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"dup.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> new_fd;</span><br><span class="line">    new_fd = dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本行代码与上一行等价</span></span><br><span class="line">    <span class="comment">// new_fd = dup2(fd, 4);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"dup"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">"world"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, str1, <span class="built_in">strlen</span>(str1));</span><br><span class="line">    <span class="built_in">write</span>(new_fd, str2, <span class="built_in">strlen</span>(str2));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功后打开文件<code>dup.txt</code>，发现写入文本内容<code>helloworld</code>，也就是说通过<code>new_fd</code>写入的文本并没有覆盖<code>fd</code>写入的文本。这主要是因为<code>dup</code>复制出的文件描述符和原文件描述符使用的是同一文件位置偏移量。</p><h4 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h4><p><code>dup dup2</code>系统调用除了能复制文件描述符，还能实现重定向操作。先来看看什么是重定向：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  echo "hello"               # 直接输出到屏幕上</span><br><span class="line">hello</span><br><span class="line">➜  echo "hello" &gt; hello.txt   # 重定向到文件中</span><br><span class="line">➜  cat &lt; hello.txt            # 从文件重定向到命令里</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>如果经常使用Linux，对重定向应该不会陌生，下面我们来使用<code>dup dup2</code>来实现一个将原本输出到终端重定向至文件的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">    <span class="keyword">int</span> new_fd;</span><br><span class="line">    new_fd = dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本行代码与上一行等价,并且不需要提前关闭文件描述符1</span></span><br><span class="line">    <span class="comment">// new_fd = dup2(fd, STDOUT_FILENO);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"dup"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"hello world!"</span>;</span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看出标准输出重定向操作主要分了三步：</p><ul><li>关闭标准输出文件描述符</li><li>复制文件描述符<code>fd</code>，此时会分配新的文件描述符1，并与<code>fd</code>所指向的文件绑定</li><li>向标准输出写入数据，此时数据会写入到<code>fd</code>所指向的文件中</li></ul><p>如果我们把下面这一行去掉，那么很明显，它会继续向标准输出打印，而不是输出到文件中，所以<code>close</code>是重定向中至关重要的一环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(STDOUT_FILENO);</span><br></pre></td></tr></table></figure><p>而<code>dup2</code>则更加简单，它可以不必提前关闭<code>STDOUT_FILENO</code>，当指定新的文件描述符为<code>STDOUT_FILENO</code>的时候，它会自动关闭，并将其与<code>fd</code>所指文件进行绑定。</p><h3 id="fcntl操作文件描述符"><a href="#fcntl操作文件描述符" class="headerlink" title="fcntl操作文件描述符"></a>fcntl操作文件描述符</h3><p><code>fcntl</code>主要作用是用来操作文件描述符，我们先看文档</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191127/20191128172640.png" alt=""></p><p><code>fd</code>参数与上面所有的系统调用一样，指打开的文件描述符，而<code>cmd</code>则是控制命令，代表我们要针对此文件描述符进行的操作。由于命令较多，此处讲解两个以演示用法。</p><h4 id="模拟dup-dup2操作"><a href="#模拟dup-dup2操作" class="headerlink" title="模拟dup dup2操作"></a>模拟dup dup2操作</h4><p>除了使用<code>dup dup2</code>来复制文件描述符，通过<code>fcntl</code>也能做到，只是这种做法不常见而已。下面我们通过代码来演示如何操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> new_fd;</span><br><span class="line">    new_fd = fcntl(fd, F_DUPFD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"dup"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"hello"</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">write</span>(new_fd, <span class="string">"world"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">close</span>(new_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完成，会成功往<code>test.txt</code>中写入<code>helloworld</code>，从上面的<code>fcntl</code>用法中我们发现了一个命令参数<code>F_DUPFD</code></p><ul><li>F_DUPFD    复制文件描述符，可用来模拟dup和dup2</li></ul><p>下面我们再演示一段模拟<code>dup2</code>重定向标准输出的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line"><span class="keyword">int</span> new_fd;</span><br><span class="line">new_fd = fcntl(fd, F_DUPFD, STDOUT_FILENO);</span><br></pre></td></tr></table></figure><p>这里需要注意的是，<code>dup2</code>设定文件描述符值之后，若此值已被使用则会先关闭，而<code>F_DUPFD</code>则不会，需要我们手动关闭，然后再设置新的文件描述符。</p><h4 id="设置文件访问模式"><a href="#设置文件访问模式" class="headerlink" title="设置文件访问模式"></a>设置文件访问模式</h4><p>由于实际开发中，很多时候我们获取到的文件描述符也许并非我们自行打开文件所得，而是由别的api返回。此时我们并不知道文件描述符的状态，也不知道是否具备我们需要的访问模式。这时也就引入了两个新的命令：</p><ul><li>F_GETFL    获取文件访问标志</li><li>F_SETFL    设置文件访问标志</li></ul><p>现在假设有一个文件描述符以可写模式打开，而我们想追加内容，来看看通过<code>fcntl</code>应该如何操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">// 获取原始文件描述符访问标志</span></span><br><span class="line">    flags = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="comment">// 在原有文件访问标志之上补充新的访问标志</span></span><br><span class="line">    flags = flags|O_APPEND;</span><br><span class="line">    <span class="comment">// 为文件描述符设定新的文件访问标志</span></span><br><span class="line">    fcntl(fd, F_SETFL, flags);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"hello"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功可以很清晰看到<code>test.txt</code>中的文本并未被覆盖，而是以追加的形式写入。通过上面的代码我们也看出了设置文件描述符标志的基本套路：</p><ul><li>获取原始文件描述符访问标志</li><li>在原有文件访问标志之上补充新的访问标志</li><li>为文件描述符设定新的文件访问标志</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的内容有点多，先是简要说明了文件读写的基本流程，然后针对文件打开、写入、读取进行了详细讲解。在文件读写过程中我们还需要注意文件共享写入、追加、lseek、空洞、关闭等小细节。最后又介绍了dup实现的文件共享以及重定向，还有fcntl操作文件描述符的简要方法。归根到底，其实文件I/O的基础操作并不难，也好理解，最重要的是一定要多看文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当C语言标准库已经提供了标准IO操作相关的一系列函数，为什么我们还需要学习系统IO呢？相信不少刚开始学习Linux系统编程的同学一定有这样的疑问。我们不妨站在一个较高的层次来看这个问题，比方说操作系统用户和编程语言使用者的角度。
    
    </summary>
    
    
      <category term="Linux" scheme="https://linxiao.pro/categories/Linux/"/>
    
    
      <category term="C" scheme="https://linxiao.pro/tags/C/"/>
    
      <category term="系统编程" scheme="https://linxiao.pro/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程-errno详解</title>
    <link href="https://linxiao.pro/2019/11/26/linux-programming-error/"/>
    <id>https://linxiao.pro/2019/11/26/linux-programming-error/</id>
    <published>2019-11-26T14:05:44.000Z</published>
    <updated>2019-11-26T06:05:44.608Z</updated>
    
    <content type="html"><![CDATA[<p>当进行系统编程的时候，知道一个系统调用或库函数的返回结果极其重要。通常情况下，函数执行正确，可以返回需要的结果或无返回。然而，一旦发生错误，除了知道出错以外，我们还需要更详细的错误信息来辅助定位问题并加以修正。在系统编程中，错误是通过函数的返回值和特殊变量errno来描述。<a id="more"></a>用函数返回值来描述错误应该是最常见的手段，比方说-1代表文件打开失败，-2代表参数缺失等等。但很多错误其实都是通用的，如果针对每一个函数用一个错误码来表示，那么不免有些冗余，二来函数的生命周期有限，仅能描述自身，而无法描述整个程序的错误状态。所以我们需要一个全局范围的错误码和对应的错误定义，来帮助我们描述错误。</p><h3 id="errno-变量"><a href="#errno-变量" class="headerlink" title="errno 变量"></a>errno 变量</h3><p>举个例子，当我们使用<code>ls</code>命令来打开一个不存在的目录<code>abc</code>，很明显此时会报错并返回错误信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ls abc</span><br><span class="line">ls: cannot access 'abc': No such file or directory</span><br></pre></td></tr></table></figure><p>但大部分人不知道的是，除了报错，ls命令还为系统设置了一个全局的errno来描述此程序错误。在shell中，我们可以通过查看<code>$?</code>来得到此errno</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ echo $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>可以看到，当前返回的错误码2实际上代表的是<code>No such file or directory</code>。如果我们已经知道了错误码，那么应该如何查看错误码对应的错误信息呢？总是用命令行或程序去试错，然后再记录下来成本有些大。所以此时便需要引入errno命令。</p><h3 id="errno-命令"><a href="#errno-命令" class="headerlink" title="errno 命令"></a>errno 命令</h3><p>没错，errno不仅是个特殊的环境变量，用<code>$?</code>来表示。与此同时，它也是一条Linux系统命令，使用<code>man errno</code>可以查看相关手册。如果你的系统中没有errno命令，那么需要安装<code>moreutils</code>，比如说在Ubuntu中：<code>sudo apt install moreutils</code></p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191126/20191126105824.png" alt=""></p><p>从上图可以看出errno命令的基本用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ errno 2                                     # 查看相应错误宏名称</span><br><span class="line">ENOENT 2 No such file or directory</span><br><span class="line">➜  ~ errno -s file                               # 通过给出的关键词来搜索错误描述</span><br><span class="line">ENOENT 2 No such file or directory</span><br><span class="line">EBADF 9 Bad file descriptor</span><br><span class="line">EEXIST 17 File exists</span><br><span class="line">...</span><br><span class="line">➜  ~ errno -l                                    # 列出所有的错误值</span><br><span class="line">EPERM 1 Operation not permitted</span><br><span class="line">ENOENT 2 No such file or directory</span><br><span class="line">ESRCH 3 No such process</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="error在系统编程中的使用"><a href="#error在系统编程中的使用" class="headerlink" title="error在系统编程中的使用"></a>error在系统编程中的使用</h3><p>上面从命令行角度来讲解了errno的用法，那么如果以开发者的角度来看，errno又该如何使用？可以从手册中找到答案。之前我们查看errno命令是直接使用<code>man errno</code>，但在代码编写中，errno是作为一个库全局变量存在，因此我们需要通过<code>man 3 errno</code>命令来查看相应用法：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191126/20191126111638.png" alt=""></p><p>以上仅截取了部分文档，详细可自行查看。但从文档头部我们得到了两条重要信息，首先errno在代码中表示最后一次函数调用出错的错误码。其次，当使用此值的时候，我们需要引入头文件<code>errno.h</code>。在文档后面，还可以看到一个基本的伪代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A common mistake is to do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (somecall() == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"somecall() failed\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (errno == ...) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，错误发生的时机源于Linux系统调用或库函数调用。<strong>而errno正确的使用方法是：当错误发生，我们需要检查errno对应的值，并且做出相应处理。</strong></p><p>可以试着用代码将这些错误描述打印，来简单实现一下<code>errno -l</code>命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">134</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %s\n"</span>, i, strerror(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0: Success</span><br><span class="line">1: Operation not permitted</span><br><span class="line">2: No such file or directory</span><br><span class="line">3: No such process</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>代码中的strerror函数返回由errno描述的错误信息的字符串指针。其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure><p>我们用上面学到的两个Api来写一个打开文件，并判断是否打开正确的简单例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"abc.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="comment">// 如果open函数返回-1，说明打开文件失败，此时我们将错误原因打印出来</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s:%s\n"</span>, <span class="string">"open"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我当前程序运行的文件夹下并没有abc.txt这一文件， 所以执行结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open:No such file or directory</span><br></pre></td></tr></table></figure><p>如此便可在程序出错时，知道出错的具体原因。</p><p>但既要使用errno又要使用strerror函数，才能输出错误，未免稍显麻烦了点，所以我们可以使用perror函数来简化这一过程。</p><h3 id="perror-函数"><a href="#perror-函数" class="headerlink" title="perror 函数"></a>perror 函数</h3><p>作用：打印系统错误信息</p><p>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure><p>现在我们用perror函数将上面的代码改造一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"abc.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时程序的运行输出已经变成了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure><p>执行结果与上面完全一致。也就是说，perror函数自动帮我们解析了errno这个特殊变量的值，并将值所对应的描述给打印了出来。此外我们还可以对perror传参，加上自己的标记。这会显示在输出开头。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在来小结一下，上面一共讲解了一个特殊的环境变量errno，当执行完程序或命令时，可以用<code>$?</code>来查看其结果。同时它也是一个Linux命令，可用来查看错误描述。而在系统编程中，它则用于保存系统调用或函数执行的错误结果。函数strerror可以解析出errno代码所对应的错误信息，而perror函数则可在系统编程中更好的输出错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当进行系统编程的时候，知道一个系统调用或库函数的返回结果极其重要。通常情况下，函数执行正确，可以返回需要的结果或无返回。然而，一旦发生错误，除了知道出错以外，我们还需要更详细的错误信息来辅助定位问题并加以修正。在系统编程中，错误是通过函数的返回值和特殊变量errno来描述。
    
    </summary>
    
    
      <category term="Linux" scheme="https://linxiao.pro/categories/Linux/"/>
    
    
      <category term="C" scheme="https://linxiao.pro/tags/C/"/>
    
      <category term="系统编程" scheme="https://linxiao.pro/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
