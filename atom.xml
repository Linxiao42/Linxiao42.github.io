<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Linxiao&#39;s Blog</title>
  
  <subtitle>学习、记录、分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://linxiao.pro/"/>
  <updated>2019-11-26T06:05:44.608Z</updated>
  <id>https://linxiao.pro/</id>
  
  <author>
    <name>Linxiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统编程-errno详解</title>
    <link href="https://linxiao.pro/2019/11/26/linux-programming-error/"/>
    <id>https://linxiao.pro/2019/11/26/linux-programming-error/</id>
    <published>2019-11-26T14:05:44.000Z</published>
    <updated>2019-11-26T06:05:44.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当进行系统编程的时候，知道一个系统调用或库函数的返回结果极其重要。通常情况下，函数执行正确，可以返回需要的结果或无返回。然而，一旦发生错误，除了知道出错以外，我们还需要更详细的错误信息来辅助定位问题并加以修正。在系统编程中，错误是通过函数的返回值和特殊变量errno来描述。<a id="more"></a>用函数返回值来描述错误应该是最常见的手段，比方说-1代表文件打开失败，-2代表参数缺失等等。但很多错误其实都是通用的，如果针对每一个函数用一个错误码来表示，那么不免有些冗余，二来函数的生命周期有限，仅能描述自身，而无法描述整个程序的错误状态。所以我们需要一个全局范围的错误码和对应的错误定义，来帮助我们描述错误。</p><h3 id="errno-变量"><a href="#errno-变量" class="headerlink" title="errno 变量"></a>errno 变量</h3><p>举个例子，当我们使用<code>ls</code>命令来打开一个不存在的目录<code>abc</code>，很明显此时会报错并返回错误信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ls abc</span><br><span class="line">ls: cannot access 'abc': No such file or directory</span><br></pre></td></tr></table></figure><p>但大部分人不知道的是，除了报错，ls命令还为系统设置了一个全局的errno来描述此程序错误。在shell中，我们可以通过查看<code>$?</code>来得到此errno</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ echo $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>可以看到，当前返回的错误码2实际上代表的是<code>No such file or directory</code>。如果我们已经知道了错误码，那么应该如何查看错误码对应的错误信息呢？总是用命令行或程序去试错，然后再记录下来成本有些大。所以此时便需要引入errno命令。</p><h3 id="errno-命令"><a href="#errno-命令" class="headerlink" title="errno 命令"></a>errno 命令</h3><p>没错，errno不仅是个特殊的环境变量，用<code>$?</code>来表示。与此同时，它也是一条Linux系统命令，使用<code>man errno</code>可以查看相关手册。如果你的系统中没有errno命令，那么需要安装<code>moreutils</code>，比如说在Ubuntu中：<code>sudo apt install moreutils</code></p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191126/20191126105824.png" alt=""></p><p>从上图可以看出errno命令的基本用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ errno 2                                     # 查看相应错误宏名称</span><br><span class="line">ENOENT 2 No such file or directory</span><br><span class="line">➜  ~ errno -s file                               # 通过给出的关键词来搜索错误描述</span><br><span class="line">ENOENT 2 No such file or directory</span><br><span class="line">EBADF 9 Bad file descriptor</span><br><span class="line">EEXIST 17 File exists</span><br><span class="line">...</span><br><span class="line">➜  ~ errno -l                                    # 列出所有的错误值</span><br><span class="line">EPERM 1 Operation not permitted</span><br><span class="line">ENOENT 2 No such file or directory</span><br><span class="line">ESRCH 3 No such process</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="error在系统编程中的使用"><a href="#error在系统编程中的使用" class="headerlink" title="error在系统编程中的使用"></a>error在系统编程中的使用</h3><p>上面从命令行角度来讲解了errno的用法，那么如果以开发者的角度来看，errno又该如何使用？可以从手册中找到答案。之前我们查看errno命令是直接使用<code>man errno</code>，但在代码编写中，errno是作为一个库全局变量存在，因此我们需要通过<code>man 3 errno</code>命令来查看相应用法：</p><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191126/20191126111638.png" alt=""></p><p>以上仅截取了部分文档，详细可自行查看。但从文档头部我们得到了两条重要信息，首先errno在代码中表示最后一次函数调用出错的错误码。其次，当使用此值的时候，我们需要引入头文件<code>errno.h</code>。在文档后面，还可以看到一个基本的伪代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A common mistake is to do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (somecall() == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"somecall() failed\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (errno == ...) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，错误发生的时机源于Linux系统调用或库函数调用。<strong>而errno正确的使用方法是：当错误发生，我们需要检查errno对应的值，并且做出相应处理。</strong></p><p>可以试着用代码将这些错误描述打印，来简单实现一下<code>errno -l</code>命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">134</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %s\n"</span>, i, strerror(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0: Success</span><br><span class="line">1: Operation not permitted</span><br><span class="line">2: No such file or directory</span><br><span class="line">3: No such process</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>代码中的strerror函数返回由errno描述的错误信息的字符串指针。其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure><p>我们用上面学到的两个Api来写一个打开文件，并判断是否打开正确的简单例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"abc.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="comment">// 如果open函数返回-1，说明打开文件失败，此时我们将错误原因打印出来</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s:%s\n"</span>, <span class="string">"open"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我当前程序运行的文件夹下并没有abc.txt这一文件， 所以执行结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open:No such file or directory</span><br></pre></td></tr></table></figure><p>如此便可在程序出错时，知道出错的具体原因。</p><p>但既要使用errno又要使用strerror函数，才能输出错误，未免稍显麻烦了点，所以我们可以使用perror函数来简化这一过程。</p><h3 id="perror-函数"><a href="#perror-函数" class="headerlink" title="perror 函数"></a>perror 函数</h3><p>作用：打印系统错误信息</p><p>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure><p>现在我们用perror函数将上面的代码改造一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"abc.txt"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时程序的运行输出已经变成了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure><p>执行结果与上面完全一致。也就是说，perror函数自动帮我们解析了errno这个特殊变量的值，并将值所对应的描述给打印了出来。此外我们还可以对perror传参，加上自己的标记。这会显示在输出开头。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在来小结一下，上面一共讲解了一个特殊的环境变量errno，当执行完程序或命令时，可以用<code>$?</code>来查看其结果。同时它也是一个Linux命令，可用来查看错误描述。而在系统编程中，它则用于保存系统调用或函数执行的错误结果。函数strerror可以解析出errno代码所对应的错误信息，而perror函数则可在系统编程中更好的输出错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;当进行系统编程的时候，知道一个系统调用或库函数的返回结果极其重要。通常情况下，函数执行正确，可以返回需要的结果或无返回。然而，一旦发生错误，除了知道出错以外，我们还需要更详细的错误信息来辅助定位问题并加以修正。在系统编程中，错误是通过函数的返回值和特殊变量errno来描述。
    
    </summary>
    
    
      <category term="Linux" scheme="https://linxiao.pro/categories/Linux/"/>
    
    
      <category term="C" scheme="https://linxiao.pro/tags/C/"/>
    
      <category term="系统编程" scheme="https://linxiao.pro/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
