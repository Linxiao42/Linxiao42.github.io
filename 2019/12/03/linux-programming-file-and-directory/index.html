<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="alternate" href="/atom.xml" title="Linxiao's Blog" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="之前讨论过大量关于文件I&#x2F;O的系统调用，现在我们的视角从文件内部回到文件本身。在Linux中一切皆为文件，而文件包含大量的元数据。诸如：类型、权限、硬链接、软连接、所属用户、所属组、最后访问时间、最后修改时间、最后状态改变时间等。本篇主要讲解文件这些属性的获取与管理。">
<meta name="keywords" content="C,系统编程">
<meta property="og:type" content="article">
<meta property="og:title" content="linux系统编程-文件与目录管理">
<meta property="og:url" content="https:&#x2F;&#x2F;linxiao.pro&#x2F;2019&#x2F;12&#x2F;03&#x2F;linux-programming-file-and-directory&#x2F;index.html">
<meta property="og:site_name" content="Linxiao&#39;s Blog">
<meta property="og:description" content="之前讨论过大量关于文件I&#x2F;O的系统调用，现在我们的视角从文件内部回到文件本身。在Linux中一切皆为文件，而文件包含大量的元数据。诸如：类型、权限、硬链接、软连接、所属用户、所属组、最后访问时间、最后修改时间、最后状态改变时间等。本篇主要讲解文件这些属性的获取与管理。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191130&#x2F;20191130090457.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191130&#x2F;20191130105045.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191202110139.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191202122005.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191202143001.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191202154031.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191202155931.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191202163535.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191202171448.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191202181701.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191202192634.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191202202837.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191202204218.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191202205756.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191203090001.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191203093612.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191202&#x2F;20191203094534.png">
<meta property="og:updated_time" content="2019-12-03T03:03:01.309Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191130&#x2F;20191130090457.png">

<link rel="canonical" href="https://linxiao.pro/2019/12/03/linux-programming-file-and-directory/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>linux系统编程-文件与目录管理 | Linxiao's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Linxiao's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">学习、记录、分享</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://linxiao.pro/2019/12/03/linux-programming-file-and-directory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linxiao">
      <meta itemprop="description" content="半醒半醉日复日，花落花开年复年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linxiao's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          linux系统编程-文件与目录管理
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-12-03 11:03:01 / 修改时间：03:03:01" itemprop="dateCreated datePublished" datetime="2019-12-03T11:03:01Z">2019-12-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/12/03/linux-programming-file-and-directory/" class="post-meta-item leancloud_visitors" data-flag-title="linux系统编程-文件与目录管理" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>之前讨论过大量关于文件I/O的系统调用，现在我们的视角从文件内部回到文件本身。在Linux中一切皆为文件，而文件包含大量的元数据。诸如：类型、权限、硬链接、软连接、所属用户、所属组、最后访问时间、最后修改时间、最后状态改变时间等。本篇主要讲解文件这些属性的获取与管理。<a id="more"></a></p>
<h3 id="从ls说起"><a href="#从ls说起" class="headerlink" title="从ls说起"></a>从ls说起</h3><p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191130/20191130090457.png" alt=""></p>
<p>当需要查看文件属性的时候，通常使用最多的命令是<code>ls -l</code>，上图说明了各列所代表的含义，这里挑出以下两列进行补充说明：</p>
<h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p><code>ls -l</code>命令所列文件属性的中第一列第一个字母代表文件类型，Linux文件一共分为7大类，用字母和符号<code>-</code>表示，其含义分别是：</p>
<ul>
<li><code>-</code> 普通文件</li>
<li><code>d</code> 目录文件，用于管理目录项，保存文件名和文件节点</li>
<li><code>c</code> 字符设备文件，如：/dev/input 下的键盘、鼠标</li>
<li><code>b</code> 块设备文件，如：/dev/下的磁盘。与字符设备的区别在于：块设备文件是以块（如4096字节）为单位来操作数据，而前者是以字节为单位来操作数据</li>
<li><code>p</code> FIFO管道文件，用于实现不同进程之间的通信</li>
<li><code>s</code> socket文件，用于网络通信</li>
<li><code>l</code> 符号链接文件，类似于Windows中的快捷方式，实则是指向另外一个文件的路径</li>
</ul>
<h4 id="硬链接数"><a href="#硬链接数" class="headerlink" title="硬链接数"></a>硬链接数</h4><p>每个文件在文件系统中是用一个<code>inode(索引节点)</code>来表示，同时<code>inode编号</code>也是文件系统中表示此文件的唯一数值。通常一个<code>inode节点</code>至少有一个硬链接，由此我们便可通过硬链接对该文件节点进行索引。如果一个文件有多个硬链接，那么每个硬链接所指向的<code>inode</code>节点是一样的，换句话说，他们只是这个文件节点的不同名字而已。如果一个<code>inode节点</code>的所有硬链接都被删除，那么它也就没有存在的价值，相当于是文件节点被删除。通过<code>ls -li</code>命令可以查看一个文件的<code>inode编号</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  touch a.txt                                # 创建文件</span><br><span class="line">➜  ln a.txt b.txt                             # 创建该文件的硬链接</span><br><span class="line">➜  ls -l                                      # 查看文件硬链接数</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r-- 2 noir noir 0 11月 29 18:08 a.txt</span><br><span class="line">-rw-r--r-- 2 noir noir 0 11月 29 18:08 b.txt</span><br><span class="line">➜  ls -li                                     # 查看硬链接所指向的文件inode节点编号</span><br><span class="line">总用量 0</span><br><span class="line">1441898 -rw-r--r-- 2 noir noir 0 11月 29 18:08 a.txt</span><br><span class="line">1441898 -rw-r--r-- 2 noir noir 0 11月 29 18:08 b.txt</span><br></pre></td></tr></table></figure>

<h3 id="stat系统调用"><a href="#stat系统调用" class="headerlink" title="stat系统调用"></a>stat系统调用</h3><p>要想实现类似于<code>ls -l</code>这样的功能，我们先要了解<code>stat</code>相关的系统调用</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191130/20191130105045.png" alt=""></p>
<p><code>stat</code>是一组函数，用于获取文件的元数据。上面三个函数的区别在于：<code>stat</code>函数会返回由参数<code>pathname</code>所指定的文件信息，而<code>fstat</code>返回由文件描述符<code>fd</code>所指向的文件信息。<code>lstat</code>与<code>stat</code>类似，唯一的区别是对于符号链接，<code>lstat</code>返回的是链接本身而非目标文件。以上三个函数调用出错时会返回-1，并设置相应的errno值，而调用成功，则将元数据存储在<code>stat</code>结构体中，即<code>statbuf</code>参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_dev;         <span class="comment">/* 文件所位于的设备节点ID，若文件不在本地，如在网络文件系统上，则该值为0 */</span></span><br><span class="line">    <span class="keyword">ino_t</span>     st_ino;         <span class="comment">/* 文件属性信息所在inode节点的编号 */</span></span><br><span class="line">    <span class="keyword">mode_t</span>    st_mode;        <span class="comment">/* 文件类型和访问权限 */</span></span><br><span class="line">    <span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">/* 文件节点的所有硬链接数 */</span></span><br><span class="line">    <span class="keyword">uid_t</span>     st_uid;         <span class="comment">/* 文件所有者的ID */</span></span><br><span class="line">    <span class="keyword">gid_t</span>     st_gid;         <span class="comment">/* 文件所属组的ID */</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_rdev;        <span class="comment">/* 如果文件是设备节点，则该字段描述设备节点ID */</span></span><br><span class="line">    <span class="keyword">off_t</span>     st_size;        <span class="comment">/* 文件大小字节数 */</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize;     <span class="comment">/* 文件系统进行I/O操作时的块大小，该值（或倍数）为用户缓冲I/O的最佳块大小 */</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* 分配给文件的块数目 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* 最近一次文件被访问的时间（读） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* 最近一次文件被修改的的时间（写） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* 最近一次文件状态改变的时间（所有者、所属组或权限变更） */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到关于块设备、时间的数据，这是通过<code>ls -l</code>无法获取的，此时可以使用<code>stat</code>命令。没错，<code>stat</code>既是系统调用，同时也是一个Linux命令，用于查看文件属性详细信息。需要注意的是Linux并不保存文件创建时间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  stat cmake-3.15.1.tar.gz</span><br><span class="line">  File: cmake-3.15.1.tar.gz</span><br><span class="line">  Size: 9268592   	Blocks: 18104      IO Block: 4096   regular file</span><br><span class="line">Device: 801h/2049d	Inode: 1966105     Links: 1</span><br><span class="line">Access: (0664/-rw-rw-r--)  Uid: ( 1000/    noir)   Gid: ( 1000/    noir)</span><br><span class="line">Access: 2019-08-05 02:54:52.985260332 -0700</span><br><span class="line">Modify: 2019-08-05 02:54:26.640913268 -0700</span><br><span class="line">Change: 2019-08-05 02:54:30.236958359 -0700</span><br></pre></td></tr></table></figure>

<p>下面我们来写一个例子<code>main.c</code>，用来读取自身的基本信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">"main.c"</span>, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"文件类型及权限：%o\t"</span>, buf.st_mode);        <span class="comment">// 输出文件类型和权限</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"硬链接数：%ld\t"</span>, buf.st_nlink);           <span class="comment">// 输出文件硬链接数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者：%d\t"</span>, buf.st_uid);                <span class="comment">// 输出文件所有者</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组：%d\t"</span>, buf.st_gid);                <span class="comment">// 输出文件所属组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"大小：%ld字节\t"</span>, buf.st_size);            <span class="comment">// 输出文件大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最后访问时间：%ld\t"</span>, buf.st_atim.tv_sec); <span class="comment">// 输出文件最后访问时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件类型及权限：100664	硬链接数：1	所有者：1000	所属组：1000	大小：79字节	最后访问时间：1574991522</span><br></pre></td></tr></table></figure>

<p>可见，除了硬链接数和文件大小能很清晰的知道其含义，其余几个字段并不像<code>ls -l</code>输出那般直观。但仔细想想，所有者和所属组用数字表示，应该是指代ID，从<code>/etc/passwd</code>和<code>/etc/group</code>文件中可以很容易找到其对应的名称。而最后访问时间，看这长度也能联想到，它指代Unix时间戳。如何从用户ID及组ID反向得到名称，以及解析时间属于系统信息相关内容，暂时先放到后续篇章吧。本文主要讲述文件属性，所以我们先把注意力放到文件类型解析和权限上面。</p>
<h4 id="文件类型解析"><a href="#文件类型解析" class="headerlink" title="文件类型解析"></a>文件类型解析</h4><p>通过代码来演示如何解析文件类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">"main.c"</span>, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File type:"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (buf.st_mode &amp; S_IFMT) &#123;</span><br><span class="line">        <span class="keyword">case</span> S_IFBLK:  <span class="built_in">printf</span>(<span class="string">"block device\n"</span>);            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR:  <span class="built_in">printf</span>(<span class="string">"character device\n"</span>);        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR:  <span class="built_in">printf</span>(<span class="string">"directory\n"</span>);               <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO:  <span class="built_in">printf</span>(<span class="string">"FIFO/pipe\n"</span>);               <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK:  <span class="built_in">printf</span>(<span class="string">"symlink\n"</span>);                 <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG:  <span class="built_in">printf</span>(<span class="string">"regular file\n"</span>);            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFSOCK: <span class="built_in">printf</span>(<span class="string">"socket\n"</span>);                  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:       <span class="built_in">printf</span>(<span class="string">"unknown?\n"</span>);                <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File type:regular file</span><br></pre></td></tr></table></figure>

<p>可以看到上述代码的关键步骤，其实是把<code>st_mode</code>&amp;<code>S_IFMT</code>，然后通过匹配一系列宏来得到具体文件类型。为什么可以这样做，首先我们从<code>st_mode</code>说起。上面打印出的<code>st_mode</code>是八进制的100664，我们将其转换成二进制来看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OCT    100 664</span><br><span class="line">BIN    1000 000 110 110 100</span><br></pre></td></tr></table></figure>

<p>上面的二进制位中，第0-8位代表访问权限，13-15位代表文件类型。先记住这个规律，然后再来看<code>S_IFMT</code>宏，我们可以先在<code>sys/stat.h</code>中找到其定义，然后在<code>bits/stat.h</code>中找到最终定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span>   S_IFMT		__S_IFMT</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span>   __S_IFMT	    0170000	 <span class="comment">/* These bits determine file type.  *</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>S_IFMT</code>实际上是一串八进制码，现在将其转换成二进制：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OCT    0170000</span><br><span class="line">BIN    1111 000 000 000 000</span><br></pre></td></tr></table></figure>

<p>所以，一旦<code>st_mode</code>&amp;<code>S_IFMT</code>，实际上也就是说，0-12位被屏蔽了，剩下的13-15位代表真正的文件类型，我们拿着它和文件类型的宏定义进行匹配就行了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st_mode    1000 000 110 110 100   </span><br><span class="line">&amp;</span><br><span class="line">S_IFMT     1111 000 000 000 000</span><br><span class="line">-------------------------------</span><br><span class="line">           1000 000 000 000 000</span><br></pre></td></tr></table></figure>

<p>再来看文件类型宏定义，同样先在<code>sys/stat.h</code>中找到其定义，然后在<code>bits/stat.h</code>中找到最终定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> S_IFDIR	__S_IFDIR</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> S_IFCHR	__S_IFCHR</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> S_IFBLK	__S_IFBLK</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> S_IFREG	__S_IFREG</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> S_IFIFO	__S_IFIFO</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> S_IFLNK	__S_IFLNK</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> S_IFSOCK	__S_IFSOCK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* File types.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__S_IFDIR	0040000	<span class="comment">/* Directory. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__S_IFCHR	0020000	<span class="comment">/* Character device.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__S_IFBLK	0060000	<span class="comment">/* Block device.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__S_IFREG	0100000	<span class="comment">/* Regular file.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__S_IFIFO	0010000	<span class="comment">/* FIFO.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__S_IFLNK	0120000	<span class="comment">/* Symbolic link.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__S_IFSOCK	0140000	<span class="comment">/* Socket.  */</span></span></span><br></pre></td></tr></table></figure>

<p>上面的代码并不太直观，我们进行一个整理，列出下表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">文件类型    八进制码    二进制码  </span><br><span class="line">S_IFDIR	   0040000    0100 000 000 000 000</span><br><span class="line">S_IFCHR	   0020000    0010 000 000 000 000</span><br><span class="line">S_IFBLK	   0060000    0110 000 000 000 000</span><br><span class="line">S_IFREG	   0100000    1000 000 000 000 000</span><br><span class="line">S_IFIFO	   0010000    0001 000 000 000 000</span><br><span class="line">S_IFLNK	   0120000    1010 000 000 000 000</span><br><span class="line">S_IFSOCK   0140000    1100 000 000 000 000</span><br></pre></td></tr></table></figure>

<p>可见，上面由<code>st_mode</code>&amp;<code>S_IFMT</code>得到的文件类型二进制码刚好与<code>S_IFREG</code>相匹配，说明此文件是普通文件。实际上在<code>sys/stat.h</code>中提供了一系列带参宏，以方便我们进行快速文件判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Test macros for file types.	*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__S_ISTYPE(mode, mask)	(((mode) &amp; __S_IFMT) == (mask))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_ISDIR(mode)	 __S_ISTYPE((mode), __S_IFDIR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_ISCHR(mode)	 __S_ISTYPE((mode), __S_IFCHR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_ISBLK(mode)	 __S_ISTYPE((mode), __S_IFBLK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_ISREG(mode)	 __S_ISTYPE((mode), __S_IFREG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISFIFO(mode)	 __S_ISTYPE((mode), __S_IFIFO)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISLNK(mode)	 __S_ISTYPE((mode), __S_IFLNK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISSOCK(mode)   __S_ISTYPE((mode), __S_IFSOCK)</span></span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">"../main.c"</span>, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Is regular file: %d\n"</span>, S_ISREG(buf.st_mode));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Is directory:    %d\n"</span>, S_ISDIR(buf.st_mode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Is regular file: 1</span><br><span class="line">Is directory:    0</span><br></pre></td></tr></table></figure>

<p>到这里，文件类型解析部分已讲完，下面来看看文件权限解析。</p>
<h4 id="文件权限解析"><a href="#文件权限解析" class="headerlink" title="文件权限解析"></a>文件权限解析</h4><p>其实文件权限解析与文件类型解析的方式如出一辙，我们先来看代码，再进行讲解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">"../main.c"</span>, &amp;buf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者可读取：       %o\n"</span>, S_IRUSR&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者可写入：       %o\n"</span>, S_IWUSR&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者可执行：       %o\n"</span>, S_IXUSR&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所有者可读写执行：    %o\n"</span>, S_IRWXU&amp;buf.st_mode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组可读取：       %o\n"</span>, S_IRGRP&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组可写入：       %o\n"</span>, S_IWGRP&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组可执行：       %o\n"</span>, S_IXGRP&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"所属组可读写执行：    %o\n"</span>, S_IRWXG&amp;buf.st_mode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他人可读取：       %o\n"</span>, S_IROTH&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他人可写入：       %o\n"</span>, S_IWOTH&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他人可执行：       %o\n"</span>, S_IXOTH&amp;buf.st_mode);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其他人可读写执行：    %o\n"</span>, S_IRWXO&amp;buf.st_mode);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"文件权限：           %o\n"</span>, (S_IRWXU&amp;buf.st_mode)|(S_IRWXG&amp;buf.st_mode)|(S_IRWXO&amp;buf.st_mode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">所有者可读取：       400</span><br><span class="line">所有者可写入：       200</span><br><span class="line">所有者可执行：       0</span><br><span class="line">所有者可读写执行：    600</span><br><span class="line">所属组可读取：       40</span><br><span class="line">所属组可写入：       20</span><br><span class="line">所属组可执行：       0</span><br><span class="line">所属组可读写执行：    60</span><br><span class="line">其他人可读取：       4</span><br><span class="line">其他人可写入：       0</span><br><span class="line">其他人可执行：       0</span><br><span class="line">其他人可读写执行：    4</span><br><span class="line">文件权限：           664</span><br></pre></td></tr></table></figure>

<p>通过代码可以很直观的获取每个具体权限，并得到文件的整体权限是664，换句话说，该文件权限为<code>rw-rw-r--</code>。在<code>st_mode</code>中，0~8共9位二进制码分三组来表示所有者、所属组和其他人的读、写、执行权限。如下所示，1表示该位有权限，0表示没有。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OCT    664</span><br><span class="line">       所有者  所属组  其他人</span><br><span class="line">       rwx     rwx    rwx</span><br><span class="line">BIN    110     110    100</span><br></pre></td></tr></table></figure>

<p>而<code>S_IRUSR S_IWUSR S_IXUSR...</code>这类宏则是用于测试二进制位是否持有对应的权限，可以在<code>sys/stat.h</code>和<code>bits/stat.h</code>中找到他们的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IRUSR	__S_IREAD	<span class="comment">/* Read by owner.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IWUSR	__S_IWRITE	<span class="comment">/* Write by owner.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IXUSR	__S_IEXEC	<span class="comment">/* Execute by owner.  */</span></span></span><br><span class="line"><span class="comment">/* Read, write, and execute by owner.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IRWXU	(__S_IREAD|__S_IWRITE|__S_IEXEC)  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__S_IREAD	0400	<span class="comment">/* Read by owner.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__S_IWRITE	0200	<span class="comment">/* Write by owner.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	__S_IEXEC	0100	<span class="comment">/* Execute by owner.  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IRGRP	(S_IRUSR &gt;&gt; 3)	<span class="comment">/* Read by group.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IWGRP	(S_IWUSR &gt;&gt; 3)	<span class="comment">/* Write by group.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IXGRP	(S_IXUSR &gt;&gt; 3)	<span class="comment">/* Execute by group.  */</span></span></span><br><span class="line"><span class="comment">/* Read, write, and execute by group.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IRWXG	(S_IRWXU &gt;&gt; 3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IROTH	(S_IRGRP &gt;&gt; 3)	<span class="comment">/* Read by others.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IWOTH	(S_IWGRP &gt;&gt; 3)	<span class="comment">/* Write by others.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IXOTH	(S_IXGRP &gt;&gt; 3)	<span class="comment">/* Execute by others.  */</span></span></span><br><span class="line"><span class="comment">/* Read, write, and execute by others.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IRWXO	(S_IRWXG &gt;&gt; 3)</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是组相关权限二进制码是对所有者相关权限进行右移3位，而其他人相关权限又是对组用户相关权限进行右移3位操作。现在来举个例子，假如我们要判断所有者是否可读，那么需要通过<code>st_mode &amp; S_IRUSR</code>，换成二进制代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OCT    664</span><br><span class="line">BIN    110 110 100    </span><br><span class="line">&amp; S_IRUSR</span><br><span class="line">OCT    400</span><br><span class="line">BIN    100 000 000</span><br><span class="line">------------------</span><br><span class="line">       100 000 000</span><br></pre></td></tr></table></figure>

<p>可见，通过按位与操作后，屏蔽了0~7位，在第8位上标记了所有者可读的权限。其余的判断也是以此类推。至此，我们学完了文件权限解析。</p>
<h3 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h3><p>通过<code>stat</code>系统调用可以获取到文件权限属性，但仅获取是不够的，我们还需要学会设置权限。通常情况下，在Linux系统中设置访问权限和所有权最常用的命令是<code>chmod</code>及<code>chown</code>。而在系统编程这一层级，这两个命令内部的核心实现又是系统调用<code>chmod</code>和系统调用<code>chown</code>，我们可以通过<code>man 2 chmod</code>和<code>man 2 chown</code>来查看。</p>
<h4 id="访问权限设置"><a href="#访问权限设置" class="headerlink" title="访问权限设置"></a>访问权限设置</h4><p>先来看看<code>chmod</code>的定义：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202110139.png" alt=""></p>
<p><code>chmod</code>和<code>fchmod</code>都可以把文件权限设置为参数<code>mode</code>指定的值。对于<code>chmod</code>函数，参数<code>pathname</code>表示需要修改的文件的相对或绝对路径名。对于<code>fchmod</code>函数，文件是由文件描述符<code>fd</code>给定。类型<code>mode_t</code>(整形)表示的是参数<code>mode</code>的合法值，和结构体<code>stat</code>中字段<code>st_mode</code>返回的值一样。上面我们学到过一系列描述权限位的宏，在此我们可以通过或运算来组合这些权限位，生成合法的<code>mode</code>值。例如（S_IRUSR|S_IRGRP）会同时把文件所有者和所属组的权限都设置为可读。</p>
<p>需要注意的是，为了改变文件权限，调用<code>chmod</code>和<code>fchmod</code>的进程有效ID必须匹配文件所有者。换句话说，如果文件file的所有者是alan，那么必须alan这一用户执行系统调用，才能改变file的权限。当然，如果是root用户，就不会有这一限制。</p>
<p>调用成功时，<code>chmod</code>和<code>fchmod</code>都返回0，失败时，都返回-1，并设置相应的errno值。下面来举个例子，现有文件<code>test.txt</code>，权限为777，通过代码将其变成660：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ls -l test.txt </span><br><span class="line">-rwxrwxrwx 1 noir noir 0 12月  1 19:21 test.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = chmod(<span class="string">"../test.txt"</span>, <span class="number">0660</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"chmod"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ls -l test.txt</span><br><span class="line">-rw-rw---- 1 noir noir 0 12月  1 19:21 test.txt</span><br></pre></td></tr></table></figure>

<p>之前说到过<code>mode</code>参数需要通过权限位宏进行组合来生成需要的值，这里我们直接使用了<code>0666</code>这样的八进制值也是可以的。并且如果你对Linux应用足够熟悉的话，这么做反而更加直观。</p>
<h4 id="所有权设置"><a href="#所有权设置" class="headerlink" title="所有权设置"></a>所有权设置</h4><p>在结构体<code>stat</code>中，我们看到过<code>st_uid</code>和<code>st_gid</code>，它们分别表示文件的所有者和所属组。通过以下三个系统调用可以改变这两个值，即改变文件的所有者和所属组：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202122005.png" alt=""></p>
<p><code>chown</code>和<code>lchown</code>设置路径<code>pathname</code>指定的文件的所有权。它们的作用是相同的，除非文件是个符号链接：前者会获取符号链接所指向的目标文件，并改变链接目标而不是链接本身的所有权，而<code>lchown</code>并不会获取符号链接所指向的目标文件，只是改变符号链接本身的所有权。<code>fchown</code>则设置文件描述符<code>fd</code>所指向的文件的所有权。</p>
<p>成功时，三个调用都会把文件所有者设置为<code>owner</code>，文件所属组设置为<code>group</code>，并返回0。如果参数<code>owner</code>或<code>group</code>的值为-1，说明值没有设定。失败时，均返回-1，并设置相应的errno值。需要注意的是，通常情况下只有root用户才有权限对文件所有权进行变更。一般用户，即无法改变自己文件的所有者和所属组，亦无法改变别人的文件。</p>
<p>下面进行演示，如何先使用<code>adduser</code>命令创建一个新用户<code>alan</code>和与之相应的用户组，然后再通过代码将所有权和所属组为<code>noir</code>的文件<code>test.txt</code>变更到<code>alan</code>下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  sudo adduser alan                               # 创建用户和用户组alan</span><br><span class="line">➜  cat /etc/passwd | tail -n1                </span><br><span class="line">alan:x:1001:1001:Alan,,,:/home/alan:/bin/bash       # 查看到alan的用户id为1001</span><br><span class="line">➜  cat /etc/group | tail -n1                 </span><br><span class="line">alan:x:1001:                                        # 查看到alan的用户组id也为1001</span><br><span class="line">➜  ls -l test.txt                                  </span><br><span class="line">-rw-rw---- 1 noir noir 0 12月  1 19:21 test.txt     # 查看到test.txt的所有者和所属组均为noir</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = chown(<span class="string">"test.txt"</span>, <span class="number">1001</span>, <span class="number">1001</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"chown"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件所有权修改成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成功后，需要使用<code>sudo</code>提升权限，或用<code>root</code>用户登录执行程序。执行成功查看<code>text.txt</code>文件所有权，已经成功变更：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ls -l test.txt </span><br><span class="line">-rw-rw---- 1 alan alan 0 12月  1 19:21 test.txt</span><br></pre></td></tr></table></figure>

<p>代码比较简单，只是在<code>chown</code>中把参数写死，而不是通过查询得到<code>uid</code>和<code>gid</code>，这种操作并不好。但由于本篇主要讲解的还是文件相关，所以如何通过用户名反查得到id，暂时先搁置，等到了解系统属性和用户相关的系统调用的时候再说。此外，不少人刚开始接触Linux的时候，对多用户和组的概念并不十分清晰，主要是因为我们现在用的都是个人计算机。而在以前，计算机可是庞然大物，一个学校和一个机构可能仅有一台计算机，大家都是通过终端来连接这台机器进行工作。为了划分权限，提高安全性以及分组管理，于是也就出现了文件所有者和所属组以及其他用户这些概念。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>前面讲到过，文件其实是用<code>inode节点来表示</code>，通过硬链接可以索引到相应的<code>inode节点</code>，也就是说链接相当于节点的名字。奇怪的是，我们使用<code>stat</code>系统调用查看文件属性的时候并没有看到描述文件名称的字段，只有硬链接数。这是因为，文件名并不保存在<code>inode节点</code>，而是保存在目录中。目录中的每个名字其实也就是一个硬链接。这样一来，也就维系了目录与文件<code>inode节点</code>的组织关系。需要注意的是，不同文件系统的<code>inode编号</code>并不一致，所以硬链接并不能跨磁盘。</p>
<p>文件的链接数可以是0、1或多个。大多数文件的链接数是1，也就是说只有一个目录项指向该文件，但有些文件可能有两个或甚至多个链接。链接数为0的文件在文件系统上没有对应的目录项。当文件链接计数达到0时，文件被标记为空闲，其占用的磁盘块就可被重用。当进程打开了这样一个文件时，文件仍在文件系统中保留。如果没有进程打开该文件，文件就会被删除。</p>
<p>Linux内核通过<code>链接计数</code>和<code>使用计数</code>来进行管理。使用计数是指文件被打开的实例数。只有当某个文件的链接计数和使用计数都为0时，该文件才会从文件系统中删除。</p>
<p>另一种链接是符号链接，它不是文件系统中文件名和<code>inode节点</code>的映射，而是更高层次的指针，在运行时解释。因此符号链接可跨域文件系统。</p>
<h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>通过<code>link</code>系统调用可以为已有的文件创建新的硬链接(或称作别名）：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202143001.png" alt=""></p>
<p>成功调用<code>link</code>会为<code>oldpath</code>所指向的文件，在路径<code>newpath</code>下创建新的硬链接，也可以说是别名。因为调用成功后，<code>oldpath</code>和<code>newpath</code>都会指向到同一个文件上，事实上并没有办法区分哪个是初始链接。调用失败，则返回-1，并设置相应的errno值。下面来看代码演示，我们为当前目录下的<code>test.txt</code>创建一个新的目录项（硬链接）<code>test2.txt</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = link(<span class="string">"./test.txt"</span>, <span class="string">"./test2.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"link"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建成功后我们删除<code>test.txt</code>，发现通过<code>test2.txt</code>依然可以访问原文件。只有把<code>test2.txt</code>删除，并且此时没有任何进程打开此文件的时候，那么该文件才算是彻底被删除。</p>
<p>需要注意的是，硬链接不能指向目录，因为硬链接映射的是文件<code>inode节点</code>，而目录不是<code>inode节点</code>。虽然硬链接无法指向目录，但是下面要讲的符号链接可以。</p>
<h4 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h4><p>符号链接，也称为<code>symlinks</code>或<code>软链接</code>。它和硬链接的相同之处在于二者均指向文件系统中的文件，不同点在于符号链接不会增加额外的目录项，而是一种特殊的文件类型。该文件包含了它所指向的目标文件的路径名。运行时，内核用该路径名代替符号链接的路径名(若使用以<code>l</code>开头的系统调用，例如<code>lstat</code>，它操作的则是链接本身而非目标文件)。一个硬链接与指向同一文件的另一个硬链接很难区分，但很容易区分符号链接以及其目标文件。软链接和硬链接相比，另一个很重要的区别点在于：由于它是对路径的映射而非<code>inode</code>节点的映射，所以可以跨越不同的文件系统。当然，符号链接也可以指向一个不存在的文件，但通常这没有任何意义。创建符号链接的系统调用和创建硬链接的系统调用非常类似：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202154031.png" alt=""></p>
<p><code>symlink</code>调用成功时，会创建符号链接<code>linkpath</code>，指向由<code>target</code>所表示的目标文件，并返回0，出错时返回-1，并设置相应的errno值。下面来看代码演示，与上例类似，我们为当前目录下的<code>test.txt</code>创建一个新的软链接<code>test2.txt</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = symlink(<span class="string">"./test.txt"</span>, <span class="string">"./test2.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"symlink"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="读取符号链接路径"><a href="#读取符号链接路径" class="headerlink" title="读取符号链接路径"></a>读取符号链接路径</h5><p>通过<code>symlink</code>可以为指定的文件创建符号链接，也可通过<code>readlink</code>系统调用来反向读取符号链接所指向的目标文件路径：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202155931.png" alt=""></p>
<p><code>pathname</code>为需要反向读取的符号链接路径，<code>buf</code>用于存放目标文件路径，<code>bufsiz</code>用来指定读取多少个字节到<code>buf</code>中。当调用成功时，<code>readlink</code>返回读取的字节数，若返回的数值与<code>bufsiz</code>参数相等，则说明目标文件路径发生了截短。出错时，返回-1，并设置相应的errno值。上面我们已经有了符号链接<code>test2.txt</code>，下面通过代码来演示读取其目标路径：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    ret = readlink(<span class="string">"test2.txt"</span>, buf, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"readlink"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为路径字符串设置尾标记以方便读取</span></span><br><span class="line">    buf[ret] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.txt          # 此为符号链接所指向的目标文件路径</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>readlink</code>系统调用仅针对符号链接有效，而无法反向获取硬链接所指向的目标文件。前面已经讲过，多个硬链接指向同一个<code>inode节点</code>的时候，并没有主次之分。</p>
<h4 id="解除链接"><a href="#解除链接" class="headerlink" title="解除链接"></a>解除链接</h4><p> 建立链接的反向操作是解除链接，即从文件系统中删除路径名。只需要调用<code>unlink</code>，就可以完成任务：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202163535.png" alt=""></p>
<p><code>unlink</code>调用成功时，会从文件系统中删除<code>pathname</code>，并返回0。如果<code>pathname</code>是指向文件的最后一个硬链接，则会从文件系统中彻底删除该文件。如果进程已经打开文件，在进程关闭文件前，内核不会从文件系统中删除文件。若没有进程打开该文件，文件会被删除。如果<code>pathname</code>指向符号链接，则只会删除该链接，而不会删除目标文件。出错时，<code>unlink</code>返回-1，并设置相应的errno值。下面通过代码来演示删除软链接文件<code>test2.txt</code>和硬链接文件<code>test.txt</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 noir noir    8 12月  2 00:09 test2.txt -&gt; test.txt</span><br><span class="line">-rw-rw-r-- 1 noir noir    0 12月  1 23:52 test.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret1 = unlink(<span class="string">"./test2.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"删除软连接失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret2 = unlink(<span class="string">"./test.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"删除硬连接失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一个<code>unlink</code>被调用时，删除的只是软链接文件，对目标文件<code>test.txt</code>并不会造成影响。而当第二个<code>unlink</code>调用时，由于此时<code>test.txt</code>硬链接总数只有1，因此该文件会被删除。</p>
<p>需要注意的是，<code>unlink</code>无法删除目录。</p>
<h5 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h5><p>通过<code>链接计数</code>和<code>使用计数</code>这两个特性，我们可以利用<code>unlink</code>来创建临时文件，即进程运行时，可正常访问，进程退出后，文件消失。下面通过代码来演示如何创建临时文件<code>data.tmp</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">// 创建新文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"./data.tmp"</span>, O_WRONLY|O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件创建成功后，硬链接数为1，此时通过unlink解除链接</span></span><br><span class="line">    unlink(<span class="string">"./data.tmp"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处执行进程运行中的读写操作</span></span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"hello world"</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程退出前关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下来，一共分四步：</p>
<ul>
<li>通过<code>open</code>或<code>creat</code>系统调用创建文件</li>
<li>文件创建成功后，马上通过<code>unlink</code>系统调用解除该文件的链接</li>
<li>正常使用此文件进行读写操作，此时目录无法索引此文件，但文件依然可用</li>
<li>进程退出前关闭文件描述符，进程退出后，文件便会自动被删除</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>前面通过使用<code>unlink</code>的方式删除文件，为了简化对各类型文件的删除，C语言提供了<code>remove</code>函数。由于此函数并非系统调用，我们需要通过<code>man 3 remove</code>来查看相应文档：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202171448.png" alt=""></p>
<p>成功调用<code>remove</code>时，会从文件系统删除<code>pathname</code>，并返回0。如果<code>pathname</code>是一个文件，<code>remove</code>会调用<code>unlink</code>；如果<code>pathname</code>是个目录，<code>remove</code>会调用<code>rmdir</code>完成目录删除。关于<code>rmdir</code>放到后面目录主题来讲解。出错时，<code>remove</code>返回-1，并设置相应errno值。下面通过代码来演示删除一个普通文件<code>test.txt</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = <span class="built_in">remove</span>(<span class="string">"test.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p><code>cp</code>拷贝应该是Linux系统中最常使用的命令之一，然而令人沮丧的是，它并没有直接对应的系统调用可供使用，而是通过一系列的文件I/O操作。举个例子，要拷贝文件<code>src</code>至文件<code>dst</code>，需要执行以下步骤：</p>
<ol>
<li>打开src</li>
<li>打开dst，如果dst不存在则创建，如果已存在则把其长度截断为零</li>
<li>把src数据块读取到内存</li>
<li>把该数据块写入dst</li>
<li>继续操作直到src全部读取完并已经都写入到dst中</li>
<li>关闭dst</li>
<li>关闭src</li>
</ol>
<p>下面我们根据这些步骤来写一段代码，以演示如何将当前源码文件<code>main.c</code>备份到<code>backup.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd_src, fd_dst;</span><br><span class="line">    fd_src = <span class="built_in">open</span>(<span class="string">"main.c"</span>, O_RDONLY);</span><br><span class="line">    fd_dst = <span class="built_in">open</span>(<span class="string">"backup.c"</span>, O_WRONLY | O_CREAT | O_TRUNC);</span><br><span class="line">    <span class="keyword">if</span> (fd_src == <span class="number">-1</span> || fd_dst == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 循环从fd_src中读取数据，并写入到fd_dst中</span></span><br><span class="line">    <span class="keyword">while</span> ((len = <span class="built_in">read</span>(fd_src, buf, <span class="number">100</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">write</span>(fd_dst, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd_dst);</span><br><span class="line">    <span class="built_in">close</span>(fd_src);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，实际上Linux系统中的<code>cp</code>命令要复杂得多，需要考虑的情况也很多，这里只是做一个基本演示，详细可以查看<code>cp</code>命令源码：<a href="https://github.com/coreutils/coreutils/blob/master/src/cp.c" target="_blank" rel="noopener">点此查看</a></p>
<h3 id="移动、重命名"><a href="#移动、重命名" class="headerlink" title="移动、重命名"></a>移动、重命名</h3><p>与拷贝文件不同，UNIX提供了<code>rename</code>系统调用来进行移动和重命名操作：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202181701.png" alt=""></p>
<p>成功调用<code>rename</code>时会返回0，原来由<code>oldpath</code>指向的文件现在变成由<code>newpath</code>指向。失败时，调用返回-1，但不影响<code>oldpath</code>或<code>newpath</code>，并设置相应的errno值。下面通过代码来演示如何将文件<code>a.txt</code>重命名为<code>b.txt</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = rename(<span class="string">"./a.txt"</span>, <span class="string">"./b.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"rename"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得说明的是，在相同目录层级下，<code>rename</code>系统调用为重命名操作。而不同目录层级，则为移动。事实上并没有移动这么一说，文件<code>inode节点</code>没有发生任何变化，只是指向它的链接（路径）变了而已。这也就要求，在进行<code>rename</code>系统调用的时候必须在相同文件系统内，否则会发生未知错误。</p>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>在UNIX中，目录是个简单的概念：它包含一个文件名列表，每个文件名对应一个<code>inode编号</code>。每个文件名称为目录项，每个目录项到<code>inode节点</code>的映射称为链接。目录内容（就是用户执行ls命令所看到的结果）就是该目录下所有文件名列表。当用户打开指定目录下的文件时，内核会在该目录列表中查找文件名所对应的<code>inode编号</code>，并将该<code>inode编号</code>传递给文件系统，文件系统使用它来寻找文件在设备上的物理位置。</p>
<h4 id="获取当前工作目录"><a href="#获取当前工作目录" class="headerlink" title="获取当前工作目录"></a>获取当前工作目录</h4><p>每个进程都有一个当前工作目录，一般是在创建时从父进程继承的。当未指定绝对路径时，当前进程进行的任何文件操作，都是以此目录为相对路径进行。获取当前工作目录的方法是通过系统调用<code>getcwd</code>:</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202192634.png" alt=""></p>
<p>成功调用<code>getcwd</code>会把当前工作目录以绝对路径名形式拷贝到<code>buf</code>指向的长度为<code>size</code>字节的缓冲区中，并返回一个指向<code>buf</code>的指针。失败时，调用返回<code>NULL</code>，并设置相应的errno值，下面是使用<code>getcwd</code>的一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span> (!getcwd(buf, <span class="number">100</span>)) &#123;</span><br><span class="line">        perror(<span class="string">"getcwd"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前工作目录的绝对路径名大小要大于<code>size</code>个字节，那么会返回NULL；如果<code>buf</code>为NULL，则<code>getcwd</code>的行为是未定义的。在这种情况下，Linux的C库将分配一个长度为<code>size</code>的缓冲区，并在那存储当前工作目录。如果<code>size</code>为0，C库将分配足够大小的缓冲区存储当前工作目录。调用结束后，则由应用程序负责使用<code>free</code>函数来释放缓冲区。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    path = getcwd(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"getcwd"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, path);</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Linux的C库也提供<code>get_current_dir_name</code>函数，当使用<code>getcwd</code>并且传递的<code>buf</code>为NULL，<code>size</code>为0时，其行为与前者一致：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    path = get_current_dir_name();</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"get_current_dir_name"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, path);</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>较早的BSD系统喜欢调用<code>getwd</code>，Linux对其提供向后兼容，调用<code>getwd</code>会把当前工作目录拷贝到<code>buf</code>中，<code>buf</code>的字节长度至少为<code>PATH_MAX</code>。成功时，调用会返回<code>buf</code>指针，而失败时，返回NULL。举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[PATH_MAX];</span><br><span class="line">    <span class="keyword">if</span> (!getwd(path)) &#123;</span><br><span class="line">        perror(<span class="string">"getwd"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, path);</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我的系统Ubuntu中，编译时会报警告</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">警告： the `getwd' function is dangerous and should not be used.</span><br></pre></td></tr></table></figure>

<p>出于移植性与安全性双重原因，应用程序不应该使用<code>getwd</code>，推荐使用<code>getcwd</code>。</p>
<h4 id="改变当前工作目录"><a href="#改变当前工作目录" class="headerlink" title="改变当前工作目录"></a>改变当前工作目录</h4><p>Linux系统提供了两个系统调用来更改当前工作目录，一个接受目录路径名，而另一个接受指向已打开的目录的文件描述符：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202202837.png" alt=""></p>
<p><code>chdir</code>会把当前工作目录更改为<code>path</code>指定的路径名，该路径名可以是绝对路径，也可以是相对路径。同样，<code>fchdir</code>会把当前工作目录更改为文件描述符<code>fd</code>指向的路径名，而<code>fd</code>必须是打开的目录。成功时，两个调用都返回0；失败时，都返回-1，并设置相应的errno值。如下代码演示切换路径到根目录<code>/</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = chdir(<span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"chdir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    path = getcwd(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"getcwd"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, path);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>在Linux系统中创建目录使用<code>mkdir</code>命令，同样这也是一个系统调用：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202204218.png" alt=""></p>
<p>成功调用<code>mkdir</code>会创建参数<code>pathname</code>所指定的目录（可以是绝对也可以是相对），其权限位为mode（可以通过umask修改），并返回0。调用失败时，<code>mkdir</code>返回-1，并设置相应errno值。举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = <span class="built_in">mkdir</span>(<span class="string">"./a"</span>, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"mkdir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在当前工作目录下创建文件夹<code>a</code>，权限为<code>0777</code>，由于我的umask为<code>002</code>，所以最终创建出的文件夹权限为<code>775</code>。需要注意的是，必须为文件夹设置可执行权限，才能进入文件夹内进行读写操作。</p>
<h4 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h4><p>与<code>mkdir</code>对应，<code>rmdir</code>系统调用会将目录从文件系统中删除</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191202205756.png" alt=""></p>
<p>调用成功时，<code>rmdir</code>会从文件系统中删除<code>pathname</code>，并返回0。前提是<code>pathname</code>指向的目录必须为空，除了<code>.</code>和<code>..</code>目录以外。没有支持类似<code>rm -r</code>一样递归删除功能的系统调用。要实现<code>rm -r</code>功能，首先要执行文件系统的深度优先搜索，从叶节点开始删除所有文件与目录，并返回至<code>pathname</code>所指向的文件夹。当目录内的全部文件被删除时，则可以使用<code>rmdir</code>来删除该目录。下面是一个简单例子，我们将之前创建的<code>a</code>文件夹删除：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = <span class="built_in">rmdir</span>(<span class="string">"./a"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"rmdir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h4><p>读取目录并非由一个函数完成，而是多个函数配合使用。开始读取目录前，首先需要通过<code>opendir</code>打开目录，通过<code>man 3 opendir</code>命令查看此函数文档：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191203090001.png" alt=""></p>
<p><code>opendir</code>函数通过路径打开目录，<code>name</code>参数为要打开的目录路径，可以是绝对路径，也可以是相对路径。<code>fdopendir</code>函数则是通过文件描述符打开目录。调用成功后，两个函数都将创建指向目录的目录流对象（directory stream object）并返回，该对象的具体结构对用户不可见，我们也不需要过多了解。失败时，返回NULL，并设置相应的errno值。</p>
<p>通过<code>opendir</code>创建一个目录流后，就可以使用<code>readdir</code>从目录流，也就是<code>DIR</code>对象中依次返回目录项：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191203093612.png" alt=""></p>
<p>成功调用<code>readdir</code>，会返回<code>dirp</code>指向的下一个目录项。结构体<code>dirent</code>指向目录项，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="keyword">ino_t</span>          d_ino;       <span class="comment">/* Inode number */</span></span><br><span class="line">    <span class="keyword">off_t</span>          d_off;       <span class="comment">/* Not an offset; see below */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;    <span class="comment">/* Length of this record */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  d_type;      <span class="comment">/* Type of file; not supported by all filesystem types */</span></span><br><span class="line">    <span class="keyword">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>连续调用<code>readdir</code>，可获取目录中的每个文件，当整个目录读完时，返回NULL。</p>
<p>此外，当读取完目录不再使用时，应当通过<code>closedir</code>关闭由<code>opendir</code>打开的目录流：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191202/20191203094534.png" alt=""></p>
<p>调用成功时，会关闭<code>dirp</code>参数指向的目录流对象，包括目录的文件描述符，并返回0。失败时，返回-1，并设置相应的errno值。</p>
<p>下面通过代码来演示如何读取<code>/</code>下的目录项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    dir = opendir(<span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"opendir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"inode:%10ld    name:%20s\n"</span>, entry-&gt;d_ino, entry-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inode:        13    name:                 bin</span><br><span class="line">inode:        15    name:               lib32</span><br><span class="line">inode:   1966081    name:                 tmp</span><br><span class="line">inode:        22    name:         vmlinuz.old</span><br><span class="line">inode:        23    name:             vmlinuz</span><br><span class="line">inode:   1572865    name:               media</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>由此，目录操作就讲到这里。实际应用中会出现更多复杂情况，但核心系统调用及库函数的使用基本如上，不会有太多出入。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇主要讲解两大内容，一是文件，二是目录。文件其实是用<code>inode节点</code>来描述，通过链接进行索引。而目录则保存了目录项，也就是文件的链接。此外通过文件还引出了权限的查看与设置操作，以及文件的删除、拷贝、移动、重命名等。最后又讲解了一系列日常开发中很常用的目录操作函数，文中演示的代码很简单，详细需要用户考虑到自身应用场景，编写代码加以练习。</p>

    </div>

    
    
    
      
        <div class="reward-container">
  <div>请作者喝杯咖啡？</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Linxiao 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Linxiao 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Linxiao
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://linxiao.pro/2019/12/03/linux-programming-file-and-directory/" title="linux系统编程-文件与目录管理">https://linxiao.pro/2019/12/03/linux-programming-file-and-directory/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C</a>
              <a href="/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 系统编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/11/29/linux-programming-basic-io/" rel="next" title="linux系统编程-文件I/O基础">
                  <i class="fa fa-chevron-left"></i> linux系统编程-文件I/O基础
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2019/12/04/linux-programming-sys-info/" rel="prev" title="linux系统编程-系统属性">
                  linux系统编程-系统属性 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#从ls说起"><span class="nav-text">从ls说起</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件类型"><span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#硬链接数"><span class="nav-text">硬链接数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stat系统调用"><span class="nav-text">stat系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件类型解析"><span class="nav-text">文件类型解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件权限解析"><span class="nav-text">文件权限解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权限设置"><span class="nav-text">权限设置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#访问权限设置"><span class="nav-text">访问权限设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#所有权设置"><span class="nav-text">所有权设置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接"><span class="nav-text">链接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#硬链接"><span class="nav-text">硬链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#符号链接"><span class="nav-text">符号链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#读取符号链接路径"><span class="nav-text">读取符号链接路径</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解除链接"><span class="nav-text">解除链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建临时文件"><span class="nav-text">创建临时文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除"><span class="nav-text">删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拷贝"><span class="nav-text">拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移动、重命名"><span class="nav-text">移动、重命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录操作"><span class="nav-text">目录操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取当前工作目录"><span class="nav-text">获取当前工作目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#改变当前工作目录"><span class="nav-text">改变当前工作目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建目录"><span class="nav-text">创建目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除目录"><span class="nav-text">删除目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读取目录"><span class="nav-text">读取目录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Linxiao"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Linxiao</p>
  <div class="site-description" itemprop="description">半醒半醉日复日，花落花开年复年</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Linxiao42" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;Linxiao42" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Linxiao</span>
</div>

        






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            leancloudSelector(url).innerText = time;
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=lRaS7JronjiApi73k5iWP8xD-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'lRaS7JronjiApi73k5iWP8xD-gzGzoHsz',
            'X-LC-Key': 'mJ0pFWRQroOumHbNkCV5ohp8',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
        if (localhost.test(document.URL)) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>






        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'lRaS7JronjiApi73k5iWP8xD-gzGzoHsz',
    appKey: 'mJ0pFWRQroOumHbNkCV5ohp8',
    placeholder: "Just go go",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
