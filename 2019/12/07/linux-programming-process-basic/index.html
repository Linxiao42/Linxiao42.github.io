<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="alternate" href="/atom.xml" title="Linxiao's Blog" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="我们写完代码，经过编译生成的可执行二进制文件称作程序。程序保存在磁盘上，它是一个静态概念。而当程序被加载到内存中开始执行时，此时它又是动态的，被称作进程。一个进程涉及到很多方面，如：正在执行的二进制文件、虚拟内存、进程体系、进程状态、进程资源以及调度等等。下面的内容主要来谈谈进程的基本概念和管理。">
<meta name="keywords" content="并发,C,系统编程">
<meta property="og:type" content="article">
<meta property="og:title" content="linux系统编程-进程管理">
<meta property="og:url" content="https:&#x2F;&#x2F;linxiao.pro&#x2F;2019&#x2F;12&#x2F;07&#x2F;linux-programming-process-basic&#x2F;index.html">
<meta property="og:site_name" content="Linxiao&#39;s Blog">
<meta property="og:description" content="我们写完代码，经过编译生成的可执行二进制文件称作程序。程序保存在磁盘上，它是一个静态概念。而当程序被加载到内存中开始执行时，此时它又是动态的，被称作进程。一个进程涉及到很多方面，如：正在执行的二进制文件、虚拟内存、进程体系、进程状态、进程资源以及调度等等。下面的内容主要来谈谈进程的基本概念和管理。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191205135830.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191205162819.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191205162858.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191205171538.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191205184100.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191205215359.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191206093458.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191206112528.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191206161937.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191206220925.png">
<meta property="og:image" content="c:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191206220814857.png">
<meta property="og:image" content="c:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191206224901577.png">
<meta property="og:image" content="c:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191206224932557.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191206225016.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191207104401.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191207112659.png">
<meta property="og:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191207122136.png">
<meta property="og:updated_time" content="2019-12-07T04:33:05.036Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;share-1300759451.cos.ap-beijing.myqcloud.com&#x2F;blog-image&#x2F;20191205&#x2F;20191205135830.png">

<link rel="canonical" href="https://linxiao.pro/2019/12/07/linux-programming-process-basic/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>linux系统编程-进程管理 | Linxiao's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Linxiao's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">学习、记录、分享</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>阅读</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://linxiao.pro/2019/12/07/linux-programming-process-basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linxiao">
      <meta itemprop="description" content="半醒半醉日复日，花落花开年复年">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linxiao's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          linux系统编程-进程管理
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-12-07 12:33:05 / 修改时间：04:33:05" itemprop="dateCreated datePublished" datetime="2019-12-07T12:33:05Z">2019-12-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/12/07/linux-programming-process-basic/" class="post-meta-item leancloud_visitors" data-flag-title="linux系统编程-进程管理" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>我们写完代码，经过编译生成的可执行二进制文件称作程序。程序保存在磁盘上，它是一个静态概念。而当程序被加载到内存中开始执行时，此时它又是动态的，被称作进程。一个进程涉及到很多方面，如：正在执行的二进制文件、虚拟内存、进程体系、进程状态、进程资源以及调度等等。下面的内容主要来谈谈进程的基本概念和管理。<a id="more"></a></p>
<h3 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a>进程ID</h3><p>我们先通过一个例子来引入进程ID这个概念，写一段代码，里面是一个死循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>gcc main.c -o loop</code>命令编译后，我们开始运行这个程序。然后在终端通过<code>ps -a</code>命令查看正在运行的进程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ps -a</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">  1936 tty2     00:35:12 java</span><br><span class="line">  1986 tty2     00:00:04 fsnotifier64</span><br><span class="line">  2303 tty2     00:00:04 gnome-software</span><br><span class="line"> 25474 pts/1    00:00:00 ps</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>可以看到刚运行的<code>loop</code>，其PID为25463，这里的PID也就是进程ID。每个进程的ID是唯一的，也就是说，同一时刻在操作系统内运行的程序，不可能产生两个或多个一样的PID。当进程被回收后，PID是可复用的，但这个概率比较小。因为默认情况下，内核将进程ID的最大值设置为32758，也就是int类型的最大值。只有当创建的进程数超过最大值以后，内核才会复用以前分配过的PID。</p>
<h4 id="获取进程ID和父进程ID"><a href="#获取进程ID和父进程ID" class="headerlink" title="获取进程ID和父进程ID"></a>获取进程ID和父进程ID</h4><p>从代码角度而言，进程ID都是由<code>pid_t</code>来表示，通常为int类型。下面两个系统调用可以获取进程ID：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205135830.png" alt=""></p>
<p><code>getpid</code>用来获取当前进程ID，<code>getppid</code>用于获取父进程ID。没错，每一个子进程都是由父进程派生出来的，所以还有父进程ID这么个概念。你可以通过命令行<code>pstree -p</code>查看进程树和相应的进程ID。由于以上两个函数总是会调用成功，因此不需要进行错误判断，下面用代码来演示打印当前进程ID和父进程ID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"process id:       %10d\n"</span>, pid);</span><br><span class="line"></span><br><span class="line">    pid = getppid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent process id:%10d\n"</span>, pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>再回到我们刚刚跑起来的<code>loop</code>进程，你应该很自然的会想到在终端中用Ctrl+c去终止它。虽然有些暴力，但也的确可以这么做。于是也就引出了我们平常终止进程的两种方式，一是正常终止，二是异常终止。正常终止包括从main返回，调用exit、<code>_exit</code>或<code>_Exit</code>函数。而异常终止包括调用<code>abort</code>，接收终止信号等。在终端中执行Ctrl+c实际上就是给当前执行的进程发送终止信号，其等同于命令<code>kill -9 PID</code>，当<code>loop</code>进程接收到信号后就会终止自身。</p>
<h4 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h4><p>通常情况下，我们在main函数中通过return返回，于是也就退出了进程。但这样的退出方式只在main函数好使，因为程序在实际运行中往往需要调用一系列函数，每次调用相当于将函数进行一次压栈操作，而每次return又相当于从当前函数返回到调用处，也就是出栈。而从main函数return，则相当于将进程中的函数调用栈清空，也就达到了退出进程的目的。这样退出的前提是，所有的函数调用最终都能返回到main中。但事实往往不是，先看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun3\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun2\n"</span>);</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun1\n"</span>);</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如当前进程执行到fun2函数遇到异常，无法向调用处返回，而是希望直接终止进程怎么办？那么最快的方式就是使用退出函数：<code>exit</code>、<code>_exit</code>或<code>_Exit</code>。 先来看三个函数的定义：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205162819.png" alt=""></p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205162858.png" alt=""></p>
<p>3个函数都用于正常终止一个进程，且都带一个<code>status</code>参数，称为终止状态。大多数UNIX系统shell都提供检查进程终止状态的方法，如通过命令行<code>echo $?</code>。其中<code>_exit</code>和<code>_Exit</code>是系统调用，执行后会立即进入内核。当进程退出时，内核会清理进程所创建的、不再使用的所有资源。这包括但不局限于：分配内存、打开文件和System V的信号量。清理完成后，内核会摧毁进程，并告知父进程其子进程已经终止。</p>
<p>进程可以直接调用<code>_exit</code>退出，但通常并不合适，绝大多数进程在完全退出之前，还需要做一些额外的清理工作。这时需要使用<code>exit</code>，它是一个C库函数。<code>exit</code>最终还是会调用系统调用<code>_exit</code>，但在此之前它会清理所有已打开的标准I/O流，并且会调用任何由<code>atexit</code>注册的函数。</p>
<h4 id="atexit"><a href="#atexit" class="headerlink" title="atexit"></a>atexit</h4><p>系统调用<code>atexit</code>用来注册一些在进程结束时要调用的函数</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205171538.png" alt=""></p>
<p><code>atexit</code>调用成功时，会注册指定的函数作为终止函数，在程序正常结束时（即进程通过调用<code>exit</code>或从<code>main</code>函数返回）运行。指定函数必须是无参的，且没有返回值。函数形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>函数调用的顺序和函数注册的顺序相反。也就是说，这些函数是存储在栈中，以后进先出的方式调用（LIFO）。注册的函数不能调用<code>exit</code>，否则会导致递归调用死循环。调用成功<code>atexit</code>返回0。错误时，返回-1。下面通过代码来演示，如何注册：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun3\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fun1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"进程正在运行\n"</span>);</span><br><span class="line">    </span><br><span class="line">    atexit(fun1);</span><br><span class="line">    atexit(fun2);</span><br><span class="line">    atexit(fun3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"进程准备退出\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行新进程"><a href="#运行新进程" class="headerlink" title="运行新进程"></a>运行新进程</h3><p>在UNIX中，把程序载入内存执行和创建新的进程是相互独立的操作。通过<code>exec</code>系列系统调用，可以把二进制程序加载到内存中，替换地址空间原来的内容，并开始执行新程序。而通过<code>fork</code>系统调用，可以创建一个新的进程，它基本上相当于复制其父进程。通常情况下，新的进程会立即执行新的程序。</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p><code>exec</code>并非一个单独的函数，而是由<code>exec</code>开头的一系列系统调用。它们都用于加载指定的二进制程序，并替换当前的进程来运行。先来看文档：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205184100.png" alt=""></p>
<p>由于函数比较多，我们先拿第一个来举例。<code>execl</code>用于加载参数<code>path</code>指定的二进制文件到内存中，并替换当前进程，<code>arg</code>是该程序的参数列表，有一个或多个，参数列表必须以NULL结尾。通常情况下，<code>execl</code>不会返回。调用成功时，会跳转到新的程序入口点，而刚刚运行的代码是不再存在于进程的地址空间中。错误时，<code>execl</code>会返回-1，并设置相应的errno值。下面来举个例子，我们用<code>ls</code>命令来替换当前的进程运行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始执行\n"</span>);</span><br><span class="line">    ret = execl(<span class="string">"/bin/ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"execl"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"执行结束\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开始执行</span><br><span class="line">总用量 72</span><br><span class="line">-rw---S--T 1 noir noir   530 12月  2 01:53 backup.c</span><br><span class="line">-rw-rw-r-- 1 noir noir 22760 11月 28 15:59 CMakeCache.txt</span><br><span class="line">drwxrwxr-x 5 noir noir  4096 12月  5 02:44 CMakeFiles</span><br><span class="line">-rw-rw-r-- 1 noir noir  1533 11月 28 15:59 cmake_install.cmake</span><br><span class="line">-rw-rw-r-- 1 noir noir  4991 12月  2 01:44 Makefile</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>有几点需要注意：</p>
<ul>
<li>上面的输出打印了<code>开始执行</code>，却没有打印<code>执行结束</code>。这是因为当载入新程序执行后，原有进程会被替代，即便还有后续可执行的代码，也会被忽略</li>
<li>虽然当前进程被新程序所替代，但进程大部分属性依然保持不变，如：pid、ppid、进程优先级、所属用户和所属组等</li>
<li>按照惯例，<code>arg</code>的第一个参数应该是程序的名称，当执行新进程时，该名称将被放入新进程的第一个参数<code>argv[0]</code>中，程序解析<code>argv[0]</code>后，就可知道二进制程序的名字了</li>
</ul>
<p>关于上面第三点，我们可以写两段代码来验证<code>exec</code>系列函数的参数传递。首先来写一段代码用来输出从<code>argv</code>中获取的参数列表，我们通过<code>gcc parse.c -o parse</code>将其编译为<code>parse</code>二进制文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们通过<code>execl</code>来调用<code>parse</code>，传入参数后，让其输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始执行\n"</span>);</span><br><span class="line">    ret = execl(<span class="string">"../parse"</span>, <span class="string">"parse"</span>, <span class="string">"-arg1"</span>, <span class="string">"-arg2"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"execl"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"执行结束\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始执行</span><br><span class="line">parse</span><br><span class="line">-arg1</span><br><span class="line">-arg2</span><br></pre></td></tr></table></figure>

<p>可见，<code>arg</code>参数被原封不动地传递到了<code>parse</code>程序的<code>argv</code>参数列表中。</p>
<h4 id="其他exec函数"><a href="#其他exec函数" class="headerlink" title="其他exec函数"></a>其他exec函数</h4><p>除了<code>execl</code>外，<code>exec</code>系还有其他5个函数，分别是：<code>execlp</code>、<code>execle</code>、<code>execv</code>、<code>execvp</code>、<code>execve</code>。这些函数很容易记住。<code>l</code>和<code>v</code>分别表示参数是以列表方式还是数组方式提供的。<code>p</code>表示会在用户的环境变量<code>path</code>下查找可执行文件。使用了<code>p</code>的函数可以只指定文件名，该文件必须在用户环境变量下。最后，<code>e</code>表示会为新进程提供新的环境变量。奇怪的是，<code>exec</code>函数中没有一个同时可以搜索路径和使用新环境变量的函数，虽然从技术角度看完全可以实现它。这可能是因为带<code>p</code>的<code>exec</code>函数主要是用于shell的，因为shell执行的进程通常会从shell本身继承环境变量。</p>
<p>和之前演示的例子一样，以下代码使用<code>execvp</code>来执行<code>ls</code>，它要求<code>ls</code>必须在<code>path</code>路径下，并且参数采用数组来提供：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *arg[] = &#123;<span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"-a"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    ret = execvp(<span class="string">"ls"</span>, arg);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"execvp"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出与之前<code>execl</code>演示的结果一致。</p>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p><code>fork</code>调用可以创建一个子进程，先来看看函数定义：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191205215359.png" alt=""></p>
<p>当<code>fork</code>调用成功时，它会创建一个几乎与父进程完全相同的子进程。父子进程会以<code>fork</code>的调用点为起点，分别继续运行。在父进程中，<code>fork</code>会返回子进程的<code>pid</code>，而在子进程中，<code>fork</code>会返回0。出错时，不会创建子进程，<code>fork</code>返回-1，并设置相应errno值。来看一段代码演示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process pid:%d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process ppid:%d\n"</span>, getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处休眠1秒，防止父进程过快终止</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent process pid:%d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent process ppid:%d\n"</span>, getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">child process pid:31033</span><br><span class="line">child process ppid:31032</span><br><span class="line">after</span><br><span class="line">parent process pid:31032</span><br><span class="line">parent process ppid:1936</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<p>上面的代码和输出有几处需要额外注意：</p>
<ul>
<li>子进程的ppid其实也就是父进程的pid</li>
<li>before只打印了一次是因为它处于<code>fork</code>之前，而after打印了两次是因为<code>fork</code>之后子进程和父进程都有一份打印代码</li>
<li>在父进程中我们休眠了一秒，是为了防止父进程在<code>fork</code>后过早结束本身运行状态，而子进程还未执行完</li>
</ul>
<p>通常情况下，会使用<code>fork</code>创建一个新的进程，然后再通过<code>exec</code>载入二进制文件，以替换<code>fork</code>出的新进程运行。将创建进程与执行二进制文件分离是一个非常好的设计。这样你就无需在<code>fork</code>出的子进程代码段中编写大量代码，而是可以编写独立的程序。这就好比我们在shell中执行命令，无需知道每个具体命令的实现，shell只需要为该命令创建一个新进程，然后把命令和相关参数丢进去执行即可。下面我们来写一段代码，演示如何在<code>fork</code>出的新进程中通过<code>exec</code>来执行<code>ls</code>命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        ret = execlp(<span class="string">"ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"-a"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"execlp"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处休眠1秒，防止父进程过快终止</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">总用量 80</span><br><span class="line">drwxrwxr-x 3 noir noir  4096 12月  5 17:10 .</span><br><span class="line">drwxrwxr-x 5 noir noir  4096 12月  5 17:10 ..</span><br><span class="line">-rw---S--T 1 noir noir   530 12月  2 01:53 backup.c</span><br><span class="line">-rw-rw-r-- 1 noir noir 22760 11月 28 15:59 CMakeCache.txt</span><br><span class="line">drwxrwxr-x 5 noir noir  4096 12月  5 17:10 CMakeFiles</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h4><p>上面的例子中需要让父进程休眠1秒，以便留给子进程足够的时间执行完。假设现在子进程进行的任务非常繁重且耗时，那么父进程应该休眠几秒？答案是不确定，我们应该让父进程等待子进程执行完。通过<code>vfork</code>可以做到这点，但是<code>vfork</code>是一个不推荐使用的函数。我们先看<code>vfork</code>的用法，然后再说明为何不推荐使用。</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206093458.png" alt=""></p>
<p><code>vfork</code>的调用和返回与<code>fork</code>相同，但使用<code>vfork</code>能保证子进程先运行，在它调用<code>exec</code>或<code>_exit</code>之后父进程才会继续运行。我们用这样一个特性来改写上面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = vfork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        ret = execlp(<span class="string">"ls"</span>, <span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="string">"-a"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"execlp"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程不做任何操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果与之前一样，但是父进程不需要再休眠。除了上面所说的运行特点，<code>fork</code>和<code>vfork</code>还有一个差别：同样是创建子进程，<code>fork</code>会把父进程的内存数据拷贝到子进程中；而<code>vfork</code>则是和父进程共享内存数据。我们之前有说过<code>fork</code>会创建一个与当前进程一样的子进程。所谓一样就是指内存数据一样。而实际应用中，大部分场景是<code>fork</code>一个新的子进程，然后直接通过<code>exec</code>载入二进制文件执行，根本不需要进行内存数据拷贝，因此共享父进程的就可以了。</p>
<p>于此同时，<code>vfork</code>这些特点也带来了些弊端：</p>
<ul>
<li>如果<code>exec</code>调用失败，那么父进程就会被一致挂起</li>
<li>在子进程中不能使用<code>return</code>或<code>exit</code>进行终止。由于是共享父进程内存数据，当使用<code>return</code>时，会从<code>main</code>函数返回，导致函数栈空间被清空，所以回到父进程继续运行时，栈空间会错乱。如果使用<code>exit</code>，那么它会清理父进程的标准I/O。子进程正确的退出方式是使用<code>_exit</code></li>
</ul>
<p>由于<code>vfork</code>所带来的这些隐患，所以它不推荐被使用。</p>
<h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p><code>vfork</code>由于没有直接的内存数据拷贝操作，所以性能非常好，但同时也带来很多危险。为了弥补<code>fork</code>拷贝内存数据所带来的性能开销，现代UNIX系统采用了写时复制(copy-on-write)的方式，而不是对父进程内存数据进行整体复制。</p>
<p>写时复制是一种基于惰性算法的优化策略，为了避免复制时的开销。其前提假设很简单：如果有多个进程要读取它们自己那部分资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有一个进程修改自己的副本，每个进程就好像独占那个资源，从而避免了复制带来的开销。如果某个进程想要修改自己的那份资源副本，就会开始复制该资源，并把副本提供给这个进程。这个进程后面就可以反复修改其持有的副本，而其他进程还是共享原来那份没有修改过的资源。这就是写时复制这个名称的由来：只有在写入时才执行复制。</p>
<h3 id="等待进程终止"><a href="#等待进程终止" class="headerlink" title="等待进程终止"></a>等待进程终止</h3><p>通过<code>vfork</code>可以使父进程挂起，等待子进程执行完再继续运行。但是<code>vfork</code>毕竟会带来一些危险性，并且其无法获取子进程执行完后的状态信息。这个时候我们需要使用<code>wait</code>系列系统调用，它们用于等待进程状态改变：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206112528.png" alt=""></p>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>先来看<code>wait</code>，调用<code>wait</code>成功时，会返回已终止子进程的pid；出错时，返回-1。如果没有子进程终止，调用会阻塞，直到有一个子进程终止。如果子进程已经终止了，调用会立即返回。如果<code>wstatus</code>指针不是NULL，那它包含了关于子进程的一些其他信息。这些信息可以根据以下宏来解释：</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>WIFEXITED(status)</td>
<td>若子进程正常终止，返回真。此时可通过WEXITSTATUS(status)获取子进程传送给exit或_exit参数的低8位</td>
</tr>
<tr>
<td>WIFSIGNALED(status)</td>
<td>若子进程被信号终止，返回真。此时可通过WTERMSIG(status)获取信号编号。若进程收到信号时产生终止进程的core文件，则WCOREDUMP(status)返回真</td>
</tr>
<tr>
<td>WIFSTOPPED(status)</td>
<td>若当前子进程停止运行，返回真。此时可通过WSTIOPSIG(status)获取使进程终止的信号编号</td>
</tr>
<tr>
<td>WIFCONTINUED(status)</td>
<td>若当前子进程继续运行，返回真。</td>
</tr>
</tbody></table>
<p>下面我们写一个例子来演示，创建一个新的子进程，休眠60秒。然后在父进程中等待其终止状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">60</span>);</span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"正常终止，终止状态码：%d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"被信号终止，信号编码：%d\n"</span>, WTERMSIG(status));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"是否生成coredump文件：%d\n"</span>, WCOREDUMP(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"被信号暂停，信号编码:%d\n"</span>, WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFCONTINUED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"继续运行\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当程序正常终止会输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正常终止，终止状态码：1</span><br></pre></td></tr></table></figure>

<p>通过<code>kill -15 41782</code>命令尝试为该进程发送终止信号，则输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">被信号终止，信号编码：15</span><br><span class="line">是否生成coredump文件：0</span><br></pre></td></tr></table></figure>

<h4 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h4><p>通常情况下，一个进程会有多个子进程，如果父进程想等待其中一个子进程，一个方法是多次调用<code>wait</code>，然后每次根据返回值来判断是否为需要等待的子进程。但这种方法并不太灵活，通过<code>waitpid</code>可以指定等待的子进程，并且它额外的参数可以支持更细粒度的调整。<code>waitpid</code>函数定义上图已经列出。</p>
<p>参数<code>pid</code>指定要等待的一个或多个进程的<code>pid</code>，它的值必须是下面四种情况之一：</p>
<ul>
<li><code>&lt;-1</code> 等待一个指定进程组中的任何子进程退出，该进程组的ID等于<code>pid</code>的绝对值。比如，传递参数值-500，表示等待在进程组500中的任何子进程</li>
<li><code>-1</code> 等待任何一个子进程退出，行为和<code>wait</code>一致</li>
<li><code>0</code> 等待同一个进程组中的任何子进程</li>
<li><code>&gt;0</code> 等待进程<code>pid</code>等于<code>pid</code>的子进程。比如，传递参数值500，表示等待<code>pid</code>为500的子进程</li>
</ul>
<p>参数<code>wstatus</code>的作用和<code>wait</code>函数中的是一样的，并且也可以只用之前讨论过的宏。</p>
<p>参数<code>options</code>是0个或多个以下选项按二进制或运算的结果：</p>
<ul>
<li>WNOHANG 不要阻塞，如果要等待的子进程还没有结束、停止或继续运行，会立即返回</li>
<li>WUNTRACED 如果设置该位，即使调用进程没有跟踪子进程，也会设置返回调用参数中的WIFSTOPPED位</li>
<li>WCONTINUED 如果设置该位，即使是调用进程没有跟踪子进程，也会设置返回调用参数中的WIFCONTINUED位</li>
</ul>
<p>调用成功时，<code>waitpid</code>返回状态发生改变的那个进程的<code>pid</code>。如果设置了WNOHANG参数，并且要等待的一个或多个子进程的状态还没有发生改变，<code>waitpid</code>返回0。出错时，调用返回-1，并设置相应的errno值。下面通过代码来演示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">60</span>);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        waitpid(pid, &amp;status, WUNTRACED|WCONTINUED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"正常终止，终止状态码:%d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"被信号暂停，信号编码:%d\n"</span>, WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFCONTINUED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"继续运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行后，我们尝试通过<code>kill -STOP 3888</code>给新创建的子进程发送信号，让其停止运行，输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被信号暂停，信号编码:19</span><br></pre></td></tr></table></figure>

<h3 id="创建并等待新进程"><a href="#创建并等待新进程" class="headerlink" title="创建并等待新进程"></a>创建并等待新进程</h3><p>如果一个进程创建了新进程并且立即开始等待它的结束，那么除了<code>vfork</code>和<code>wait</code>，还有另一种实现方式，即使用<code>system</code>函数</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206161937.png" alt=""></p>
<p><code>system</code>函数会使用<code>fork</code>创建一个子进程，然后在其内部通过<code>execl</code>系统调用去执行<code>command</code>所指定的命令，调用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, command, (<span class="keyword">char</span> *) <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>成功时，返回值是执行<code>command</code>命令得到的返回状态，该状态和执行<code>waitpid</code>所获取的状态一致。因此，可以通过WEXITSTATUS获取执行<code>command</code>命令的返回值。如果调用<code>/bin/sh</code>本身失败了，那么从WEXITSTATUS返回的值和调用exit(127)的返回值是一样的。因为也可能是调用的命令返回了127，但没有办法来检测是shell本身发生了错误还是调用<code>command</code>命令执行失败而返回127。失败时，<code>system</code>调用会返回-1。如果参数<code>command</code>是NULL且<code>/bin/sh</code>是可用的，<code>system</code>会返回一个非0值，否则返回0。我们通过一段代码来演示，如何使用<code>system</code>来调用<code>ls</code>并获取返回值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    status = system(<span class="string">"ls -l -a"</span>);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"system"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"正常终止，终止状态码:%d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">总用量 80</span><br><span class="line">drwxrwxr-x 3 noir noir  4096 12月  6 00:38 .</span><br><span class="line">drwxrwxr-x 5 noir noir  4096 12月  6 00:38 ..</span><br><span class="line">-rw---S--T 1 noir noir   530 12月  2 01:53 backup.c</span><br><span class="line">-rw-rw-r-- 1 noir noir 22760 11月 28 15:59 CMakeCache.txt</span><br><span class="line">...</span><br><span class="line">正常终止，终止状态码:0</span><br></pre></td></tr></table></figure>

<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>当子进程结束后，它的父进程还未获取其状态，那么这个进程就叫做僵尸进程。僵尸进程会消耗少量资源用于保存进程之前的一些状态信息。一旦父进程通过<code>waitpid</code>等方式得到此信息，那么内核就会将子进程销毁。下面用一段代码演示子进程到僵尸进程的转化过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子进程结束\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span> (pid == wait(<span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"子进程已被回收\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"父进程结束\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行后，我们可以通过<code>ps -ao pid,ppid,stat,cmd | grep zombie</code>（zombie是我们编译出的二进制程序）查看进程状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 程序开始执行，此时两个进程都在休眠状态</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep zombie</span><br><span class="line">  7354   3411 S+   ./zombie</span><br><span class="line">  7355   7354 S+   ./zombie</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序运行到第10秒，此时子进程结束，变成僵尸进程</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep zombie</span><br><span class="line">  7354   3411 S+   ./zombie</span><br><span class="line">  7355   7354 Z+   [zombie] &lt;defunct&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序运行到第20秒，此时子进程已被回收，只剩下父进程</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep zombie</span><br><span class="line">  7354   3411 S+   ./zombie</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序又运行10秒，此时父进程已经退出</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep zombie</span><br></pre></td></tr></table></figure>

<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>与僵尸进程对应的是孤儿进程，它是指父进程在等待子进程结束之前就已经结束自身。无论何时，只要有进程结束了，内核就会遍历它的所有子进程，并且把它们的父进程重新设置为init进程（即pid为1的那个进程）。这保证了系统中不存在没有父进程的进程，从而使得每个子进程最终都能正常退出。下面我们通过代码来演示子进程到孤儿进程的转化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"子进程结束\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"父进程结束\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行后，同样我们通过<code>ps -ao pid,ppid,stat,cmd | grep orphan</code>查看进程状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 程序开始执行，此时两个进程都在休眠</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep orphan</span><br><span class="line">  7989   5753 S+   ./orphan</span><br><span class="line">  7990   7989 S+   ./orphan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序运行到第10秒，此时父进程结束，子进程变成孤儿进程，内核将其ppid重设为1</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep orphan</span><br><span class="line">  7990      1 S    ./orphan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序运行到第20秒，子进程也结束</span></span><br><span class="line">➜  ~ ps -ao pid,ppid,stat,cmd | grep orphan</span><br></pre></td></tr></table></figure>

<h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><p>在Linux系统中，每个进程都有用户ID和组ID，它们限定了该进程可以执行哪些操作。可以通过下面4个系统调用可以查看用户ID和组ID：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206220925.png" alt=""></p>
<p><img src="C:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191206220814857.png" alt="image-20191206220814857"></p>
<p>这四个系统调用总会成功执行，因此无需进行错误判断，下面通过代码来演示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uid_t</span> uid, euid;</span><br><span class="line">    <span class="keyword">gid_t</span> gid, egid;</span><br><span class="line"></span><br><span class="line">    uid = getuid();</span><br><span class="line">    euid = geteuid();</span><br><span class="line"></span><br><span class="line">    gid = getgid();</span><br><span class="line">    egid = getegid();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uid:%d\n"</span>, uid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"euid:%d\n"</span>, euid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"gid:%d\n"</span>, gid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"egid:%d\n"</span>, egid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uid:1000</span><br><span class="line">euid:1000</span><br><span class="line">gid:1000</span><br><span class="line">egid:1000</span><br></pre></td></tr></table></figure>

<p>上面的用户ID和组ID对应数值的名称可以在<code>/etc/passwd</code>和<code>/etc/group</code>文件中找到。为何用户ID和组ID都分别有两个？因为其含义不同，以上四个ID分别表示：实际用户ID、有效用户ID、实际用户组、有效用户组。</p>
<p>实际用户ID是指运行当前进程的用户uid，这个uid往往通过继承父进程而来。有效用户ID是当前进程所使用的用户ID，一般用于权限验证。事实上，远不止这两个id，其他id可以通过命令<code>ps -ao pid,uid,euid,gid,egid,ruid,suid,cmd</code>来查看，这里不再一一解释：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PID   UID  EUID   GID  EGID  RUID  SUID CMD</span><br><span class="line">1708  1000  1000  1000  1000  1000  1000 /usr/lib/xorg/Xorg vt2 </span><br><span class="line">1717  1000  1000  1000  1000  1000  1000 /usr/lib/gnome-session/gnome-session-binary </span><br><span class="line">1859  1000  1000  1000  1000  1000  1000 /usr/bin/gnome-shell</span><br><span class="line">1918  1000  1000  1000  1000  1000  1000 ibus-daemon --xim --panel disable</span><br><span class="line">1922  1000  1000  1000  1000  1000  1000 /usr/lib/ibus/ibus-dconf</span><br><span class="line">1923  1000  1000  1000  1000  1000  1000 /usr/lib/ibus/ibus-extension-gtk3</span><br><span class="line">1925  1000  1000  1000  1000  1000  1000 /usr/lib/ibus/ibus-x11 --kill-daemon</span><br></pre></td></tr></table></figure>

<p>为何需要这么多ID呢？实际上是因为进程在运行时对于权限的需求是变化的，有可能在进程初期需要较大权限，如将用户id和组id改为root；而后，当不需要这么大权限时，本着最小权限原则，应该再将用户id和组id的权限进行降级操作。不同的id实际上是对应了进程运行的各个不同周期。一般而言，root用户可以将用户ID和组ID改为任一需要的权限，而普通用户只能在已继承的不同周期的用户权限间进行修改。</p>
<p>通过以下四个系统调用我们可以用于更改实际用户ID、实际用户组ID、有效用户ID和有效组ID：</p>
<p><img src="C:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191206224901577.png" alt="image-20191206224901577"></p>
<p><img src="C:%5CUsers%5CNoir%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191206224932557.png" alt="image-20191206224932557"></p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191206225016.png" alt=""></p>
<p>执行成功时，四个调用都返回0，失败时返回-1，并设置相应的errno值。下面通过代码来演示如何修改有效用户ID，其余几个函数用法类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = seteuid(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ret"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"修改成功，当前有效用户ID为:%d\n"</span>, geteuid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果我们想把当前进程的有效用户ID设置为root，那么运行此进程的时候必须是root用户，或者有root权限。</p>
<h3 id="会话和进程组"><a href="#会话和进程组" class="headerlink" title="会话和进程组"></a>会话和进程组</h3><p>正如同你是你家庭的一份子，每个进程都属于一个进程组。而进程组内首进程的<code>pid</code>，也就是进程组的ID。进程组的一大好处是，当你给进程组发送信号的时候，会发送给进程组内的所有进程。比如在进行作业控制的时候，你可以通过一个操作，让组内所有进程终止、暂停或是继续运行。</p>
<p>而多个进程组在一起则组合成了会话。通常情况下，当有新用户登录计算机，那么登录进程就会为该用户创建一个新的会话，这个新的会话包含一个单进程，即用户的登录shell。登录shell会作为会话的首进程，会话首进程的pid也就是会话ID。会话囊括了登录用户的所有活动，并分配给用户一个控制终端来处理用户的I/O行为。事实上，我们如今的控制终端与所使用的shell已经近似于一个概念。</p>
<p>系统中往往存在多个会话，每个用户的登录都是一个会话，但还有一些是与用户登录会话无关的进程（例如守护进程）。守护进程往往会创建自己的会话，从而避免与其他存在的会话产生关系。每个会话都包含一个或多个进程组，而且每个进程组至少包含一个进程。包含多个进程的进程组通常是为了完成一系列任务而存在。</p>
<p>在登录时，shell会创建新的会话，通过<code>setsid</code>系统调用完成：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191207104401.png" alt=""></p>
<p>假如调用进程不是某个进程组首进程，调用<code>setsid</code>会创建新的会话，并在该会话内创建新的进程组，调用进程就是新会话和新进程组内的唯一进程，会话ID和进程组ID都被设置为调用进程的pid，此会话没有控制终端。这个特性对于守护进程而言非常有用，因为它不想是任何已存在会话的成员，也不想拥有控制终端。对于shell来说，它也很有用，因为shell希望为每一个登录的用户创建新的会话。</p>
<p>成功时，<code>setsid</code>会返回新会话的会话ID。出错时，返回-1，并设置相应的errno值。下面通过代码来演示如何在子进程中开启一个新的会话：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"当前父进程会话ID：%d\n"</span>, getsid(<span class="number">0</span>));</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前子进程会话ID：%d\n"</span>, getsid(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (setsid() == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"setsid"</span>);</span><br><span class="line">            _exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"创建新会话成功,当前会话ID:%d\n"</span>, getsid(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前父进程会话ID：1706</span><br><span class="line">当前子进程会话ID：1706</span><br><span class="line">创建新会话成功,当前回话ID:21891</span><br></pre></td></tr></table></figure>

<p>上面用到了一个系统调用<code>getsid</code>用于获取当前进程的会话ID：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191207112659.png" alt=""></p>
<p>当参数<code>pid</code>为0，就返回调用进程的会话ID。出错时，返回-1，并设置相应的errno值。通常情况下，这一系统调用并不常用，它主要用于诊断问题。</p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程运行在后台，不与任何控制终端相关联。守护进程通常在系统启动时就运行，它们以root用户或者其他特殊的用户（例如nginx或ssh)运行，并处理一些系统级的任务。习惯上守护进程的名字通常以d结尾(如crond和sshd)，但这不是必需的，甚至不是通用的。对于守护进程，有两个基本要求：一是必须作为init进程的子进程运行，一是不与任何控制终端交互。</p>
<p>一般而言，进程可以通过以下步骤成为守护进程：</p>
<ol>
<li>调用fork，创建新的子进程</li>
<li>在父进程中调用exit</li>
<li>调用<code>setsid</code>，创建新的会话和进程组，并把当前子进程作为会话的首进程</li>
<li>调用<code>chdir</code>，将当前工作目录改为根目录。以防止当前继承而来的工作目录所在的文件系统无法被正常卸载</li>
<li>关闭所有文件描述符</li>
<li>打开文件描述符0、1、2，并把他们重定向到/dev/null</li>
</ol>
<p>以下是一个编写守护进程的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 创建新进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 退出父进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新会话和新进程组</span></span><br><span class="line">    <span class="keyword">if</span> (setsid() == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsid"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置工作目录为根</span></span><br><span class="line">    <span class="keyword">if</span> (chdir(<span class="string">"/"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"chdir"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭所有文件描述符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">close</span>(i) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重定向文件描述符0 1 2 到/dev/null</span></span><br><span class="line">    <span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">    dup(<span class="number">0</span>);</span><br><span class="line">    dup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下为守护进程自己的任务</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，很多UNIX系统在C库中提供了<code>daemon</code>函数来自动完成这些工作：</p>
<p><img src="https://share-1300759451.cos.ap-beijing.myqcloud.com/blog-image/20191205/20191207122136.png" alt=""></p>
<p>如果参数<code>nochdir</code>为非0值，就不会将工作目录改为根目录。如果参数<code>noclose</code>为非0值，就不会关闭所有打开的文件描述符。成功时，返回0。失败时，返回-1，并设置相应的errno值。</p>

    </div>

    
    
    
      
        <div class="reward-container">
  <div>请作者喝杯咖啡？</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Linxiao 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Linxiao 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Linxiao
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://linxiao.pro/2019/12/07/linux-programming-process-basic/" title="linux系统编程-进程管理">https://linxiao.pro/2019/12/07/linux-programming-process-basic/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"><i class="fa fa-tag"></i> 并发</a>
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C</a>
              <a href="/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 系统编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/12/04/linux-programming-sys-info/" rel="next" title="linux系统编程-系统属性">
                  <i class="fa fa-chevron-left"></i> linux系统编程-系统属性
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2019/12/10/linux-programming-signal/" rel="prev" title="linux系统编程-信号">
                  linux系统编程-信号 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程ID"><span class="nav-text">进程ID</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取进程ID和父进程ID"><span class="nav-text">获取进程ID和父进程ID</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#终止进程"><span class="nav-text">终止进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#退出函数"><span class="nav-text">退出函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#atexit"><span class="nav-text">atexit</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行新进程"><span class="nav-text">运行新进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#exec"><span class="nav-text">exec</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他exec函数"><span class="nav-text">其他exec函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fork"><span class="nav-text">fork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vfork"><span class="nav-text">vfork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写时复制"><span class="nav-text">写时复制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待进程终止"><span class="nav-text">等待进程终止</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#wait"><span class="nav-text">wait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#waitpid"><span class="nav-text">waitpid</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建并等待新进程"><span class="nav-text">创建并等待新进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#僵尸进程"><span class="nav-text">僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#孤儿进程"><span class="nav-text">孤儿进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户和组"><span class="nav-text">用户和组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#会话和进程组"><span class="nav-text">会话和进程组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#守护进程"><span class="nav-text">守护进程</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Linxiao"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Linxiao</p>
  <div class="site-description" itemprop="description">半醒半醉日复日，花落花开年复年</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Linxiao42" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;Linxiao42" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Linxiao</span>
</div>

        






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            leancloudSelector(url).innerText = time;
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=lRaS7JronjiApi73k5iWP8xD-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'lRaS7JronjiApi73k5iWP8xD-gzGzoHsz',
            'X-LC-Key': 'mJ0pFWRQroOumHbNkCV5ohp8',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
        if (localhost.test(document.URL)) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>






        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'lRaS7JronjiApi73k5iWP8xD-gzGzoHsz',
    appKey: 'mJ0pFWRQroOumHbNkCV5ohp8',
    placeholder: "Just go go",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
